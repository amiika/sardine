{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sardine: Python based live coding library with MIDI and OSC support \u2728 \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u255a\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591 \u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d Sardine is a Python library tailored for musical live coding. It can turn Python into a fun music instrument and/or stage control tool for electronic musicians. Sardine is working on Windows/MacOS/Linux using Python 3.8+. It can send and receive MIDI, OSC and SuperDirt messages. Sardine is based on the principle of temporal recursion . It allows the execution of recursive functions synchronised with musical time. It means that you can sequence synthesizers, samples, MIDI and OSC signals or even arbitrary Python code with a strict and guaranteed timing! @swim def hop ( d = 0.5 , i = 0 ): M ( delay = 0.3 , note = '60 46 50 67' , velocity = 127 , channel = 0 ) . out ( i ) cc ( channel = 0 , control = 20 , value = randint ( 1 , 127 )) anew ( hop , d = 0.5 , i = i + 1 ) @swim def bam ( d = 0.5 , i = 0 ): S ( 'k:1_10' , cutoff = '1_10*100 2000 4000!4' , speed = '1 0.5' ) . out ( i ) again ( bam , d = choice ([ 0.5 , 0.25 ]), i = i + 1 )","title":"Home"},{"location":"#sardine-python-based-live-coding-library-with-midi-and-osc-support","text":"\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u255a\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591 \u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d Sardine is a Python library tailored for musical live coding. It can turn Python into a fun music instrument and/or stage control tool for electronic musicians. Sardine is working on Windows/MacOS/Linux using Python 3.8+. It can send and receive MIDI, OSC and SuperDirt messages. Sardine is based on the principle of temporal recursion . It allows the execution of recursive functions synchronised with musical time. It means that you can sequence synthesizers, samples, MIDI and OSC signals or even arbitrary Python code with a strict and guaranteed timing! @swim def hop ( d = 0.5 , i = 0 ): M ( delay = 0.3 , note = '60 46 50 67' , velocity = 127 , channel = 0 ) . out ( i ) cc ( channel = 0 , control = 20 , value = randint ( 1 , 127 )) anew ( hop , d = 0.5 , i = i + 1 ) @swim def bam ( d = 0.5 , i = 0 ): S ( 'k:1_10' , cutoff = '1_10*100 2000 4000!4' , speed = '1 0.5' ) . out ( i ) again ( bam , d = choice ([ 0.5 , 0.25 ]), i = i + 1 )","title":"Sardine: Python based live coding library with MIDI and OSC support \u2728"},{"location":"about/","text":"About Why Sardine? Sardine is a side-project initially conceived as a demonstration tool made for my PhD dissertation in musicology at the University of Saint-Etienne / Paris 8 University. Sardine is trying to encompass various programming paradigms and techniques used by live coders: declarative and imperative programming, DSLs for pattern processing, clock synchronisation with other tools, live cybernetic performances, etc... Obviously, I'm also trying to develop Sardine for my own usage and for my friends. Programming new tools is fun and rewarding! I am playing music with the Cookie Collective in Paris and with the Creative Code Lyon community. I am a member of TOPLAP and documentation contributor to TidalCycles . I learned programming by live coding music. The next logical step is now to code my own tool so I can share it with others and make people see the incredibly fruitful intersection between code and music. Since I started live coding a few years ago, I always wished to develop my own tool just to see how things work! Contributions Contributions of any sort are really welcome! I am not a professional developer and am just trying to do my best with Sardine! I might code things in a weird / unefficient way. Everything takes place on the main GitHub repo, website and Python package. Don't be afraid of proposing big breaking changes, I'm here for the fun!","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#why-sardine","text":"Sardine is a side-project initially conceived as a demonstration tool made for my PhD dissertation in musicology at the University of Saint-Etienne / Paris 8 University. Sardine is trying to encompass various programming paradigms and techniques used by live coders: declarative and imperative programming, DSLs for pattern processing, clock synchronisation with other tools, live cybernetic performances, etc... Obviously, I'm also trying to develop Sardine for my own usage and for my friends. Programming new tools is fun and rewarding! I am playing music with the Cookie Collective in Paris and with the Creative Code Lyon community. I am a member of TOPLAP and documentation contributor to TidalCycles . I learned programming by live coding music. The next logical step is now to code my own tool so I can share it with others and make people see the incredibly fruitful intersection between code and music. Since I started live coding a few years ago, I always wished to develop my own tool just to see how things work!","title":"Why Sardine?"},{"location":"about/#contributions","text":"Contributions of any sort are really welcome! I am not a professional developer and am just trying to do my best with Sardine! I might code things in a weird / unefficient way. Everything takes place on the main GitHub repo, website and Python package. Don't be afraid of proposing big breaking changes, I'm here for the fun!","title":"Contributions"},{"location":"showcase/","text":"Your regular Sardine session Found sound symphony Soundchecking Sardine Excerpts from early dev stages","title":"Showcase"},{"location":"showcase/#your-regular-sardine-session","text":"","title":"Your regular Sardine session"},{"location":"showcase/#found-sound-symphony","text":"","title":"Found sound symphony"},{"location":"showcase/#soundchecking-sardine","text":"","title":"Soundchecking Sardine"},{"location":"showcase/#excerpts-from-early-dev-stages","text":"","title":"Excerpts from early dev stages"},{"location":"documentation/reference/","text":"th, td { border: 2px solid var(--md-typeset-table-color); border-spacing: 0; border-bottom: none; border-left: none; border-top: none; min-width: 100%; } .md-typeset__table { width: 100%; } .md-typeset__table table:not([class]) { display: table } .md-typeset__table { line-height: 2; min-width: 100%; } .md-typeset__table table:not([class]) { font-size: .74rem; border-right: none; } .md-typeset__table table:not([class]) td, .md-typeset__table table:not([class]) th { padding: 9px; min-width: 100%; } /* light mode alternating table bg colors */ .md-typeset__table tr:nth-child(2n) { background-color: #f8f8f8; min-width: 100%; } /* dark mode alternating table bg colors */ [data-md-color-scheme=\"slate\"] .md-typeset__table tr:nth-child(2n) { background-color: hsla(var(--md-hue),25%,25%,1) min-width: 100%; } SuperDirt SuperDirt documentation is rather scarce and most of it needs to be inferred by looking at the source code. However, the behavior of most parameters is well known -- usually from experience -- by live coders. Moreover, SuperDirt can be customised freely to add custom effects and synthesizers. I'm working hard on gathering information about each and every parameter I can find :) Some of them are rather arcane. They are probably not meant to be used directly. Keep in mind that not all of them are useful and that you will likely find better options by building your own environment. Sampling Parameter Brief description Typical range amp Sound volume (linear scaling) 0 -> x gain Sound volume (exponential scaling) 0 -> 1 freq Pitch around given frequency 0 -> x midinote Pitch around given MIDI note 0 - 127 note Pitch around given note ??? octave Pitch up or down depending on octave number 0 -> x sound Implicit (first argument of S() ) -------------- begin Start position of audio playback 0 -> 1 end End position of audio playback 0 -> 1 speed Sample playback, impacts pitch. Negative will play reverse -x -> 0 -> x accelerate Rising sample playback speed (pitch glissando) -x -> 0 -> x cps Implicit (cycles per second, inherited from Tidal) -------------- loop ??? ??? delta Unused -------------- cut Cut other sounds playing on same orbit, start playing 0 or 1 legato Play sample for the given duration (without cutting others) 0 -> x pan Pan sound from left to right speaker (by default) 0 -> 1 orbit Play sound/synth on the given audio effect bus (0 - 11) 0 - 11 latency Add a latency to audio playback (in seconds) 0 -> x lag Similar to latency/offset 0 -> x offset Similar to latency/lag 0 -> x Audio effects Space Reverb Parameter Brief description Typical range room Size of the room 0 -> x size Size of the reverb - keep below 1 (inf) 0 -> 1 dry Dry/Wet balance 0 -> 1 @swim def test_fx ( d = 0.25 ): S ( 'hh' , amp = 1 , room = 's($.S)' , dry = 0.1 , size = 's($)' ) . out () a ( test_fx , d = 0.25 ) Delay The delay effect is initially built for Tidal, which is based on a cyclical time representation. However, it has been pre-configured here to work properly with Sardine . Parameter Brief description Typical range delay Wet/Dry 0 -> 1 delaytime Delay time 0 -> x delayfeedback Amount of reinjection of dry signal - don't go over 1 0 -> .99 @swim def test_fx ( d = 0.25 ): S ( 'hh' , speed = '1|2|4' , delay = 1 / 2 , delaytime = 1 / ( 2 / 3 ), delayfeedback = '0.5+(r/4)' , amp = 1 ) . out () a ( test_fx , d = 0.25 ) Phaser Not functioning as it should? Parameter Brief description Typical range phaserrate Speed of phaser (in hz) 0 -> x phaserdepth Modulation amount 0 -> x @swim def test_fx ( d = 0.25 ): S ( 'jvbass' , midinote = 'C|Eb|G|Bb' , phaserrate = '1:10' , phaserdepth = 's($*2)' , amp = 1 ) . out () a ( test_fx , d = 0.5 ) Leslie This is a simple emulation of a Leslie rotating speaker typically used in music for treating organ sounds, voices, and to add an eary tint to everything that goes through it. This is basically a way to play creatively with doppler effects. Parameter Brief description Typical range leslie Dry/Wet 0 -> x lrate Rate 0 -> x lsize Wooden cabinet size (in meters) 0 -> x @swim def test_fx ( d = 0.25 ): S ( 'jvbass' , amp = 1 , leslie = 0.9 , lrate = 0.1 , lsize = '0.1+r*2' ) . out () a ( test_fx , d = 0.25 ) Tremolo A simple tremolo effect. Parameter Brief description Typical range tremolorate Tremolo speed 0 -> x tremolodepth Depth of tremolo 0 -> x @swim def test_fx ( d = 0.25 , i = 0 ): S ( 'amencutup:[1:20]' , tremolorate = '16|32' , tremolodepth = '[0:1,0.25]' ) . out ( i ) a ( test_fx , d = 0.5 , i = i + 1 ) Granular weirdness This is a weird granular effect probably intended to serve as a building block for some other effect but you can use it as is nonetheless. It will slice your audio sample into tiny fragments of it while applying some amount of pitch-shifting on every sample. Parameter Brief description Typical range psrate Pitch-shift rate 0 -> x psdisp Pitch-shift dispersion 0 -> x @swim def test_fx ( d = 0.25 , i = 0 ): S ( 'amencutup:[1:20]' , psrate = '2' , psdisp = '[0:1,0.5]' ) . out ( i ) a ( test_fx , d = 0.5 , i = i + 1 ) Filters Parameter Brief description Typical range cutoff Low-pass filter cutoff frequency (in hertz) 0 -> x us. >2Khz hcutoff High-pass filter cutoff frequency (in hertz) 0 -> x us. < 500hz bandf Bandpass filter cutoff frequency (in hertz) 0 -> x resonance Filter resonance 0 -> 1 bandqf Bandpass resonance 0 -> x @swim def test_fx ( d = 0.25 ): S ( 'jvbass' , midinote = 'C.|C|Eb|G|Bb' , cutoff = 'r*7000' , resonance = 'r/2' , amp = 1 ) . out () a ( test_fx , d = 0.5 ) Distortion Squiz Will distort your signal, combination of multiple effects put together. It works better if you input multiples of two as parameters. Parameter Brief description Typical range squiz Amount 0, 2 -> x @swim def test_fx ( d = 0.25 ): S ( 'tabla:r*200' , cut = 1 , squiz = '0|2|4|8' , midinote = 'C|F|Bb|E5b' , amp = 1 ) . out () a ( test_fx , d = 0.5 ) Triode Very gentle distortion. I actually have no idea about how the triode parameter works. Parameter Brief description Typical range triode Distortion amount 0 -> x @swim def test_fx ( d = 0.25 ): S ( 'tabla:r*200' , cut = 1 , triode = 'r' , # comment me midinote = 'C|F|Bb|E5b' , amp = 1 ) . out () a ( test_fx , d = 0.5 ) Distort Heavy distortion that will/can wildly change the spectrum of your sound. Parameter Brief description Typical range distort Distortion amount 0 -> x @swim def test_fx ( d = 0.25 ): S ( 'sd:r*200' , cut = 1 , distort = '0|0.5' , midinote = 'C|G' , amp = 1 ) . out () a ( test_fx , d = 0.5 ) Shaping Shape is an amplifier that can enter distortion territory but with a gentle curve. It will naturally make your sound louder the more you ramp up the value. Parameter Brief description Typical range shape Amplification amount 0 -> x @swim def test_fx ( d = 0.25 , i = 0 ): S ( 'amencutup:[1:20]' , shape = '[0:1,0.1]' ) . out ( i ) a ( test_fx , d = 0.5 , i = i + 1 ) Crush A very agressive bit crushing effect. Works only when you input multiples of 2. 2 for extreme crushing, 32 for non-discernable. Parameter Brief description Typical range crush Crushing factor 0 -> x @swim def test_fx ( d = 0.25 , i = 0 ): S ( 'bd, sn, hh, sn' , crush = 4 ) . out ( i ) a ( test_fx , d = 0.5 , i = i + 1 ) Ring Modulation Can't make it work on the Sardine side. Parameter Brief description Typical range ring Ring modulation amount 0 -> x ringf Ring modulation frequency 0 -> x ringdf Modulation frequency slide 0 -> x Sardine Library Sardine is still in an early stage of development. The library is still in an unstable state. The reference will be included after the first stable release. Please refer to the Sardinopedia (code examples) or to the Tutorial section (long-form article) to learn more about Sardine and its usage.","title":"Reference"},{"location":"documentation/reference/#superdirt","text":"SuperDirt documentation is rather scarce and most of it needs to be inferred by looking at the source code. However, the behavior of most parameters is well known -- usually from experience -- by live coders. Moreover, SuperDirt can be customised freely to add custom effects and synthesizers. I'm working hard on gathering information about each and every parameter I can find :) Some of them are rather arcane. They are probably not meant to be used directly. Keep in mind that not all of them are useful and that you will likely find better options by building your own environment.","title":"SuperDirt"},{"location":"documentation/reference/#sampling","text":"Parameter Brief description Typical range amp Sound volume (linear scaling) 0 -> x gain Sound volume (exponential scaling) 0 -> 1 freq Pitch around given frequency 0 -> x midinote Pitch around given MIDI note 0 - 127 note Pitch around given note ??? octave Pitch up or down depending on octave number 0 -> x sound Implicit (first argument of S() ) -------------- begin Start position of audio playback 0 -> 1 end End position of audio playback 0 -> 1 speed Sample playback, impacts pitch. Negative will play reverse -x -> 0 -> x accelerate Rising sample playback speed (pitch glissando) -x -> 0 -> x cps Implicit (cycles per second, inherited from Tidal) -------------- loop ??? ??? delta Unused -------------- cut Cut other sounds playing on same orbit, start playing 0 or 1 legato Play sample for the given duration (without cutting others) 0 -> x pan Pan sound from left to right speaker (by default) 0 -> 1 orbit Play sound/synth on the given audio effect bus (0 - 11) 0 - 11 latency Add a latency to audio playback (in seconds) 0 -> x lag Similar to latency/offset 0 -> x offset Similar to latency/lag 0 -> x","title":"Sampling"},{"location":"documentation/reference/#audio-effects","text":"","title":"Audio effects"},{"location":"documentation/reference/#space","text":"","title":"Space"},{"location":"documentation/reference/#reverb","text":"Parameter Brief description Typical range room Size of the room 0 -> x size Size of the reverb - keep below 1 (inf) 0 -> 1 dry Dry/Wet balance 0 -> 1 @swim def test_fx ( d = 0.25 ): S ( 'hh' , amp = 1 , room = 's($.S)' , dry = 0.1 , size = 's($)' ) . out () a ( test_fx , d = 0.25 )","title":"Reverb"},{"location":"documentation/reference/#delay","text":"The delay effect is initially built for Tidal, which is based on a cyclical time representation. However, it has been pre-configured here to work properly with Sardine . Parameter Brief description Typical range delay Wet/Dry 0 -> 1 delaytime Delay time 0 -> x delayfeedback Amount of reinjection of dry signal - don't go over 1 0 -> .99 @swim def test_fx ( d = 0.25 ): S ( 'hh' , speed = '1|2|4' , delay = 1 / 2 , delaytime = 1 / ( 2 / 3 ), delayfeedback = '0.5+(r/4)' , amp = 1 ) . out () a ( test_fx , d = 0.25 )","title":"Delay"},{"location":"documentation/reference/#phaser","text":"Not functioning as it should? Parameter Brief description Typical range phaserrate Speed of phaser (in hz) 0 -> x phaserdepth Modulation amount 0 -> x @swim def test_fx ( d = 0.25 ): S ( 'jvbass' , midinote = 'C|Eb|G|Bb' , phaserrate = '1:10' , phaserdepth = 's($*2)' , amp = 1 ) . out () a ( test_fx , d = 0.5 )","title":"Phaser"},{"location":"documentation/reference/#leslie","text":"This is a simple emulation of a Leslie rotating speaker typically used in music for treating organ sounds, voices, and to add an eary tint to everything that goes through it. This is basically a way to play creatively with doppler effects. Parameter Brief description Typical range leslie Dry/Wet 0 -> x lrate Rate 0 -> x lsize Wooden cabinet size (in meters) 0 -> x @swim def test_fx ( d = 0.25 ): S ( 'jvbass' , amp = 1 , leslie = 0.9 , lrate = 0.1 , lsize = '0.1+r*2' ) . out () a ( test_fx , d = 0.25 )","title":"Leslie"},{"location":"documentation/reference/#tremolo","text":"A simple tremolo effect. Parameter Brief description Typical range tremolorate Tremolo speed 0 -> x tremolodepth Depth of tremolo 0 -> x @swim def test_fx ( d = 0.25 , i = 0 ): S ( 'amencutup:[1:20]' , tremolorate = '16|32' , tremolodepth = '[0:1,0.25]' ) . out ( i ) a ( test_fx , d = 0.5 , i = i + 1 )","title":"Tremolo"},{"location":"documentation/reference/#granular-weirdness","text":"This is a weird granular effect probably intended to serve as a building block for some other effect but you can use it as is nonetheless. It will slice your audio sample into tiny fragments of it while applying some amount of pitch-shifting on every sample. Parameter Brief description Typical range psrate Pitch-shift rate 0 -> x psdisp Pitch-shift dispersion 0 -> x @swim def test_fx ( d = 0.25 , i = 0 ): S ( 'amencutup:[1:20]' , psrate = '2' , psdisp = '[0:1,0.5]' ) . out ( i ) a ( test_fx , d = 0.5 , i = i + 1 )","title":"Granular weirdness"},{"location":"documentation/reference/#filters","text":"Parameter Brief description Typical range cutoff Low-pass filter cutoff frequency (in hertz) 0 -> x us. >2Khz hcutoff High-pass filter cutoff frequency (in hertz) 0 -> x us. < 500hz bandf Bandpass filter cutoff frequency (in hertz) 0 -> x resonance Filter resonance 0 -> 1 bandqf Bandpass resonance 0 -> x @swim def test_fx ( d = 0.25 ): S ( 'jvbass' , midinote = 'C.|C|Eb|G|Bb' , cutoff = 'r*7000' , resonance = 'r/2' , amp = 1 ) . out () a ( test_fx , d = 0.5 )","title":"Filters"},{"location":"documentation/reference/#distortion","text":"","title":"Distortion"},{"location":"documentation/reference/#squiz","text":"Will distort your signal, combination of multiple effects put together. It works better if you input multiples of two as parameters. Parameter Brief description Typical range squiz Amount 0, 2 -> x @swim def test_fx ( d = 0.25 ): S ( 'tabla:r*200' , cut = 1 , squiz = '0|2|4|8' , midinote = 'C|F|Bb|E5b' , amp = 1 ) . out () a ( test_fx , d = 0.5 )","title":"Squiz"},{"location":"documentation/reference/#triode","text":"Very gentle distortion. I actually have no idea about how the triode parameter works. Parameter Brief description Typical range triode Distortion amount 0 -> x @swim def test_fx ( d = 0.25 ): S ( 'tabla:r*200' , cut = 1 , triode = 'r' , # comment me midinote = 'C|F|Bb|E5b' , amp = 1 ) . out () a ( test_fx , d = 0.5 )","title":"Triode"},{"location":"documentation/reference/#distort","text":"Heavy distortion that will/can wildly change the spectrum of your sound. Parameter Brief description Typical range distort Distortion amount 0 -> x @swim def test_fx ( d = 0.25 ): S ( 'sd:r*200' , cut = 1 , distort = '0|0.5' , midinote = 'C|G' , amp = 1 ) . out () a ( test_fx , d = 0.5 )","title":"Distort"},{"location":"documentation/reference/#shaping","text":"Shape is an amplifier that can enter distortion territory but with a gentle curve. It will naturally make your sound louder the more you ramp up the value. Parameter Brief description Typical range shape Amplification amount 0 -> x @swim def test_fx ( d = 0.25 , i = 0 ): S ( 'amencutup:[1:20]' , shape = '[0:1,0.1]' ) . out ( i ) a ( test_fx , d = 0.5 , i = i + 1 )","title":"Shaping"},{"location":"documentation/reference/#crush","text":"A very agressive bit crushing effect. Works only when you input multiples of 2. 2 for extreme crushing, 32 for non-discernable. Parameter Brief description Typical range crush Crushing factor 0 -> x @swim def test_fx ( d = 0.25 , i = 0 ): S ( 'bd, sn, hh, sn' , crush = 4 ) . out ( i ) a ( test_fx , d = 0.5 , i = i + 1 )","title":"Crush"},{"location":"documentation/reference/#ring-modulation","text":"Can't make it work on the Sardine side. Parameter Brief description Typical range ring Ring modulation amount 0 -> x ringf Ring modulation frequency 0 -> x ringdf Modulation frequency slide 0 -> x","title":"Ring Modulation"},{"location":"documentation/reference/#sardine-library","text":"Sardine is still in an early stage of development. The library is still in an unstable state. The reference will be included after the first stable release. Please refer to the Sardinopedia (code examples) or to the Tutorial section (long-form article) to learn more about Sardine and its usage.","title":"Sardine Library"},{"location":"documentation/sardinopedia/","text":"Demonstration patterns These patterns are small songs and/or long patterns that you can copy and paste to familiarise yourself with the syntax. Change some values, comment a few lines here and there. Try to learn how to move and alter Sardine code. Play with the div amount to generate interesting rhythms. Pitch Playback speed (S) @swim def hh ( d = 0.5 , i = 0 ): S ( 'hh' , speed = '[1:8]' ) . out ( i ) again ( hh , d = 0.5 , i = i + 1 ) Changing the speed of audio playback for a given audio sample. Cheap version of tuning. Sample to pitch (S) @swim def hh ( d = 0.5 , i = 0 ): S ( 'hh' , midinote = 'C5!3, E5, G5' ) . out ( i ) again ( hh , d = 0.5 , i = i + 1 ) Pitching an audio sample relatively to a MIDI note. Sample to freq (S) @swim def hh ( d = 0.5 , i = 0 ): S ( 'hh' , freq = '100 + (r*2000)' ) . out ( i ) again ( hh , d = 0.5 , i = i + 1 ) Pitching an audio sample relatively to a given frequency (in hertz ).","title":"Sardinopedia"},{"location":"documentation/sardinopedia/#demonstration-patterns","text":"These patterns are small songs and/or long patterns that you can copy and paste to familiarise yourself with the syntax. Change some values, comment a few lines here and there. Try to learn how to move and alter Sardine code. Play with the div amount to generate interesting rhythms.","title":"Demonstration patterns"},{"location":"documentation/sardinopedia/#pitch","text":"","title":"Pitch"},{"location":"documentation/sardinopedia/#playback-speed-s","text":"@swim def hh ( d = 0.5 , i = 0 ): S ( 'hh' , speed = '[1:8]' ) . out ( i ) again ( hh , d = 0.5 , i = i + 1 ) Changing the speed of audio playback for a given audio sample. Cheap version of tuning.","title":"Playback speed (S)"},{"location":"documentation/sardinopedia/#sample-to-pitch-s","text":"@swim def hh ( d = 0.5 , i = 0 ): S ( 'hh' , midinote = 'C5!3, E5, G5' ) . out ( i ) again ( hh , d = 0.5 , i = i + 1 ) Pitching an audio sample relatively to a MIDI note.","title":"Sample to pitch (S)"},{"location":"documentation/sardinopedia/#sample-to-freq-s","text":"@swim def hh ( d = 0.5 , i = 0 ): S ( 'hh' , freq = '100 + (r*2000)' ) . out ( i ) again ( hh , d = 0.5 , i = i + 1 ) Pitching an audio sample relatively to a given frequency (in hertz ).","title":"Sample to freq (S)"},{"location":"documentation/tutorial/","text":"The tutorial is not up to date Sardine was updated quite a lot recently. The tutorial has not been fully updated to reflect changes. Please rely on the Sardinopedia for now, until I fix this long-form article :) At last! You have now installed and configured Sardine. You are up and running but you still don't know how to use Sardine ! You might not really understand what it is either. This tutorial will hopefully help you to understand what Sardine is and what it does. I will not dive deep into technical details but this will serve as an in-depth exploration of the different components of Sardine . Practical Philosophy This is Epictetus, no links with Sardine but he was teaching practical philosophy too... What you can do To be clear once and for all, Sardine is: strictly speaking, a music live coding library ( eg. TidalCycles, FoxDot, Gibber) but more trivially, it is: a musical instrument that you gradually learn to master and to tune to your liking a control tool for external audio/video devices, instruments and softwares an environment for improvising algorithmic music live by coding with Python a blank canevas for exploring musical ideas (rhythms, textures and pitch) on-the-fly On the contrary, Sardine is not (or not really ): a Digital Audio Workstation : no timeline, no click and play process, no ready-to-use patterns or presets, no way to save and recall sessions with pre-configured parameters, no way to record, process and master songs, tracks or beats. Sardine is meant to be used in parallel with such tools :) a compositional environment to write scores or to deal programatically with traditional score notation ( \u00e0 la Finale , Sibelius , Lilypond , etc...). Sardine is not meant for writing , but for playing . This would be the same thing as to ask a piano to print a musical score while you play. This doesn't mean that you can't compose things with Sardine to play them later. It just means that it doesn't deal with the traditional scoring system. If your intent is to prepare for an art installation, a techno/house gig or an experimental music recital, you can do it just fine! How you do it Sardine is an instrument/tool that you control by programming live. Your keyboard will be your main musical interface, which is pretty unusual compared to other musical practices. Sardine is a tool made to explore various live coding techniques, and a tool made to integrate with other live coding softwares and environments. For people unfamiliar with it, live coding could be said to be three distinct things: a programming technique : the art of manipulating, redefining or altering software while it runs. A technique exploring processes of hot swapping , reloading or re-compiling parts of a software stack without interruption, as part of the way the software is meant to be used. an artistic practice : promoting artistic expression throughout the use of computer code. Turning programming into a gestural and expressive act, usually meant to be shared with an audience. a subculture : a niche in the larger world of computer and electronic music. Live coding has always been there. You can trace its origins way back to the 70s if you are really looking for it :) Nowadays, live coding is mostly promoted by algoravers or by the TOPLAP collective. Try to read about it. It's a fascinating world of people happily hacking and sharing software, usually free and open source. The goal is to find the right tool for the nail you want to hammer, and build from there, turning your computer into an environment for personal artistic expression. For our case, it means that Sardine is meant to be extended, modified, specialised for what you need to do :) Sardine Clock MIDI Clock The most crucial information to know about Sardine is that everything happens because of the clock . When Sardine is imported using the command from sardine import * , an instance of the Clock class will automatically start to run in the background and will be referenced by the variable c . Clock is the main MIDI Clock. By default, if you haven't touched to the configuration, the clock will be running in active mode: it will send a MIDI clock signal for every tick on the default MIDI port. The default MIDI port will either be a virtual port named Sardine if your OS supports virtual MIDI ports or the first available MIDI Port declared by your OS. It can also be passive and made to listen to the default MIDI port if you prefer. Never override the c variable. You won't have to worry a lot about the internals. Never override any variable that is one letter long! You will likely find the following commands interesting: c.bpm : current tempo in beats per minute. c.ppqn : current PPQN (Pulses per Quarter Note, used by MIDI gear). be careful. The tempo might fluctuate based on the PPQN you choose. Assume that 24 is a default sane PPQN for most synthesizers/drum machines. c.accel : an acceleration factor for the clock, from 0 to 100 (double tempo) %. c.nudge : nudge the clock forward in time by the given amount. Usually pinged randomly until you fall back on the external click track you wish to follow. Ableton Link Clock The Link protocol is a novel open source protocol released by Ableton which allows users to synchronise their musical tempo seamlessly on a local network. While still pretty new, this method of synchronisation is now supported by a fair amount of by music software and apps, including other live coding libraries. Sardine can be made to start or follow an Ableton Link Clock that will be shared by all users on the local network. To do so, you will need to join/start a session using the c.link() method. Be mindful that the regular behavior of the clock will be altered and that you won't be able to change the tempo or alter time the way you want. Link is a collaborative clocking protocol, and there is no \"main\" tempo originating somewhere and followed by everyone, unlike MIDI. To resume the regular behavior of the clock, use the command c.unlink() . The c.link_log() function can be used to monitor the Ableton Link Clock state. Weirdness of Link Clock The Link Clock is a bit weird. It will disrupt the regular behavior of the Sardine Clock. It will stop emitting a MIDI clock signal because it cannot ensure that the clock signal will be steady. MIDI Clocks and Link Clock does not go hand in hand. It is preferable to kill every running pattern before attempting the switch from regular time to Link time. Latency and sync There are many possible reasons that could explain why your computer is not perfectly in sync with another one. To tackle this issue, Sardine is proposing a set of variables you can play with to finetune the latency of various parts of the system. If you ever encounter a synchronisation issue, try to play an event on the first beat of the bar on each computer and to play around with the following values: c.midi_nudge : in miliseconds. Nudge value for the MIDI Sender (MIDI). c.superdirt_nudge : in milliseconds. Nudge value for the SuperDirt Sender (Sound). c.nudge : in milliseconds. General nudge for the Sardine clock. There is also an additional nudge value you can configure directly in your SuperDirt configuration. Finding the right configuration is usually just a matter of exploring and finding the right values for you and the other computer you are trying to synchronise with. Be careful not to override hard limits. Your computer needs some time to process information. More info about clocks Sardine will not behave nicely if no external clock is running while in passive mode. Time is simply frozen and events will not trigger, suspended somewhere in time. You can introspect the current state of the clock using clock attributes or using the very verbose debug mode. Be careful, your terminal will be flooded by messages. After running c.debug = True , you should see something that looks like: ... BPM : 130.0 , PHASE : 15 , DELTA : 0.001726 || TICK : 495 BAR : 2 3 / 4 BPM : 130.0 , PHASE : 16 , DELTA : 0.001729 || TICK : 496 BAR : 2 3 / 4 BPM : 130.0 , PHASE : 17 , DELTA : 0.001475 || TICK : 497 BAR : 2 3 / 4 BPM : 130.0 , PHASE : 18 , DELTA : 0.000634 || TICK : 498 BAR : 2 3 / 4 BPM : 130.0 , PHASE : 19 , DELTA : 0.000614 || TICK : 499 BAR : 2 3 / 4 BPM : 130.0 , PHASE : 20 , DELTA : 0.001333 || TICK : 500 BAR : 2 3 / 4 ... Some interesting clock attributes can be accessed: c.beat : current clock beat since start. c.tick : current clock tick since start. c.bar : current clock bar since start ( 4/4 bars by default). c.phase : current phase. These clock attributes are used everywhere in Sardine as they provide the most basic interface to the clock for every component in the system. You can use them if you wish to compose more complex pieces and sequences. They are still really useful tools to craft conditionals and random number generators even though there are better and more controlled ways to access them (for instance, via the patterning system ). The meaning of sleep If you are already familiar with Python , you might have heard about or used the sleep() function. This function will halt the execution of a program for a given amount of time and resume immediately after. Sardine does not rely on Python's sleep because it is unreliable for musical purposes! Your OS can decide to introduce micro-delays, to resume the execution too late or even not sleep for the precise duration you wanted. Sardine proposes an alternative to regular Python sleep , backed by the clock system previously described, crafted by @thegamecracks. The sleep() function has been overriden to allow you to have a safe and sane, similarly working alternative for musical contexts. You can use it to stop and resume a swimming function while keeping synchronization and timing accuracy. @swim def sleeping_demo ( d = 1 ): print ( \"Doing something...\" ) sleep ( 1 ) print ( \"Doing something else...\" ) sleep ( 1 ) again ( sleeping_demo , d = 2 ) @swim def limping ( d = 4 ): S ( 'hh' ) . out () sleep ( 3 ) S ( 'bd' ) . out () again ( limping , d = 4 ) The swimming function sleeping_demo() will recurse after a delay of 2 . Think of the time you have in-between a recursion as spare time you can use and consume using sleep() . You can use that time sending the instructions that compose your swimming function. You can also do nothing for most of your time just like in limping() . You can write code in an imperative fashion, something that you might have already encountered in live coding systems such as Sonic Pi or SuperCollider Tdefs . Oversleeping is a thing Be careful ! You can oversleep and trigger a recursion while your function is still running, effectively overlapping different versions of your swimming functions : @swim def oversleep ( d = 4 ): S ( 'hh' ) . out () sleep ( 3 ) S ( 'bd' ) . out () again ( oversleep , d = 0.5 ) # Changed the value to oversleep If you are not yet familiar with the concept of recursion, or with the meaning of some of the facts presented here, keep patience. The meaning of all this will become clear after a few sections and some tests on your side :) Swimming functions To understand recursion, you must understand recursion says the old and not so funny joke... We have already used the term swimming function in the sections above without taking enough time to explain what it means precisely! In Sardine parlance, a swimming function is a function that is scheduled to be repeated by recursion. The function will call itself when it ends, and again and again. Usually, in computer science manuals, you learn that recursion always needs to end, that there must be a case where the function will exit. We have this in Sardine too but we usually want the function to continue indefinitely, as a way to generate rhythms and to build a musical groove. A swimming function will call itself, and again, and again... This is a way computer scientists and sardinists alike like to think about loops and structures like lists. To define a function as a swimming function , use the @swim decorator. The opposite of the @swim decorator is the @die decorator that will release a function from this dreadful recursive temporal loop. @swim # replace me by 'die' def bd ( d = 1 ): \"\"\"Loud bassdrum\"\"\" S ( 'bd' , amp = 2 ) . out () again ( bd , d = 1 ) # again == anew == cs If you don't manually add the recursion to the designated swimming function , the function will run once and stop. Recursion must be explicit and you should not forget about it! Forgetting the recursion loop call is another way to make a swimming function stop but not the recommended one! # Boring @swim def bd ( d = 1 ): S ( 'bd' , amp = 2 ) . out () The recursion can (and should) be used to update your arguments between each call of the swimming function . Here is an example of a very simple iterator: @swim # or die async def iter ( d = 1 , nb = 0 ): \"\"\"A simple recursive iterator\"\"\" print ( f \" { nb } \" ) again ( iter , d = 1 , nb = nb + 1 ) # 0 # 1 # 2 # 3 # 4 This is an incredibly useful feature to keep track of state between each call of your function. Swimming functions and its handling of arguments are the most basic thing you have to learn in order to use Sardine proficiently. This is the base to improvise music with variation, nuance and finesse. Temporal recursion makes it very easy to manually code LFOs, musical sequences, randomisation, etc... It will gradually become like a second nature for you to write them. Swimming functions are great but they have one BIG difference compared to a classic recursion: they are temporal recursive. They must be given a delay argument. The delay argument is actually d (shorter is better). If you don't provide it, Sardine will assume that your function uses d=1 . If you forget it on one side while using it on the other side, Sardine will jump up to your neck and try to kill you. If you ever try to give a delay of 0 , your function will immediately stop and an error message will be printed in your terminal. Not waiting is simply not an option, otherwise we would equally be able to travel back in time :) Making sound / sending information Sender objects Sender objects are the most frequent objects you will be interacting with while playing with Sardine . Senders are objects that compose a single message that can be sent out using the .out(iter=0) method. They are your main interface to the outside world ( SuperCollider / SuperDirt , MIDI or OSC ). These objects can receive various and/or arbitrary parameters depending on their purpose and specialty. These arguments can be integers ( 1 , 2 ), floats ( 1.23 , 0.123123 ) or strings ( \"baba\" , \"dada/43/baba/\" ): int / float : parameters are sent as is, they are numbers! string : interpreted by Sardine and transformed into a pattern of values. When you import Sardine , MIDISender , SuperDirtSender and OSCSender will already be available under the name M() (for MIDI ), S() (for sound or SuperDirt ) and O() (for OSC ). These objects are preconfigured objects that must be prefered to custom senders you can declare yourself (more on this later). M , O and S are three ways of interacting with the synthesis engine, your synths or other equipment/softwares. SuperDirt output The easiest way to trigger a sound with Sardine is to send an OSC message to SuperDirt . SuperDirt is designed as a tool that will convert control messages into the an appropriate action without having to deal with SuperCollider itself. Most people will use the SuperDirt output instead of plugging multiple synthesizers along with Sardine , or craft musical patches listening to OSC messages. The interface to SuperDirt is crude but fully functional. People already familiar with TidalCycles will feel at home using the S() (for SuperDirt ) object. The syntax is extremely similar for the purpose is similar, and names often match between the two systems: # A bassdrum (sample 0 from folder 'bd') S ( 'bd' ) . out () # Fourth sample, way louder! S ( 'bd' , n = 3 , amp = 2 ) . out () # Patterning a parameter (read the appropriate section) S ( 'bd' , n = 3 , amp = 1 , speed = '1,0.5' ) . out ( i ) # Introducing some Python in our parameters from random import random , randint S ( 'bd' if random () > 0.5 else 'hh' , speed = randint ( 1 , 5 )) Delayed messages You can pre-declare a sound before sending it out. This allows you to build your messages incrementely before sending them out using the .out() method. @swim def delayed ( d = 0.5 ): sound = S ( 'bd' ) if sometimes (): sound . shape ( 0.5 ) else : sound . speed ( 4 ) sound . out () again ( delayed ) Do not use the assign operator ( = ). Call the attribute directly (eg: amp() ). Any attribute can be set but they are not checked for validity. This is an useful feature if you prefer to write your code in an imperative fashion. There are other things to know about delayed composition: attributes can be chained: S('cp').speed('1 2').room(0.5).out() attributes will be parsed. You can write patterns just like you do when you send the objet out directly. Attributes are not checked for validity. You can really write anything so be careful: spell out the SuperDirt attribute names correctly. This technique is also really interesting if you like to pre-compose things before playing them. You can write some additional code to store libraries of prepared audio samples matching with some custom parameters. Orbits You will soon find out that you can assign effects to audio samples played using S() such as a reverb, a low-pass filter or a bitcrusher. Some of these effects are local . They only affect the sound you are currently playing. Some other effects are global . They will affect all the sounds running through the same audio bus. This is an important distinction to keep in mind! To specify which bus you would like to use for a given sound, use the orbit argument. orbit is a very important argument. Actually, it is the only argument that is specified by default. You can run a sound through a very heavy and long-tailed reverb while having, concurrently, another dry sound by switching orbits: S ( 'clap' , room = 0.9 , dry = 0.1 , size = 0.9 , orbit = 0 ) . out () S ( 'bd' , orbit = 3 ) . out () The number of orbits at your disposition is declared on the SuperDirt side in your configuration file. More on this later on! In the meantime, check out the SuperDirt GitHub repository if you would like to learn more about it. MIDI Output The MIDISender object is structurally similar to the SuperDirtSender object. It is specialized in writing/sending MIDI notes and MIDI notes only. Other MIDI events are handled differently by specific methods such as cc() (for control changes) or pgch() (for program changes). MIDI Notes messages need a duration, a velocity, a note number and a channel: duration ( seconds ): time between a note-on and note-off event (pressing a key on an imaginary keyboard). velocity ( 0-127 ): think of it as the volume amplitude of a note. channel ( 0-16 ): the MIDI channel to send that note to on your default MIDI port. note ( 0-127 ): note from the lowest possible octave on a keyboard to the highest. M ( delay = 0.2 , note = 60 , velocity = 120 , channel = 0 ) The .out() method is still used to carry a note out and to inform the sender of the value you would like to select in a pattern (see patterning). All of these values have a given default. If you don't specify anything ( M() ), you will hear a very loud middle-C on channel 0. See the MIDI section to learn more about sending out other message types such as control changes or program changes . OSC output The OSCSender is the weirdest of all the senders. It behaves and works just like the other ones but will require more work from your part. By default, the object cannot assume what OSC connexion you would like to use. For that reason, you will need to feed him one with an aditional parameter. Likewise, the sender cannot assume what address you would like to carry your message to. You will need to feed the object an address everytime you wish to send a message out. There is no default OSC connexion (except for the one used by SuperDirt and Sardine internally). To use the OSCSender object, you will have to open manually an OSC connexion before feeding it into the object: my_osc = OSC ( ip = \"127.0.0.1\" , port = 12000 , name = \"super_connexion\" , ahead_amount = 0.25 ) O ( my_osc , 'loulou' , value = '1,2,3,4' ) . out () Argument names do not matter when composing OSC messages. You can name arguments, but this will only make it easier for you to name and find values in your code. The message being caried out will not feature the name of the argument you specified. I'm still pondering if that is a nice thing or if I should find another system. If you have an opinion about it, please voice it! Composing patterns Sardine features an embedded programming language dedicated to the generation of musical patterns. Python code and pattern code go hand in hand to compose a successful and musical swimming function . This is, by far, the most intriguing aspect of Sardine . These patterns can be used to generate rhythms, streams of notes, OSC addresses, numbers, random values, etc... They can be used just anywhere a regular Python value would be expected. They replace fixed values with dynamic values, regular variables by mutating variables, etc... Think of this pattern-oriented programming language as a glorified time-dependant calculator that can also do some arithmetics on lists, with new operators such as _ , ! or : . The pattern syntax can be used for things like summoning musical scales, musical chords and applying some funny musical transformations (such as .disco or .explosion ). All of this is ma\u00efeutic , aka meant to fuel your imagination and let you explore a world of dynamic algorithmic musical patterns. Important To be precise, the pattern syntax is a fully-fleged programming language. It is distinct from Python. This programming language is embedded within Sardine . It has its own rules, its own operations, its own syntax. However, you will soon see that the syntax is much simpler than the one used by Python. There is a certain amount of communication and inter-operability between the pattern syntax and the Python code. Some variables and some iterators are shared. Information about the clock can also be accessed both in Python code and in pattern code. You will soon learn that playing around with semi-random values can generate very fruitful musical results. Composing a pattern Patterns as written as strings of values separated by commas: 1,2,3,4 , dada, baba, lala , synth/freq, synth/mod , [1:2,0.2], 5*4, s(2) , etc... It is recommended to use double quotes for your patterns, because the single quotation mark is an operator used by the pattern syntax. Patterns are lists Fundamentally, a pattern will always yield a list as a result. The most complicated pattern generation expression you can imagine will always result in a goold old Python list that you need to iterate through using an index. Senders can always receive an index, directly as the first argument of their .out() method: S('hh:[1:10], legato='r', pan='r, 1', speed='s($)*4').out(i) . To pattern, you always need an iterator and a pattern. There are multiple ways to generate iterators, whether you want to use shorthand iterators ( i.i ) or more complex iterators generated by recursion: def iter ( d = 0.5 , i = 0 ): S ( 'bd' ) . out ( i ) a ( iter , d = 0.5 , i = i + 1 ) You will see people leaning more towards a technique or another. It is of paramount importance to master the usage of iterators. You can for instance limit the range of an iterator by using a modulo operation to only iterate over a few chosen values in your pattern: def iter ( d = 0.5 , i = 0 ): S ( 'bd' , speed = [ 1 : 100 ]) . out ( i % 8 ) a ( iter , d = 0.5 , i = i + 1 ) You can also suddenly decide to iterate by decrementing and not by incrementing to reverse your pattern: i . i = [ 0 , - 1 ] def iter ( d = 0.5 ): S ( 'bd' , speed = [ 1 : 100 ]) . out ( i . i % 8 ) a ( iter , d = 0.5 ) You can be really creative with how you handle your iterators, giving you another way to create more complex patterns. The Pattern Object There is a method called P() , that can be used to write a pattern outside of a sender. This method will need two arguments: the pattern itself followed by the iterator. You can use it to introduce Sardine patterns in regular Python code. It can be particularly useful to pattern the recursion delay of your swimming functions : def iter ( d = 0.5 ): S ( 'bd' , speed = [ 1 : 100 ]) . out ( i . i % 8 ) a ( iter , d = P ( '0.5!8, 0.25!4' , i . p )) There is nothing more to know about it really. It can be particularly convenient to explore patterns by combining it with a print() statement. Value types The first important thing to learn is what the atomic values are. Atomic values are the absolute basics. They denote something that can be transformed or something upon which you can build a calculation. There are three fundamental basic types of values that can be used to compose a Sardine pattern: notes : musical notes. Symbolic names referring to a particular pitch. names : names denoting an OSC address or an audio sample file name. numbers : floating-point numbers or integers. numbers can also be information coming from the clock, shared iterators and shared variables ( eg. see the next section). All these values, even if not of the same type, can interact with one another, which means that you can write a scale and transpose it by a given factor just by doing math on it: C->penta + 2 . The main design principle Sardine is trying to follow is not to impose any limits to what you can do with values you interact with. Giving the possibility to assign things to other things freely is one way not to hinder the user and to encourage creativity. Variable values There are some values you can summon, which cannot yield a deterministic result. If you wish to add 2 to the current number of beats elapsed in the bar, the result will likely differ depending on the beat number during which the calculation takes place. Likely, you can ask Sardine what is the current value of a variable, or what the current year number is. These values are based on Sardine clock time. Depending on the moment where your recursion takes place, you might see some values recurring because you are not polling continuously but polling just a predictible moment in time. $ : tick , the tick number since the clock started. r : random , between 0 and 1. p : phase , a number between 0 and your c.ppqn. m : measure, the measure since the clock started. There are other temporal values to be accessed, but these will not be referring to Sardine time. They are just extrapolated from the current absolute time on your OS: $.Y : year, the current year. $.M : month, the current month. $.D : day, the current day. $.H : hour, the current hour. $.m : minute, the current minute. $.S : second, the current second. $.\u00b5 : microsecond, the current microsecond. Some other values are variables that can be freely altered both from the Python side and from the pattern side. They can be two things: iterators : i.a ... i.z and i.A ... i.Z , one for each letter of the latin alphabet both lowercase and uppercase. variables : v.a ... v.z and v.A ... v.Z , one for each letter of the latin alphabet both lowercase and uppercase. Iterators will yield a different result each time you call them. That is because they are counters . They increment or decrement each time they are activated by a given step. To change the current step of an iterator , you must provide them a new base value and step value as a list : i.a = [0, 5] . This example will make the iterator start from 0 and increment by 5 everytime. Iterators can also be resetted globally or invidually. The method to do so is specific to which side you are currently manipulating them (pattern or Python): Python : i.reset(\"a\") Pattern : i.a.reset You can also set your iterator to a given value: Python : i.a = 5 Pattern : i.a = 5 Variables are based on the same principle. The main difference is that they don't increment everytime you call them. They are just good old values you can use and manipulate both on the Python and pattern side. The syntax for their usage is strictly similar to the one used by iterators . Musical notes You can write notes in patterns. Notes will be converted to some MIDI value used by SuperDirt . It means that notes are numbers too and that you can do math on them if you wish to. The syntax to write notes is the following. The steps 2 and 3 can be omitted: 1) capital letter indicating the note name: C , D , E , F , G , A , B 2) flat or sharp: # , b 3) octave number: 0 .. 9 Regular names Names are just... good old names. There are some rules to know but it is really easy to remember: a single letter is not a name. a name cannot start with a number. Here is a list of some valid names you could use: dada , kqsdlkj321 or hellyearhsardineiscool2 . Most of the time, these names will correspond to a given sample name in your library. Be sure to name your sample folders accordingly to respect these rules. OSC Addresses Addresses and names are really similar, but they can also be composite names, aka. two or more names separated by a right-angled slash / . They are used to write OSC addresses, which usually adhere to this principle. Some valid addresses would look like: synth/freq/mod or robot/arm/pinky . Math but funnier The pattern syntax started out by being a very simple calculator on integers. It then spreaded out to be able to pattern a lot of things. The pattern syntax is still pretty new and I don't expect it to be final before at least a year or even more. You can safely expect that some things will change in the following days or months. In the meantime, it works and you can do really interesting things with it. It is already pretty capable of being helpful to generate the objects you expect to find in an electronic instrument: LFOs, ramps, melodic generators, etc.. Basic Arithmetics The pattern syntax includes some basic arithmetic operations that you expect to find such as + , - , * , / , // (floor division) , % (modulo). They work on almost any type of values. Of course, names and addresses do not support arithmetics very well, so don't even try to do it, it will likely crash. However, you can do arithmetics on just the numeric part of a name: dada:(2+2) . The result of this operation will be dada:4 . While being really useful for a lot of things, arithmetics become particularly fun when you start patterning random or moving values such as the tick number: $/20 . Basic functions The typical functions you can access on a scientific calculator are present in Sardine : sin and cos : sinus and cosinus functions used to compute periodc phenomenons (how convenient, just like sound). tan : tangent function. They are extremely useful for generating signal-like patterns, even though the resolution is not the greatest due to how Sardine operates. Number ranges As a shorthand, you can use the 1:10 syntax to generate a number between 1 and 10 . This is also working for floating point numbers! Number ramps You can generate ramps by surrounding two numbers with curly braces: [1:10] . This syntax will yield the following result: [1, 2, 3, 4, 5, ..., 10] . You can generate lists ramping up and down. You can also generate a ramp with a floating point range by specifying it as the third argument: [1:10,0.1] . This is really useful if you are looking to generate linear LFOs. Repeat operator The ! operator inspired by TidalCycles is used to denote the repetition of a value. You can also sometimes use the !! operator from the same family. This operator is a bit special and will be detailed later. Overflow protection Some values such as notes need to be confined in the usual range of MIDI notes, defined on 8 bytes, from 0 to 127 . Math operations on notes that should result in overflowing that limit will be wrapped around. 128 will be changed into 0, etc... Most arithmetic operations are wrapped around. If you think that it makes no sense, I feel the same too but I am waiting to find a better solution to this problem. I could probably just lock the value to its bounds. More on this in later versions. Dealing with notes The support for traditional notes is still very basic. You can write very basic melodies with Sardine , but there is no good syntax for algorithmic composition like the one you could find in a tool such as SuperCollider . This is likely to change in the future, but dealing with musical objects is always extra difficult just like in any other computer music software. There are many ways to approach this, and it can be hard to decide which one is the right one or even to impose a vision about the way to deal with traditional musical objects such as chords and notes. Notes are integers Notes in Sardine are values just any other. It means that the whole range of arithmetic operations is available to you. Internally, a note becomes a number as soon as it is parsed by the system (based on a MIDI Note to integer conversion). Note qualifiers A Sardine note can receive a specific quality. Having a quality means being chosen as the base note for building a collection (chord, scale, structure). You can print the list of available qualifiers by using the print_scales() function. To qualify a note, the right arrow operator must be used: -> . The list of available qualities is subject to change and additions. I will not reproduce it here. Here are some examples of the qualification of a note: D3b->penta , E5#->fifths , G4->messiaen1 . MIDI Sardine supports all the basic messages one can send and receive through MIDI. It will likely support every possible MIDI message in the future. By default, Sardine is always associated to a default MIDI port. It can both send and receive information from that port. If the clock is active , you already learned that clock messages will be forwarded to the default port and thus to all your connected softwares/gear. You can also open arbitrary MIDI ports as long as you know their precise name on your system. There is no function to facilitate this for now. I will not enter into the topic of finding / creating / managing virtual MIDI ports. This subject is outside the scope of what Sardine offers and you are on your own to deal with this. MIDI Out Here is an example of a swimming function sending a constant MIDI Note: @swim def hop ( d = 0.5 , i = 0 ): M ( dur = 0.3 , note = 60 , velocity = 127 , channel = 0 ) . out () a ( hop , d = 0.5 , i = i + 1 ) The default MIDI output is accessible through the M() syntax (contrary to S , it is not an object!). MIDI still need some work to support all messages coming out from the use of the same object. Note that the channel count starts at 0 , covering a range from 0 to 15 . This is unfortunate but that it how MIDI interfaces are built. The duration for each and every note should be written in milliseconds ( ms ) because MIDI is handling MIDI Notes as two separate messages (one for the note_on and one for the note_off ). Following the MIDI standard, note and velocity values are expressed in the range from 0 to 127 . Let's go further and make an arpeggio using the pattern system: @swim def hop ( d = 0.5 , i = 0 ): M ( dur = 0.3 , note = 'C,E,G,B' , velocity = 127 , channel = 0 ) . out ( i ) anew ( hop , d = 0.5 , i = i + 1 ) A similar function exists for sending MIDI CC messages. Let's combine it with our arpeggio: @swim def hop ( d = 0.5 , i = 0 ): M ( dur = 0.3 , note = '60 46 50 67' , velocity = 127 , channel = 0 ) . out ( i ) cc ( channel = 0 , control = 20 , value = P ( 'r*127' , i . v )) a ( hop , d = 0.5 , i = i + 1 ) MIDI In MIDI Input is supported through the use of a special object, the MidiListener object. This object will open a connexion listening to incoming MIDI messages. There are only a few types of messages you should be able to listen to: MIDI Notes through the NoteTarget object MIDI CC through the ControlTarget object Additionally, you can listen to incoming Clock messages ( ClockListener ) but you must generally let Sardine handle this alone. There are currently no good or valid reasons to do this! Every MidiListener is expecting a target. You must declare one and await on it using the following syntax: a = MidiListener ( target = ControlTarget ( 20 , 0 )) @swim def pluck ( d = 0.25 ): S ( 'pluck' , midinote = a . get ()) . out () a ( pluck , d = 0.25 ) In this example, we are listening on CC n\u00b0 20 on the first midi channel ( 0 ), on the default MIDI port. Sardine cannot assert the value of a given MIDI Control before it receives a first message therefore the initial value will be assumed to be 0 . You can fine tune your listening object by tweaking the parameters: # picking a different MIDI Port a = MidiListener ( 'other_midi_port' , target = ControlTarget ( 40 , 4 )) OSC You can send OSC ( Open Sound Control ) messages by declaring your own OSC connexion and sending custom messages. It is rather easy to do and should work without causing you any trouble. Manual method The following example details the simplest way to send an OSC message using Sardine. It is very crude and really not recommended at all to follow this route for there is a better one: # Open a new OSC connexion my_osc = OSC ( ip = \"127.0.0.1\" , port = 23000 , name = \"Bibu\" , ahead_amount = 0.25 ) # Recursive function sending OSC @swim def custom_osc ( d = 1 ): my_osc . send ( c , '/coucou' , [ randint ( 1 , 10 ), randint ( 1 , 100 )]) anew ( custom_osc , d = 1 ) # Closing and getting rid of the connexion cr ( custom_osc ) del my_osc Note that you always need to provide the clock as the first argument of the send() method. It is probably better to write a dedicated function to avoid having to specify the address everytime you want to send something at a specific address: def coucou ( * args ): my_osc . send ( c , '/coucou' , list ( args )) Using the OSCSender object Prefer the OscSender object, aliased to O() . The syntax is similar but you gain the ability to name your OSC parameters and you can use patterns to play around with them. Compared to S() and M() , O() requires one additional parameter: the OSC connexion previously defined. # Open a new OSC connexion my_osc = OSC ( ip = \"127.0.0.1\" , port = 23000 , name = \"Bibu\" , ahead_amount = 0.25 ) # Simple address O ( my_osc , 'loulou' , value = '1, 2, 3, 4' ) . out () O ( my_osc , 'loulou/yves' , value = '1, 2, 3, 4' ) . out () @swim def lezgo ( d = 1 , i = 0 ): O ( my_osc , 'loulou/blabla' , value = '1, 2, 3, 4' , otherv = '1, 2|4, r*2' ) . out ( i ) anew ( lezgo , i = i + 1 ) What about crashes? If you already know how to program, you know that 90% of your time is usually spent debugging code that doesn't run. You will not be a better programmer when using Sardine . Crashes will happen too, but they are handled and taken care of so that the musical flow is never truly interrupted. If you write something wrong inside a swimming function , the following will happen: if the function crashes and has never looped, it will not be recovered. if the function is already running and has already looped, the last valid function will be rescheduled and the current error message will be printed so that you can debug. It means that once you start playing something, it will never stop until you want it to. You can make music without fearing interruption because of a crash. Some mistakes might be harder than other to recover from but most of the time, you shouldn't really hear or feel any interruption in the musical flow. If that is the case, please report the bug along with a way to reproduce it easily.","title":"Tutorial"},{"location":"documentation/tutorial/#practical-philosophy","text":"This is Epictetus, no links with Sardine but he was teaching practical philosophy too...","title":"Practical Philosophy"},{"location":"documentation/tutorial/#what-you-can-do","text":"To be clear once and for all, Sardine is: strictly speaking, a music live coding library ( eg. TidalCycles, FoxDot, Gibber) but more trivially, it is: a musical instrument that you gradually learn to master and to tune to your liking a control tool for external audio/video devices, instruments and softwares an environment for improvising algorithmic music live by coding with Python a blank canevas for exploring musical ideas (rhythms, textures and pitch) on-the-fly On the contrary, Sardine is not (or not really ): a Digital Audio Workstation : no timeline, no click and play process, no ready-to-use patterns or presets, no way to save and recall sessions with pre-configured parameters, no way to record, process and master songs, tracks or beats. Sardine is meant to be used in parallel with such tools :) a compositional environment to write scores or to deal programatically with traditional score notation ( \u00e0 la Finale , Sibelius , Lilypond , etc...). Sardine is not meant for writing , but for playing . This would be the same thing as to ask a piano to print a musical score while you play. This doesn't mean that you can't compose things with Sardine to play them later. It just means that it doesn't deal with the traditional scoring system. If your intent is to prepare for an art installation, a techno/house gig or an experimental music recital, you can do it just fine!","title":"What you can do"},{"location":"documentation/tutorial/#how-you-do-it","text":"Sardine is an instrument/tool that you control by programming live. Your keyboard will be your main musical interface, which is pretty unusual compared to other musical practices. Sardine is a tool made to explore various live coding techniques, and a tool made to integrate with other live coding softwares and environments. For people unfamiliar with it, live coding could be said to be three distinct things: a programming technique : the art of manipulating, redefining or altering software while it runs. A technique exploring processes of hot swapping , reloading or re-compiling parts of a software stack without interruption, as part of the way the software is meant to be used. an artistic practice : promoting artistic expression throughout the use of computer code. Turning programming into a gestural and expressive act, usually meant to be shared with an audience. a subculture : a niche in the larger world of computer and electronic music. Live coding has always been there. You can trace its origins way back to the 70s if you are really looking for it :) Nowadays, live coding is mostly promoted by algoravers or by the TOPLAP collective. Try to read about it. It's a fascinating world of people happily hacking and sharing software, usually free and open source. The goal is to find the right tool for the nail you want to hammer, and build from there, turning your computer into an environment for personal artistic expression. For our case, it means that Sardine is meant to be extended, modified, specialised for what you need to do :)","title":"How you do it"},{"location":"documentation/tutorial/#sardine-clock","text":"","title":"Sardine Clock"},{"location":"documentation/tutorial/#midi-clock","text":"The most crucial information to know about Sardine is that everything happens because of the clock . When Sardine is imported using the command from sardine import * , an instance of the Clock class will automatically start to run in the background and will be referenced by the variable c . Clock is the main MIDI Clock. By default, if you haven't touched to the configuration, the clock will be running in active mode: it will send a MIDI clock signal for every tick on the default MIDI port. The default MIDI port will either be a virtual port named Sardine if your OS supports virtual MIDI ports or the first available MIDI Port declared by your OS. It can also be passive and made to listen to the default MIDI port if you prefer. Never override the c variable. You won't have to worry a lot about the internals. Never override any variable that is one letter long! You will likely find the following commands interesting: c.bpm : current tempo in beats per minute. c.ppqn : current PPQN (Pulses per Quarter Note, used by MIDI gear). be careful. The tempo might fluctuate based on the PPQN you choose. Assume that 24 is a default sane PPQN for most synthesizers/drum machines. c.accel : an acceleration factor for the clock, from 0 to 100 (double tempo) %. c.nudge : nudge the clock forward in time by the given amount. Usually pinged randomly until you fall back on the external click track you wish to follow.","title":"MIDI Clock"},{"location":"documentation/tutorial/#ableton-link-clock","text":"The Link protocol is a novel open source protocol released by Ableton which allows users to synchronise their musical tempo seamlessly on a local network. While still pretty new, this method of synchronisation is now supported by a fair amount of by music software and apps, including other live coding libraries. Sardine can be made to start or follow an Ableton Link Clock that will be shared by all users on the local network. To do so, you will need to join/start a session using the c.link() method. Be mindful that the regular behavior of the clock will be altered and that you won't be able to change the tempo or alter time the way you want. Link is a collaborative clocking protocol, and there is no \"main\" tempo originating somewhere and followed by everyone, unlike MIDI. To resume the regular behavior of the clock, use the command c.unlink() . The c.link_log() function can be used to monitor the Ableton Link Clock state. Weirdness of Link Clock The Link Clock is a bit weird. It will disrupt the regular behavior of the Sardine Clock. It will stop emitting a MIDI clock signal because it cannot ensure that the clock signal will be steady. MIDI Clocks and Link Clock does not go hand in hand. It is preferable to kill every running pattern before attempting the switch from regular time to Link time.","title":"Ableton Link Clock"},{"location":"documentation/tutorial/#latency-and-sync","text":"There are many possible reasons that could explain why your computer is not perfectly in sync with another one. To tackle this issue, Sardine is proposing a set of variables you can play with to finetune the latency of various parts of the system. If you ever encounter a synchronisation issue, try to play an event on the first beat of the bar on each computer and to play around with the following values: c.midi_nudge : in miliseconds. Nudge value for the MIDI Sender (MIDI). c.superdirt_nudge : in milliseconds. Nudge value for the SuperDirt Sender (Sound). c.nudge : in milliseconds. General nudge for the Sardine clock. There is also an additional nudge value you can configure directly in your SuperDirt configuration. Finding the right configuration is usually just a matter of exploring and finding the right values for you and the other computer you are trying to synchronise with. Be careful not to override hard limits. Your computer needs some time to process information.","title":"Latency and sync"},{"location":"documentation/tutorial/#more-info-about-clocks","text":"Sardine will not behave nicely if no external clock is running while in passive mode. Time is simply frozen and events will not trigger, suspended somewhere in time. You can introspect the current state of the clock using clock attributes or using the very verbose debug mode. Be careful, your terminal will be flooded by messages. After running c.debug = True , you should see something that looks like: ... BPM : 130.0 , PHASE : 15 , DELTA : 0.001726 || TICK : 495 BAR : 2 3 / 4 BPM : 130.0 , PHASE : 16 , DELTA : 0.001729 || TICK : 496 BAR : 2 3 / 4 BPM : 130.0 , PHASE : 17 , DELTA : 0.001475 || TICK : 497 BAR : 2 3 / 4 BPM : 130.0 , PHASE : 18 , DELTA : 0.000634 || TICK : 498 BAR : 2 3 / 4 BPM : 130.0 , PHASE : 19 , DELTA : 0.000614 || TICK : 499 BAR : 2 3 / 4 BPM : 130.0 , PHASE : 20 , DELTA : 0.001333 || TICK : 500 BAR : 2 3 / 4 ... Some interesting clock attributes can be accessed: c.beat : current clock beat since start. c.tick : current clock tick since start. c.bar : current clock bar since start ( 4/4 bars by default). c.phase : current phase. These clock attributes are used everywhere in Sardine as they provide the most basic interface to the clock for every component in the system. You can use them if you wish to compose more complex pieces and sequences. They are still really useful tools to craft conditionals and random number generators even though there are better and more controlled ways to access them (for instance, via the patterning system ).","title":"More info about clocks"},{"location":"documentation/tutorial/#the-meaning-of-sleep","text":"If you are already familiar with Python , you might have heard about or used the sleep() function. This function will halt the execution of a program for a given amount of time and resume immediately after. Sardine does not rely on Python's sleep because it is unreliable for musical purposes! Your OS can decide to introduce micro-delays, to resume the execution too late or even not sleep for the precise duration you wanted. Sardine proposes an alternative to regular Python sleep , backed by the clock system previously described, crafted by @thegamecracks. The sleep() function has been overriden to allow you to have a safe and sane, similarly working alternative for musical contexts. You can use it to stop and resume a swimming function while keeping synchronization and timing accuracy. @swim def sleeping_demo ( d = 1 ): print ( \"Doing something...\" ) sleep ( 1 ) print ( \"Doing something else...\" ) sleep ( 1 ) again ( sleeping_demo , d = 2 ) @swim def limping ( d = 4 ): S ( 'hh' ) . out () sleep ( 3 ) S ( 'bd' ) . out () again ( limping , d = 4 ) The swimming function sleeping_demo() will recurse after a delay of 2 . Think of the time you have in-between a recursion as spare time you can use and consume using sleep() . You can use that time sending the instructions that compose your swimming function. You can also do nothing for most of your time just like in limping() . You can write code in an imperative fashion, something that you might have already encountered in live coding systems such as Sonic Pi or SuperCollider Tdefs . Oversleeping is a thing Be careful ! You can oversleep and trigger a recursion while your function is still running, effectively overlapping different versions of your swimming functions : @swim def oversleep ( d = 4 ): S ( 'hh' ) . out () sleep ( 3 ) S ( 'bd' ) . out () again ( oversleep , d = 0.5 ) # Changed the value to oversleep If you are not yet familiar with the concept of recursion, or with the meaning of some of the facts presented here, keep patience. The meaning of all this will become clear after a few sections and some tests on your side :)","title":"The meaning of sleep"},{"location":"documentation/tutorial/#swimming-functions","text":"To understand recursion, you must understand recursion says the old and not so funny joke... We have already used the term swimming function in the sections above without taking enough time to explain what it means precisely! In Sardine parlance, a swimming function is a function that is scheduled to be repeated by recursion. The function will call itself when it ends, and again and again. Usually, in computer science manuals, you learn that recursion always needs to end, that there must be a case where the function will exit. We have this in Sardine too but we usually want the function to continue indefinitely, as a way to generate rhythms and to build a musical groove. A swimming function will call itself, and again, and again... This is a way computer scientists and sardinists alike like to think about loops and structures like lists. To define a function as a swimming function , use the @swim decorator. The opposite of the @swim decorator is the @die decorator that will release a function from this dreadful recursive temporal loop. @swim # replace me by 'die' def bd ( d = 1 ): \"\"\"Loud bassdrum\"\"\" S ( 'bd' , amp = 2 ) . out () again ( bd , d = 1 ) # again == anew == cs If you don't manually add the recursion to the designated swimming function , the function will run once and stop. Recursion must be explicit and you should not forget about it! Forgetting the recursion loop call is another way to make a swimming function stop but not the recommended one! # Boring @swim def bd ( d = 1 ): S ( 'bd' , amp = 2 ) . out () The recursion can (and should) be used to update your arguments between each call of the swimming function . Here is an example of a very simple iterator: @swim # or die async def iter ( d = 1 , nb = 0 ): \"\"\"A simple recursive iterator\"\"\" print ( f \" { nb } \" ) again ( iter , d = 1 , nb = nb + 1 ) # 0 # 1 # 2 # 3 # 4 This is an incredibly useful feature to keep track of state between each call of your function. Swimming functions and its handling of arguments are the most basic thing you have to learn in order to use Sardine proficiently. This is the base to improvise music with variation, nuance and finesse. Temporal recursion makes it very easy to manually code LFOs, musical sequences, randomisation, etc... It will gradually become like a second nature for you to write them. Swimming functions are great but they have one BIG difference compared to a classic recursion: they are temporal recursive. They must be given a delay argument. The delay argument is actually d (shorter is better). If you don't provide it, Sardine will assume that your function uses d=1 . If you forget it on one side while using it on the other side, Sardine will jump up to your neck and try to kill you. If you ever try to give a delay of 0 , your function will immediately stop and an error message will be printed in your terminal. Not waiting is simply not an option, otherwise we would equally be able to travel back in time :)","title":"Swimming functions"},{"location":"documentation/tutorial/#making-sound-sending-information","text":"","title":"Making sound / sending information"},{"location":"documentation/tutorial/#sender-objects","text":"Sender objects are the most frequent objects you will be interacting with while playing with Sardine . Senders are objects that compose a single message that can be sent out using the .out(iter=0) method. They are your main interface to the outside world ( SuperCollider / SuperDirt , MIDI or OSC ). These objects can receive various and/or arbitrary parameters depending on their purpose and specialty. These arguments can be integers ( 1 , 2 ), floats ( 1.23 , 0.123123 ) or strings ( \"baba\" , \"dada/43/baba/\" ): int / float : parameters are sent as is, they are numbers! string : interpreted by Sardine and transformed into a pattern of values. When you import Sardine , MIDISender , SuperDirtSender and OSCSender will already be available under the name M() (for MIDI ), S() (for sound or SuperDirt ) and O() (for OSC ). These objects are preconfigured objects that must be prefered to custom senders you can declare yourself (more on this later). M , O and S are three ways of interacting with the synthesis engine, your synths or other equipment/softwares.","title":"Sender objects"},{"location":"documentation/tutorial/#superdirt-output","text":"The easiest way to trigger a sound with Sardine is to send an OSC message to SuperDirt . SuperDirt is designed as a tool that will convert control messages into the an appropriate action without having to deal with SuperCollider itself. Most people will use the SuperDirt output instead of plugging multiple synthesizers along with Sardine , or craft musical patches listening to OSC messages. The interface to SuperDirt is crude but fully functional. People already familiar with TidalCycles will feel at home using the S() (for SuperDirt ) object. The syntax is extremely similar for the purpose is similar, and names often match between the two systems: # A bassdrum (sample 0 from folder 'bd') S ( 'bd' ) . out () # Fourth sample, way louder! S ( 'bd' , n = 3 , amp = 2 ) . out () # Patterning a parameter (read the appropriate section) S ( 'bd' , n = 3 , amp = 1 , speed = '1,0.5' ) . out ( i ) # Introducing some Python in our parameters from random import random , randint S ( 'bd' if random () > 0.5 else 'hh' , speed = randint ( 1 , 5 ))","title":"SuperDirt output"},{"location":"documentation/tutorial/#delayed-messages","text":"You can pre-declare a sound before sending it out. This allows you to build your messages incrementely before sending them out using the .out() method. @swim def delayed ( d = 0.5 ): sound = S ( 'bd' ) if sometimes (): sound . shape ( 0.5 ) else : sound . speed ( 4 ) sound . out () again ( delayed ) Do not use the assign operator ( = ). Call the attribute directly (eg: amp() ). Any attribute can be set but they are not checked for validity. This is an useful feature if you prefer to write your code in an imperative fashion. There are other things to know about delayed composition: attributes can be chained: S('cp').speed('1 2').room(0.5).out() attributes will be parsed. You can write patterns just like you do when you send the objet out directly. Attributes are not checked for validity. You can really write anything so be careful: spell out the SuperDirt attribute names correctly. This technique is also really interesting if you like to pre-compose things before playing them. You can write some additional code to store libraries of prepared audio samples matching with some custom parameters.","title":"Delayed messages"},{"location":"documentation/tutorial/#orbits","text":"You will soon find out that you can assign effects to audio samples played using S() such as a reverb, a low-pass filter or a bitcrusher. Some of these effects are local . They only affect the sound you are currently playing. Some other effects are global . They will affect all the sounds running through the same audio bus. This is an important distinction to keep in mind! To specify which bus you would like to use for a given sound, use the orbit argument. orbit is a very important argument. Actually, it is the only argument that is specified by default. You can run a sound through a very heavy and long-tailed reverb while having, concurrently, another dry sound by switching orbits: S ( 'clap' , room = 0.9 , dry = 0.1 , size = 0.9 , orbit = 0 ) . out () S ( 'bd' , orbit = 3 ) . out () The number of orbits at your disposition is declared on the SuperDirt side in your configuration file. More on this later on! In the meantime, check out the SuperDirt GitHub repository if you would like to learn more about it.","title":"Orbits"},{"location":"documentation/tutorial/#midi-output","text":"The MIDISender object is structurally similar to the SuperDirtSender object. It is specialized in writing/sending MIDI notes and MIDI notes only. Other MIDI events are handled differently by specific methods such as cc() (for control changes) or pgch() (for program changes). MIDI Notes messages need a duration, a velocity, a note number and a channel: duration ( seconds ): time between a note-on and note-off event (pressing a key on an imaginary keyboard). velocity ( 0-127 ): think of it as the volume amplitude of a note. channel ( 0-16 ): the MIDI channel to send that note to on your default MIDI port. note ( 0-127 ): note from the lowest possible octave on a keyboard to the highest. M ( delay = 0.2 , note = 60 , velocity = 120 , channel = 0 ) The .out() method is still used to carry a note out and to inform the sender of the value you would like to select in a pattern (see patterning). All of these values have a given default. If you don't specify anything ( M() ), you will hear a very loud middle-C on channel 0. See the MIDI section to learn more about sending out other message types such as control changes or program changes .","title":"MIDI Output"},{"location":"documentation/tutorial/#osc-output","text":"The OSCSender is the weirdest of all the senders. It behaves and works just like the other ones but will require more work from your part. By default, the object cannot assume what OSC connexion you would like to use. For that reason, you will need to feed him one with an aditional parameter. Likewise, the sender cannot assume what address you would like to carry your message to. You will need to feed the object an address everytime you wish to send a message out. There is no default OSC connexion (except for the one used by SuperDirt and Sardine internally). To use the OSCSender object, you will have to open manually an OSC connexion before feeding it into the object: my_osc = OSC ( ip = \"127.0.0.1\" , port = 12000 , name = \"super_connexion\" , ahead_amount = 0.25 ) O ( my_osc , 'loulou' , value = '1,2,3,4' ) . out () Argument names do not matter when composing OSC messages. You can name arguments, but this will only make it easier for you to name and find values in your code. The message being caried out will not feature the name of the argument you specified. I'm still pondering if that is a nice thing or if I should find another system. If you have an opinion about it, please voice it!","title":"OSC output"},{"location":"documentation/tutorial/#composing-patterns","text":"Sardine features an embedded programming language dedicated to the generation of musical patterns. Python code and pattern code go hand in hand to compose a successful and musical swimming function . This is, by far, the most intriguing aspect of Sardine . These patterns can be used to generate rhythms, streams of notes, OSC addresses, numbers, random values, etc... They can be used just anywhere a regular Python value would be expected. They replace fixed values with dynamic values, regular variables by mutating variables, etc... Think of this pattern-oriented programming language as a glorified time-dependant calculator that can also do some arithmetics on lists, with new operators such as _ , ! or : . The pattern syntax can be used for things like summoning musical scales, musical chords and applying some funny musical transformations (such as .disco or .explosion ). All of this is ma\u00efeutic , aka meant to fuel your imagination and let you explore a world of dynamic algorithmic musical patterns. Important To be precise, the pattern syntax is a fully-fleged programming language. It is distinct from Python. This programming language is embedded within Sardine . It has its own rules, its own operations, its own syntax. However, you will soon see that the syntax is much simpler than the one used by Python. There is a certain amount of communication and inter-operability between the pattern syntax and the Python code. Some variables and some iterators are shared. Information about the clock can also be accessed both in Python code and in pattern code. You will soon learn that playing around with semi-random values can generate very fruitful musical results.","title":"Composing patterns"},{"location":"documentation/tutorial/#composing-a-pattern","text":"Patterns as written as strings of values separated by commas: 1,2,3,4 , dada, baba, lala , synth/freq, synth/mod , [1:2,0.2], 5*4, s(2) , etc... It is recommended to use double quotes for your patterns, because the single quotation mark is an operator used by the pattern syntax.","title":"Composing a pattern"},{"location":"documentation/tutorial/#patterns-are-lists","text":"Fundamentally, a pattern will always yield a list as a result. The most complicated pattern generation expression you can imagine will always result in a goold old Python list that you need to iterate through using an index. Senders can always receive an index, directly as the first argument of their .out() method: S('hh:[1:10], legato='r', pan='r, 1', speed='s($)*4').out(i) . To pattern, you always need an iterator and a pattern. There are multiple ways to generate iterators, whether you want to use shorthand iterators ( i.i ) or more complex iterators generated by recursion: def iter ( d = 0.5 , i = 0 ): S ( 'bd' ) . out ( i ) a ( iter , d = 0.5 , i = i + 1 ) You will see people leaning more towards a technique or another. It is of paramount importance to master the usage of iterators. You can for instance limit the range of an iterator by using a modulo operation to only iterate over a few chosen values in your pattern: def iter ( d = 0.5 , i = 0 ): S ( 'bd' , speed = [ 1 : 100 ]) . out ( i % 8 ) a ( iter , d = 0.5 , i = i + 1 ) You can also suddenly decide to iterate by decrementing and not by incrementing to reverse your pattern: i . i = [ 0 , - 1 ] def iter ( d = 0.5 ): S ( 'bd' , speed = [ 1 : 100 ]) . out ( i . i % 8 ) a ( iter , d = 0.5 ) You can be really creative with how you handle your iterators, giving you another way to create more complex patterns.","title":"Patterns are lists"},{"location":"documentation/tutorial/#the-pattern-object","text":"There is a method called P() , that can be used to write a pattern outside of a sender. This method will need two arguments: the pattern itself followed by the iterator. You can use it to introduce Sardine patterns in regular Python code. It can be particularly useful to pattern the recursion delay of your swimming functions : def iter ( d = 0.5 ): S ( 'bd' , speed = [ 1 : 100 ]) . out ( i . i % 8 ) a ( iter , d = P ( '0.5!8, 0.25!4' , i . p )) There is nothing more to know about it really. It can be particularly convenient to explore patterns by combining it with a print() statement.","title":"The Pattern Object"},{"location":"documentation/tutorial/#value-types","text":"The first important thing to learn is what the atomic values are. Atomic values are the absolute basics. They denote something that can be transformed or something upon which you can build a calculation. There are three fundamental basic types of values that can be used to compose a Sardine pattern: notes : musical notes. Symbolic names referring to a particular pitch. names : names denoting an OSC address or an audio sample file name. numbers : floating-point numbers or integers. numbers can also be information coming from the clock, shared iterators and shared variables ( eg. see the next section). All these values, even if not of the same type, can interact with one another, which means that you can write a scale and transpose it by a given factor just by doing math on it: C->penta + 2 . The main design principle Sardine is trying to follow is not to impose any limits to what you can do with values you interact with. Giving the possibility to assign things to other things freely is one way not to hinder the user and to encourage creativity.","title":"Value types"},{"location":"documentation/tutorial/#variable-values","text":"There are some values you can summon, which cannot yield a deterministic result. If you wish to add 2 to the current number of beats elapsed in the bar, the result will likely differ depending on the beat number during which the calculation takes place. Likely, you can ask Sardine what is the current value of a variable, or what the current year number is. These values are based on Sardine clock time. Depending on the moment where your recursion takes place, you might see some values recurring because you are not polling continuously but polling just a predictible moment in time. $ : tick , the tick number since the clock started. r : random , between 0 and 1. p : phase , a number between 0 and your c.ppqn. m : measure, the measure since the clock started. There are other temporal values to be accessed, but these will not be referring to Sardine time. They are just extrapolated from the current absolute time on your OS: $.Y : year, the current year. $.M : month, the current month. $.D : day, the current day. $.H : hour, the current hour. $.m : minute, the current minute. $.S : second, the current second. $.\u00b5 : microsecond, the current microsecond. Some other values are variables that can be freely altered both from the Python side and from the pattern side. They can be two things: iterators : i.a ... i.z and i.A ... i.Z , one for each letter of the latin alphabet both lowercase and uppercase. variables : v.a ... v.z and v.A ... v.Z , one for each letter of the latin alphabet both lowercase and uppercase. Iterators will yield a different result each time you call them. That is because they are counters . They increment or decrement each time they are activated by a given step. To change the current step of an iterator , you must provide them a new base value and step value as a list : i.a = [0, 5] . This example will make the iterator start from 0 and increment by 5 everytime. Iterators can also be resetted globally or invidually. The method to do so is specific to which side you are currently manipulating them (pattern or Python): Python : i.reset(\"a\") Pattern : i.a.reset You can also set your iterator to a given value: Python : i.a = 5 Pattern : i.a = 5 Variables are based on the same principle. The main difference is that they don't increment everytime you call them. They are just good old values you can use and manipulate both on the Python and pattern side. The syntax for their usage is strictly similar to the one used by iterators .","title":"Variable values"},{"location":"documentation/tutorial/#musical-notes","text":"You can write notes in patterns. Notes will be converted to some MIDI value used by SuperDirt . It means that notes are numbers too and that you can do math on them if you wish to. The syntax to write notes is the following. The steps 2 and 3 can be omitted: 1) capital letter indicating the note name: C , D , E , F , G , A , B 2) flat or sharp: # , b 3) octave number: 0 .. 9","title":"Musical notes"},{"location":"documentation/tutorial/#regular-names","text":"Names are just... good old names. There are some rules to know but it is really easy to remember: a single letter is not a name. a name cannot start with a number. Here is a list of some valid names you could use: dada , kqsdlkj321 or hellyearhsardineiscool2 . Most of the time, these names will correspond to a given sample name in your library. Be sure to name your sample folders accordingly to respect these rules.","title":"Regular names"},{"location":"documentation/tutorial/#osc-addresses","text":"Addresses and names are really similar, but they can also be composite names, aka. two or more names separated by a right-angled slash / . They are used to write OSC addresses, which usually adhere to this principle. Some valid addresses would look like: synth/freq/mod or robot/arm/pinky .","title":"OSC Addresses"},{"location":"documentation/tutorial/#math-but-funnier","text":"The pattern syntax started out by being a very simple calculator on integers. It then spreaded out to be able to pattern a lot of things. The pattern syntax is still pretty new and I don't expect it to be final before at least a year or even more. You can safely expect that some things will change in the following days or months. In the meantime, it works and you can do really interesting things with it. It is already pretty capable of being helpful to generate the objects you expect to find in an electronic instrument: LFOs, ramps, melodic generators, etc..","title":"Math but funnier"},{"location":"documentation/tutorial/#basic-arithmetics","text":"The pattern syntax includes some basic arithmetic operations that you expect to find such as + , - , * , / , // (floor division) , % (modulo). They work on almost any type of values. Of course, names and addresses do not support arithmetics very well, so don't even try to do it, it will likely crash. However, you can do arithmetics on just the numeric part of a name: dada:(2+2) . The result of this operation will be dada:4 . While being really useful for a lot of things, arithmetics become particularly fun when you start patterning random or moving values such as the tick number: $/20 .","title":"Basic Arithmetics"},{"location":"documentation/tutorial/#basic-functions","text":"The typical functions you can access on a scientific calculator are present in Sardine : sin and cos : sinus and cosinus functions used to compute periodc phenomenons (how convenient, just like sound). tan : tangent function. They are extremely useful for generating signal-like patterns, even though the resolution is not the greatest due to how Sardine operates.","title":"Basic functions"},{"location":"documentation/tutorial/#number-ranges","text":"As a shorthand, you can use the 1:10 syntax to generate a number between 1 and 10 . This is also working for floating point numbers!","title":"Number ranges"},{"location":"documentation/tutorial/#number-ramps","text":"You can generate ramps by surrounding two numbers with curly braces: [1:10] . This syntax will yield the following result: [1, 2, 3, 4, 5, ..., 10] . You can generate lists ramping up and down. You can also generate a ramp with a floating point range by specifying it as the third argument: [1:10,0.1] . This is really useful if you are looking to generate linear LFOs.","title":"Number ramps"},{"location":"documentation/tutorial/#repeat-operator","text":"The ! operator inspired by TidalCycles is used to denote the repetition of a value. You can also sometimes use the !! operator from the same family. This operator is a bit special and will be detailed later.","title":"Repeat operator"},{"location":"documentation/tutorial/#overflow-protection","text":"Some values such as notes need to be confined in the usual range of MIDI notes, defined on 8 bytes, from 0 to 127 . Math operations on notes that should result in overflowing that limit will be wrapped around. 128 will be changed into 0, etc... Most arithmetic operations are wrapped around. If you think that it makes no sense, I feel the same too but I am waiting to find a better solution to this problem. I could probably just lock the value to its bounds. More on this in later versions.","title":"Overflow protection"},{"location":"documentation/tutorial/#dealing-with-notes","text":"The support for traditional notes is still very basic. You can write very basic melodies with Sardine , but there is no good syntax for algorithmic composition like the one you could find in a tool such as SuperCollider . This is likely to change in the future, but dealing with musical objects is always extra difficult just like in any other computer music software. There are many ways to approach this, and it can be hard to decide which one is the right one or even to impose a vision about the way to deal with traditional musical objects such as chords and notes.","title":"Dealing with notes"},{"location":"documentation/tutorial/#notes-are-integers","text":"Notes in Sardine are values just any other. It means that the whole range of arithmetic operations is available to you. Internally, a note becomes a number as soon as it is parsed by the system (based on a MIDI Note to integer conversion).","title":"Notes are integers"},{"location":"documentation/tutorial/#note-qualifiers","text":"A Sardine note can receive a specific quality. Having a quality means being chosen as the base note for building a collection (chord, scale, structure). You can print the list of available qualifiers by using the print_scales() function. To qualify a note, the right arrow operator must be used: -> . The list of available qualities is subject to change and additions. I will not reproduce it here. Here are some examples of the qualification of a note: D3b->penta , E5#->fifths , G4->messiaen1 .","title":"Note qualifiers"},{"location":"documentation/tutorial/#midi","text":"Sardine supports all the basic messages one can send and receive through MIDI. It will likely support every possible MIDI message in the future. By default, Sardine is always associated to a default MIDI port. It can both send and receive information from that port. If the clock is active , you already learned that clock messages will be forwarded to the default port and thus to all your connected softwares/gear. You can also open arbitrary MIDI ports as long as you know their precise name on your system. There is no function to facilitate this for now. I will not enter into the topic of finding / creating / managing virtual MIDI ports. This subject is outside the scope of what Sardine offers and you are on your own to deal with this.","title":"MIDI"},{"location":"documentation/tutorial/#midi-out","text":"Here is an example of a swimming function sending a constant MIDI Note: @swim def hop ( d = 0.5 , i = 0 ): M ( dur = 0.3 , note = 60 , velocity = 127 , channel = 0 ) . out () a ( hop , d = 0.5 , i = i + 1 ) The default MIDI output is accessible through the M() syntax (contrary to S , it is not an object!). MIDI still need some work to support all messages coming out from the use of the same object. Note that the channel count starts at 0 , covering a range from 0 to 15 . This is unfortunate but that it how MIDI interfaces are built. The duration for each and every note should be written in milliseconds ( ms ) because MIDI is handling MIDI Notes as two separate messages (one for the note_on and one for the note_off ). Following the MIDI standard, note and velocity values are expressed in the range from 0 to 127 . Let's go further and make an arpeggio using the pattern system: @swim def hop ( d = 0.5 , i = 0 ): M ( dur = 0.3 , note = 'C,E,G,B' , velocity = 127 , channel = 0 ) . out ( i ) anew ( hop , d = 0.5 , i = i + 1 ) A similar function exists for sending MIDI CC messages. Let's combine it with our arpeggio: @swim def hop ( d = 0.5 , i = 0 ): M ( dur = 0.3 , note = '60 46 50 67' , velocity = 127 , channel = 0 ) . out ( i ) cc ( channel = 0 , control = 20 , value = P ( 'r*127' , i . v )) a ( hop , d = 0.5 , i = i + 1 )","title":"MIDI Out"},{"location":"documentation/tutorial/#midi-in","text":"MIDI Input is supported through the use of a special object, the MidiListener object. This object will open a connexion listening to incoming MIDI messages. There are only a few types of messages you should be able to listen to: MIDI Notes through the NoteTarget object MIDI CC through the ControlTarget object Additionally, you can listen to incoming Clock messages ( ClockListener ) but you must generally let Sardine handle this alone. There are currently no good or valid reasons to do this! Every MidiListener is expecting a target. You must declare one and await on it using the following syntax: a = MidiListener ( target = ControlTarget ( 20 , 0 )) @swim def pluck ( d = 0.25 ): S ( 'pluck' , midinote = a . get ()) . out () a ( pluck , d = 0.25 ) In this example, we are listening on CC n\u00b0 20 on the first midi channel ( 0 ), on the default MIDI port. Sardine cannot assert the value of a given MIDI Control before it receives a first message therefore the initial value will be assumed to be 0 . You can fine tune your listening object by tweaking the parameters: # picking a different MIDI Port a = MidiListener ( 'other_midi_port' , target = ControlTarget ( 40 , 4 ))","title":"MIDI In"},{"location":"documentation/tutorial/#osc","text":"You can send OSC ( Open Sound Control ) messages by declaring your own OSC connexion and sending custom messages. It is rather easy to do and should work without causing you any trouble.","title":"OSC"},{"location":"documentation/tutorial/#manual-method","text":"The following example details the simplest way to send an OSC message using Sardine. It is very crude and really not recommended at all to follow this route for there is a better one: # Open a new OSC connexion my_osc = OSC ( ip = \"127.0.0.1\" , port = 23000 , name = \"Bibu\" , ahead_amount = 0.25 ) # Recursive function sending OSC @swim def custom_osc ( d = 1 ): my_osc . send ( c , '/coucou' , [ randint ( 1 , 10 ), randint ( 1 , 100 )]) anew ( custom_osc , d = 1 ) # Closing and getting rid of the connexion cr ( custom_osc ) del my_osc Note that you always need to provide the clock as the first argument of the send() method. It is probably better to write a dedicated function to avoid having to specify the address everytime you want to send something at a specific address: def coucou ( * args ): my_osc . send ( c , '/coucou' , list ( args ))","title":"Manual method"},{"location":"documentation/tutorial/#using-the-oscsender-object","text":"Prefer the OscSender object, aliased to O() . The syntax is similar but you gain the ability to name your OSC parameters and you can use patterns to play around with them. Compared to S() and M() , O() requires one additional parameter: the OSC connexion previously defined. # Open a new OSC connexion my_osc = OSC ( ip = \"127.0.0.1\" , port = 23000 , name = \"Bibu\" , ahead_amount = 0.25 ) # Simple address O ( my_osc , 'loulou' , value = '1, 2, 3, 4' ) . out () O ( my_osc , 'loulou/yves' , value = '1, 2, 3, 4' ) . out () @swim def lezgo ( d = 1 , i = 0 ): O ( my_osc , 'loulou/blabla' , value = '1, 2, 3, 4' , otherv = '1, 2|4, r*2' ) . out ( i ) anew ( lezgo , i = i + 1 )","title":"Using the OSCSender object"},{"location":"documentation/tutorial/#what-about-crashes","text":"If you already know how to program, you know that 90% of your time is usually spent debugging code that doesn't run. You will not be a better programmer when using Sardine . Crashes will happen too, but they are handled and taken care of so that the musical flow is never truly interrupted. If you write something wrong inside a swimming function , the following will happen: if the function crashes and has never looped, it will not be recovered. if the function is already running and has already looped, the last valid function will be rescheduled and the current error message will be printed so that you can debug. It means that once you start playing something, it will never stop until you want it to. You can make music without fearing interruption because of a crash. Some mistakes might be harder than other to recover from but most of the time, you shouldn't really hear or feel any interruption in the musical flow. If that is the case, please report the bug along with a way to reproduce it easily.","title":"What about crashes?"},{"location":"documentation/demos/PMA5/","text":"Tribute to Jules Cipher Description Two songs composed by combining Sardine with the Roland PMA-5. Everything was recorded with two awful mono jack cables connected to a USB audio soundcard linked through Carla (very high signal-to-noise ratio). Performance Source code c . bpm = 125 #LEAD #marimba pgch ( program = 12 , channel = 0 ) #vibraphone pgch ( program = 11 , channel = 0 ) @swim def liquide ( d = 0.5 , i = 0 ): #minTheme #disco() #div=1 #M(note = \"C@maj\", channel = 0).out(i, div = 2) #M(note=\".!7,<C@min7>,.!7,<C@min7>,.!7,<C@maj7>\", # channel = 0).out(i, div=4) #LeadTHEME #apal #^[2~6] #M(note=\"pal(<C@maj, C@min7>,68,65,.,67,.)\" , # velocity = P(\"70~90\",i), # channel = 0, dur=5000).out(i) #Bass lente #M(note=\"disco(<C@maj, C@min7>,68,65,.,67,.)\" , # velocity = P(\"80~95\",i), # channel = 0, dur=50).out(i, div = 2) again ( liquide , d = P ( \"0.25, 0.5\" , i ), i = i + 1 ) #BAss TB303 pgch ( program = 38 , channel = 1 ) cc ( control = 0 , value = 66 , channel = 1 ) Pt >> play_midi ( note = 'C2@min | ., C2@min7' , channel = 1 ) cc ( control = 1 , value = 0 , channel = 1 ) Pt >> None #DRUMSET #TR808 pgch ( program = 25 , channel = 9 ) #ROOM2 pgch ( program = 72 , channel = 9 ) #TR909 pgch ( program = 88 , channel = 9 ) PO >> play_midi ( note = \"36,.,36,.\" , velocity = 127 , channel = 9 ) PO >> None Ps >> play_midi ( note = \".,.,38,.\" , velocity = 100 , channel = 9 ) Ps >> None Ph >> play_midi ( note = \"44!7,46\" , channel = 9 ) Ph >> None #CHANSON NUMERO 2, dowaping in the DOO-wap (nourriture) c . bpm = 152 #ROOM2 pgch ( program = 72 , channel = 9 ) PO >> play_midi ( note = \"36,.,..,.,.,.,36,36\" , velocity = 130 , channel = 9 ) PO >> None Ps >> play_midi ( note = \".,.,.,38\" , velocity = 85 , channel = 9 ) Ps >> None Ph >> play_midi ( note = \"44!7,46\" , channel = 9 ) hush () pgch ( program = 33 , channel = 1 ) cc ( control = 0 , value = 66 , channel = 1 ) @swim def dubibass ( d = 0.5 , i = 0 ): M ( note = \".,D3\" , channel = 1 ) . out ( i , div = 2 , rate = 1 ) M ( note = 'D2,.,D2' , channel = 1 ) . out ( i , div = 1 , rate = 1 ) again ( dubibass , d = 1 , i = i + 1 ) pgch ( program = 63 , channel = 3 ) cc ( control = 0 , value = 64 , channel = 3 ) @swim def orgie ( d = 0.5 , i = 0 ): M ( note = \"<D4@maj7>\" , channel = 3 , velocity = P ( \"[45:65]\" , i ), dur = 30 ) . out ( i , div = 4 , rate = 1 ) #M(note=\".!8,adisco(F4@maj7)\", # channel = 3, # velocity = P(\"[75:45]\",i), # dur = 65).out(i,div=4, rate=1) again ( orgie , d = 0.125 , i = i + 1 ) @swim def dowap ( d = 0.5 , i = 0 ): pgch ( program = 53 , channel = 4 ) if E ( 2 , 3 , i ): pgch ( program = 54 , channel = 4 ) M ( note = \"D5,.,disco(D4@maj7),.,F3@hirajoshi | .\" , channel = 4 ) . out ( i , div = 4 , rate = 1 ) #M(note=\"D6,.,disco(D5@maj7),.,disco(F4@maj7)\", channel=4).out(i, div=4, rate=P(\"1,2,3\",i)) again ( dowap , d = 0.125 , i = i + 1 ) #laisser que le hh @swim def tempomedler ( d = 0.5 , i = 0 ): if c . bpm < 80 : c . bpm = c . bpm * 1.02 else : c . bpm = 60 again ( tempomedler , d = 0.5 , i = i + 1 ) hush ()","title":"Tribute to Jules Cipher"},{"location":"documentation/demos/PMA5/#tribute-to-jules-cipher","text":"","title":"Tribute to Jules Cipher"},{"location":"documentation/demos/PMA5/#description","text":"Two songs composed by combining Sardine with the Roland PMA-5. Everything was recorded with two awful mono jack cables connected to a USB audio soundcard linked through Carla (very high signal-to-noise ratio).","title":"Description"},{"location":"documentation/demos/PMA5/#performance","text":"","title":"Performance"},{"location":"documentation/demos/PMA5/#source-code","text":"c . bpm = 125 #LEAD #marimba pgch ( program = 12 , channel = 0 ) #vibraphone pgch ( program = 11 , channel = 0 ) @swim def liquide ( d = 0.5 , i = 0 ): #minTheme #disco() #div=1 #M(note = \"C@maj\", channel = 0).out(i, div = 2) #M(note=\".!7,<C@min7>,.!7,<C@min7>,.!7,<C@maj7>\", # channel = 0).out(i, div=4) #LeadTHEME #apal #^[2~6] #M(note=\"pal(<C@maj, C@min7>,68,65,.,67,.)\" , # velocity = P(\"70~90\",i), # channel = 0, dur=5000).out(i) #Bass lente #M(note=\"disco(<C@maj, C@min7>,68,65,.,67,.)\" , # velocity = P(\"80~95\",i), # channel = 0, dur=50).out(i, div = 2) again ( liquide , d = P ( \"0.25, 0.5\" , i ), i = i + 1 ) #BAss TB303 pgch ( program = 38 , channel = 1 ) cc ( control = 0 , value = 66 , channel = 1 ) Pt >> play_midi ( note = 'C2@min | ., C2@min7' , channel = 1 ) cc ( control = 1 , value = 0 , channel = 1 ) Pt >> None #DRUMSET #TR808 pgch ( program = 25 , channel = 9 ) #ROOM2 pgch ( program = 72 , channel = 9 ) #TR909 pgch ( program = 88 , channel = 9 ) PO >> play_midi ( note = \"36,.,36,.\" , velocity = 127 , channel = 9 ) PO >> None Ps >> play_midi ( note = \".,.,38,.\" , velocity = 100 , channel = 9 ) Ps >> None Ph >> play_midi ( note = \"44!7,46\" , channel = 9 ) Ph >> None #CHANSON NUMERO 2, dowaping in the DOO-wap (nourriture) c . bpm = 152 #ROOM2 pgch ( program = 72 , channel = 9 ) PO >> play_midi ( note = \"36,.,..,.,.,.,36,36\" , velocity = 130 , channel = 9 ) PO >> None Ps >> play_midi ( note = \".,.,.,38\" , velocity = 85 , channel = 9 ) Ps >> None Ph >> play_midi ( note = \"44!7,46\" , channel = 9 ) hush () pgch ( program = 33 , channel = 1 ) cc ( control = 0 , value = 66 , channel = 1 ) @swim def dubibass ( d = 0.5 , i = 0 ): M ( note = \".,D3\" , channel = 1 ) . out ( i , div = 2 , rate = 1 ) M ( note = 'D2,.,D2' , channel = 1 ) . out ( i , div = 1 , rate = 1 ) again ( dubibass , d = 1 , i = i + 1 ) pgch ( program = 63 , channel = 3 ) cc ( control = 0 , value = 64 , channel = 3 ) @swim def orgie ( d = 0.5 , i = 0 ): M ( note = \"<D4@maj7>\" , channel = 3 , velocity = P ( \"[45:65]\" , i ), dur = 30 ) . out ( i , div = 4 , rate = 1 ) #M(note=\".!8,adisco(F4@maj7)\", # channel = 3, # velocity = P(\"[75:45]\",i), # dur = 65).out(i,div=4, rate=1) again ( orgie , d = 0.125 , i = i + 1 ) @swim def dowap ( d = 0.5 , i = 0 ): pgch ( program = 53 , channel = 4 ) if E ( 2 , 3 , i ): pgch ( program = 54 , channel = 4 ) M ( note = \"D5,.,disco(D4@maj7),.,F3@hirajoshi | .\" , channel = 4 ) . out ( i , div = 4 , rate = 1 ) #M(note=\"D6,.,disco(D5@maj7),.,disco(F4@maj7)\", channel=4).out(i, div=4, rate=P(\"1,2,3\",i)) again ( dowap , d = 0.125 , i = i + 1 ) #laisser que le hh @swim def tempomedler ( d = 0.5 , i = 0 ): if c . bpm < 80 : c . bpm = c . bpm * 1.02 else : c . bpm = 60 again ( tempomedler , d = 0.5 , i = i + 1 ) hush ()","title":"Source code"},{"location":"documentation/demos/artificial_life/","text":"Artificial Life Description Experimental use of the Taichi numerical simulation and graphics language for live visuals and artificial life simulation. For more info see: https://github.com/Intelligent-Instruments-Lab/iil-python-tools. Performance Source code https://github.com/Intelligent-Instruments-Lab/iil-python-tools/tree/master/examples/tulvera from sardine import * import taichi as ti import numpy as np import math import tulvera as tul ti . init ( arch = ti . vulkan ) c . bpm = 250 c . link () resx = 1920 resy = 1080 n = 8192 boids = tul . vera . Boids ( resx , resy , n ) window = ti . ui . Window ( \"Boids\" , ( resx , resy )) canvas = window . get_canvas () @swim def gui_loop ( d = 0.5 , i = 0 ): boids . update () canvas . set_image ( boids . world . to_numpy () . astype ( np . uint8 )) window . show () a ( gui_loop , d = 1 / 16 , i = i + 1 ) @swim def param_loop ( d = 16 , i = 0 ): # boids.vis_radius[None] = P('40.0,80.0,150.0',i) # boids.max_speed[None] = P('1.0,2.0,3.0',i) boids . max_speed [ None ] = P ( '2*sin($/2)' ) a ( param_loop , d = 8 , i = i + 1 ) hush ()","title":"Artificial Life"},{"location":"documentation/demos/artificial_life/#artificial-life","text":"","title":"Artificial Life"},{"location":"documentation/demos/artificial_life/#description","text":"Experimental use of the Taichi numerical simulation and graphics language for live visuals and artificial life simulation. For more info see: https://github.com/Intelligent-Instruments-Lab/iil-python-tools.","title":"Description"},{"location":"documentation/demos/artificial_life/#performance","text":"","title":"Performance"},{"location":"documentation/demos/artificial_life/#source-code","text":"https://github.com/Intelligent-Instruments-Lab/iil-python-tools/tree/master/examples/tulvera from sardine import * import taichi as ti import numpy as np import math import tulvera as tul ti . init ( arch = ti . vulkan ) c . bpm = 250 c . link () resx = 1920 resy = 1080 n = 8192 boids = tul . vera . Boids ( resx , resy , n ) window = ti . ui . Window ( \"Boids\" , ( resx , resy )) canvas = window . get_canvas () @swim def gui_loop ( d = 0.5 , i = 0 ): boids . update () canvas . set_image ( boids . world . to_numpy () . astype ( np . uint8 )) window . show () a ( gui_loop , d = 1 / 16 , i = i + 1 ) @swim def param_loop ( d = 16 , i = 0 ): # boids.vis_radius[None] = P('40.0,80.0,150.0',i) # boids.max_speed[None] = P('1.0,2.0,3.0',i) boids . max_speed [ None ] = P ( '2*sin($/2)' ) a ( param_loop , d = 8 , i = i + 1 ) hush ()","title":"Source code"},{"location":"documentation/demos/dumpster_dive/","text":"dumpsterDive (11/11/2022) Description dumpsterDive is a short piece that can be performed with quasi live-coding practices. It uses a set of percussive field recordings made with a hard marimba mallet on various parts of a public metal dumpster. One sound was made with a plastic scraper. They are particularly resonant sounds that work well together. The Sardine function uses the stacked samples model, where each sample line can be played alone or together with others. Audio equipment: Tascam DR-100 , Rode shotgun mic: NTG4 . Software: Sardine Dumpster samples are available via the sardine-sounds repository. Performance: composed quasi live-coding Source code # Load audio effect and preset dictionaries first. # Play one or both lines from each section (basic, reverse rhythms, melodic patterns, bass, scrape). Explore combinations. c . bpm = 60 @swim def dumpsterDive ( d = 1 , i = 0 ): ## basic samples - cycle thru the sounds used by all layers S ( 'dumpster:[0,1,4,2,5,3,.!2]' , speed = 1 , amp = .5 , ** rev1 , orbit = 0 ) . out ( i , div = 8 ) #S('dumpster:[2,0,1,4,3,5]', speed='2', pan=.7, amp=.5, **rev1, orbit=1).out(i, div=2) #**del1 ## reverse rhythms #S('dumpster:1', begin=.065, end=.4, speed='-1', pan='[.14:.84,0.1],[.83:.15,0.1]', amp=.8, **rev0, orbit=2).out(i, div4) #S('dumpster:0!2,.', begin=0, end=.85, speed='1,-1', pan='[.9:.1,0.2],[.1:.9,0.2]', amp=.6, **rev1, orbit=3).out(i, rate=1, div=2) #**del1, ## melodic patterns #S('dumpster:[1!2,4!2,5!2,4]', begin=.052, end=.088, freq='[414,240,620,.,500,380,820,750]', timescale=1.4, pan='[.1,.9]', amp=.95, **rev2, orbit=4).out(i, rate=1, div=1) #S('dumpster:[0,1,0,3,4,]', begin='0', end='.2',speed='1', amp=.6, pan=.3, **rev1, orbit=5).out(i, rate=1, div=2) #S('dumpster:[6!2,8!3,7!2]', octave='7', cut=1, pan=.3, amp=.9, **rev2, orbit=6).out(i, div=4) ## bass - choose one or the other #S('dumpster:[2,1,0,.,4,1]', octave=4, amp=.5, **rev1, orbit=7).out(i, rate=1, div=4) #S('dumpster:2', octave='[4.8:5.1,.04],[4.6:4.8,.04]', amp=.95, **rev1, orbit=8).out(i, div=4) ## scrape #S('dumpster:[5,.,5]', octave='6', cut=1, amp=1.2, **del1, **rev1, orbit=8).out(i, rate=.5, div=4) #S('dumpster:[5,.,5]', octave='[6!3,6.62,5.4]', cut=1, amp=.9, **rev2, orbit=9).out(i, rate=1, div=1) #**del2 ## presets #returnGroove['bass1'].out(i, rate=1, div=4) #returnGroove['melody2'].out(i, rate=1, div=2) #closing['basic2'].out(i, div=2) #closing['basic2a'].out(i, rate=2, div=2) ## div=1 #closing['scrape2'].out(i, rate=1, div=2) #c.bpm = P('[60:90,.03]', i) #accelerate tempo at the end a ( dumpsterDive , d = 1 / 8 , i = i + 1 ) ###################################################### #hush(dumpsterDive) ######################## LOAD THESE FIRST - python dictionarys referenced in dumpsterDive function ################# c . bpm = 60 ## audio effects rev0 = { 'room' : .8 , 'size' : 0.5 , 'dry' : 0.5 } rev1 = { 'room' : .9 , 'size' : 0.6 , 'dry' : 0.4 } rev2 = { 'room' : 1.5 , 'size' : 0.7 , 'dry' : 0.4 } rev3 = { 'room' : 2 , 'size' : 0.8 , 'dry' : 0.3 } del0 = { 'delay' : 0.5 , 'delaytime' : 0.3 , 'delayfeedback' : 0.5 , 'triode' : 0 } del1 = { 'delay' : 0.5 , 'delaytime' : 0.4 , 'delayfeedback' : 0.6 } del2 = { 'delay' : 0.5 , 'delaytime' : 0.25 , 'delayfeedback' : 0.8 } #Presets returnGroove = { 'bass1' : S ( 'dumpster:[2,1,0,.,4,1]' , octave = 4 , amp = .5 , ** rev1 , orbit = 7 ), 'melody2' : S ( 'dumpster:[0,1,0,3,4,]' , begin = '0' , end = '.2' , speed = '1' , amp = .4 , pan = .3 , ** rev1 , orbit = 5 ) } closing = { 'basic2' : S ( 'dumpster:[12,0,1,4,3,5]' , speed = '2' , pan = .7 , amp = .5 , ** del1 , ** rev1 , orbit = 1 ), 'basic2a' : S ( 'dumpster:[0,5,3,4,3,0]' , speed = '[2.01:1.96,.01],[1.96:2.01,.01]' , pan = '[.99:.01,0.3],[.01:.99,0.3]' , amp = .7 , ** rev1 , ** del2 , orbit = 1 ), 'scrape2' : S ( 'dumpster:[5,.,5]' , octave = '[6!3,6.62,5.4]' , cut = 1 , amp = .9 , ** del2 , ** rev2 , orbit = 9 ) } Thanks to @Bubobubobubobubo for assistance on Sardine usage.","title":"Dumpster Dive"},{"location":"documentation/demos/dumpster_dive/#dumpsterdive-11112022","text":"","title":"dumpsterDive (11/11/2022)"},{"location":"documentation/demos/dumpster_dive/#description","text":"dumpsterDive is a short piece that can be performed with quasi live-coding practices. It uses a set of percussive field recordings made with a hard marimba mallet on various parts of a public metal dumpster. One sound was made with a plastic scraper. They are particularly resonant sounds that work well together. The Sardine function uses the stacked samples model, where each sample line can be played alone or together with others. Audio equipment: Tascam DR-100 , Rode shotgun mic: NTG4 . Software: Sardine Dumpster samples are available via the sardine-sounds repository.","title":"Description"},{"location":"documentation/demos/dumpster_dive/#performance-composed-quasi-live-coding","text":"","title":"Performance: composed quasi live-coding"},{"location":"documentation/demos/dumpster_dive/#source-code","text":"# Load audio effect and preset dictionaries first. # Play one or both lines from each section (basic, reverse rhythms, melodic patterns, bass, scrape). Explore combinations. c . bpm = 60 @swim def dumpsterDive ( d = 1 , i = 0 ): ## basic samples - cycle thru the sounds used by all layers S ( 'dumpster:[0,1,4,2,5,3,.!2]' , speed = 1 , amp = .5 , ** rev1 , orbit = 0 ) . out ( i , div = 8 ) #S('dumpster:[2,0,1,4,3,5]', speed='2', pan=.7, amp=.5, **rev1, orbit=1).out(i, div=2) #**del1 ## reverse rhythms #S('dumpster:1', begin=.065, end=.4, speed='-1', pan='[.14:.84,0.1],[.83:.15,0.1]', amp=.8, **rev0, orbit=2).out(i, div4) #S('dumpster:0!2,.', begin=0, end=.85, speed='1,-1', pan='[.9:.1,0.2],[.1:.9,0.2]', amp=.6, **rev1, orbit=3).out(i, rate=1, div=2) #**del1, ## melodic patterns #S('dumpster:[1!2,4!2,5!2,4]', begin=.052, end=.088, freq='[414,240,620,.,500,380,820,750]', timescale=1.4, pan='[.1,.9]', amp=.95, **rev2, orbit=4).out(i, rate=1, div=1) #S('dumpster:[0,1,0,3,4,]', begin='0', end='.2',speed='1', amp=.6, pan=.3, **rev1, orbit=5).out(i, rate=1, div=2) #S('dumpster:[6!2,8!3,7!2]', octave='7', cut=1, pan=.3, amp=.9, **rev2, orbit=6).out(i, div=4) ## bass - choose one or the other #S('dumpster:[2,1,0,.,4,1]', octave=4, amp=.5, **rev1, orbit=7).out(i, rate=1, div=4) #S('dumpster:2', octave='[4.8:5.1,.04],[4.6:4.8,.04]', amp=.95, **rev1, orbit=8).out(i, div=4) ## scrape #S('dumpster:[5,.,5]', octave='6', cut=1, amp=1.2, **del1, **rev1, orbit=8).out(i, rate=.5, div=4) #S('dumpster:[5,.,5]', octave='[6!3,6.62,5.4]', cut=1, amp=.9, **rev2, orbit=9).out(i, rate=1, div=1) #**del2 ## presets #returnGroove['bass1'].out(i, rate=1, div=4) #returnGroove['melody2'].out(i, rate=1, div=2) #closing['basic2'].out(i, div=2) #closing['basic2a'].out(i, rate=2, div=2) ## div=1 #closing['scrape2'].out(i, rate=1, div=2) #c.bpm = P('[60:90,.03]', i) #accelerate tempo at the end a ( dumpsterDive , d = 1 / 8 , i = i + 1 ) ###################################################### #hush(dumpsterDive) ######################## LOAD THESE FIRST - python dictionarys referenced in dumpsterDive function ################# c . bpm = 60 ## audio effects rev0 = { 'room' : .8 , 'size' : 0.5 , 'dry' : 0.5 } rev1 = { 'room' : .9 , 'size' : 0.6 , 'dry' : 0.4 } rev2 = { 'room' : 1.5 , 'size' : 0.7 , 'dry' : 0.4 } rev3 = { 'room' : 2 , 'size' : 0.8 , 'dry' : 0.3 } del0 = { 'delay' : 0.5 , 'delaytime' : 0.3 , 'delayfeedback' : 0.5 , 'triode' : 0 } del1 = { 'delay' : 0.5 , 'delaytime' : 0.4 , 'delayfeedback' : 0.6 } del2 = { 'delay' : 0.5 , 'delaytime' : 0.25 , 'delayfeedback' : 0.8 } #Presets returnGroove = { 'bass1' : S ( 'dumpster:[2,1,0,.,4,1]' , octave = 4 , amp = .5 , ** rev1 , orbit = 7 ), 'melody2' : S ( 'dumpster:[0,1,0,3,4,]' , begin = '0' , end = '.2' , speed = '1' , amp = .4 , pan = .3 , ** rev1 , orbit = 5 ) } closing = { 'basic2' : S ( 'dumpster:[12,0,1,4,3,5]' , speed = '2' , pan = .7 , amp = .5 , ** del1 , ** rev1 , orbit = 1 ), 'basic2a' : S ( 'dumpster:[0,5,3,4,3,0]' , speed = '[2.01:1.96,.01],[1.96:2.01,.01]' , pan = '[.99:.01,0.3],[.01:.99,0.3]' , amp = .7 , ** rev1 , ** del2 , orbit = 1 ), 'scrape2' : S ( 'dumpster:[5,.,5]' , octave = '[6!3,6.62,5.4]' , cut = 1 , amp = .9 , ** del2 , ** rev2 , orbit = 9 ) } Thanks to @Bubobubobubobubo for assistance on Sardine usage.","title":"Source code"},{"location":"documentation/demos/zorba_in_belleville/","text":"Zorba in Belleville (11/11/2022) Description This code is taken from an algorave that took place at the Zorba ( Belleville , Paris) in early november (2022). It is a very straightforward dance oriented performance that plays a lot with simple audio sample manipulations. As stated in the opening banner, this performance was meant to test the stability of Sardine after introducing new features and control mechanisms. Everything lives in the baba function, meaning that you only need to keep track one function during the whole performance. Sounds are extracted from a very heavy sound library, lazy-loaded when needed. This is how I like to make music, extracting a lof of raw audio files from my hard disk :) Performance Source code # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588 # \u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588 # \u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588 # \u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588 # \u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588 # \u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588 # \u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588 # \u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2580\u2003\u2588\u2591\u2588\u2003 \u2003\u2580\u2588\u2580\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2003\u2580\u2588\u2580\u2003 \u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2003\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003 \u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2588\u2003\u2584\u2580\u2588\u2003 \u2003\u2588\u2580\u2588\u2003\u2591\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2584\u2588 # \u2588\u2584\u2584\u2003\u2588\u2580\u2584\u2003\u2588\u2580\u2588\u2003\u2584\u2588\u2003\u2588\u2580\u2588\u2003 \u2003\u2591\u2588\u2591\u2003\u2588\u2588\u2584\u2003\u2584\u2588\u2003\u2591\u2588\u2591\u2003 \u2003\u2580\u2584\u2580\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2584\u2003\u2584\u2588\u2003\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2591\u2580\u2588\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003 \u2003\u2588\u2584\u2588\u2003\u2584\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2588\u2003\u2591\u2588 # @@@@@@@@@@@@@@@@@@@@@@@@@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ # @@@@@@@@@@@@@@@@@....,.....,..,,,,,,,,,,,,,*(&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ # @@@@@@@@@@@@&.,,,,/*//////////**,*.*,*..,***,,,,**********/(%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ # @@@@@@@@@@(..,*//**/***,,,,,(%((%%,/,%%%%(****,,.,,********,,,*/*/*****///(%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ # @@@@@@@@@ .,(/////*,,,,,,,/%%%(*.((,/%%(/.((/%/%//,//,/#%(*****************,,*****///////(&@@@@@@@@@@@@@@@@@@@@@@@@ # @@@@@@@@ ./(//*,*,,**,,,,,,,,,,*,*,,**,*/#%%%%%,*#(*(,,(*%(,(*,/*(%(#,/%%/****************,*//*//****/&@@@@@@@@@@@@ # @@@@@@@ .(##***,*,,,,,,,,,,,,,,,,,,,,,*,*,,****,*,****,*(%%%/##/(%,./*//(%(,(%(./((/,*%**************.,****%@@@@@@@ # @@@@@@.*///*********,*,**,,*,,,,,,,%%%%%((#%%%%%,,(%%%%%%%%%%%##%%#,,**/%&%%(/,&(,((/#%%%*,,,,,,,,,,,,,,,..***(@@@@ # @@@@@%/**/*****,,***,,,,,,,,,,,%%%%##/##%%%%%%%%%%%#((**###%%%%####%#####%#(,,********/#%***,,,,,,,,,,,,,,,,.,**/@@ # @@@@@,/**,**************,,,,,*%%%/.((*%*/,/((*#./*. .. ..*,/(##/*,,###*/#/(#%%%#(#,*,#%%%%%%%%%/,,*,,,,,,,,,,..***@ # @@@@ ,/**********,*******,,,,*,% #*,,//#%(.#*,,**#,(##(/**##%##%##/,/#%(//(//,.(#(#%#((,#%%##*##%%%,,,,,,,,,,,. *** # @@@ .,///*******,*,*,**,,**,,*,,*./ /((..((/(%,,/#(/(/*,*#,.*#/###%%##/**/(/(/.(//%%%%%/###%##,,,%%%***,,,,,,.. .** # @@@...////*************,***,,,/(((((*.(., #*( *(..#/(/*(///(##(#(####(/#(*##%(/((%%%%%%%/((#%%%%%%%#***,,,**, ,* # @@,..../(//********,,***,,,***(((((( ((*((,,##,,,/###(//*(##((((((#(, ,(%%#%%,.,(####%###,/%&******,*,*, .( # @@*/.,..*(*/***********,*,,*,,,,,**(.((.(((((((((**,(%%%%%%%%###########(*//(#((//*/. *,/(#%##,.,******,**,*,, ,% # @@,/*,*.,..(***************,,*,,,*,#*&(**(,* (( .(((((..((((/********,,*,****/((((((,***********************, *( # @/,*/**,,*,,...,*,,*,*,..,,*,,,,,,*,*,**,(#&(,*,/((./(( (( /(. ...(((*../( (#((((((((((********************** .*#, # @, *//********/.,,.........,,,,,,,,,,*,,..,,,**,,**##(%&#*****/((#(((((((((((/*,***************************,...**%# # @% ,*/******//////////**/****,.,,.........,,**/*,,,,,,,,,,,*,*******,************************************,.. **,#,@ # @@* .********/*///////////*/////////*********,,,,,,***//*//////***,*,,,,,,****************************,... ,***/#/@ # @@@#/..********///////////**/*,*,/#.//////////////**********,,.,,**********//*,,,,,,,.,***********,.....,*/*,*(#(&@ # @@@@@&(*,,******///////./,//**/.**//////,/***,/#,,//**,/.////////******/***,,..,,*,...,,**/*,,**,*//*/*****/((#%*@@ # @@@@@@@@%/(/,,,***///////*,,**/**////,**/*/,,**////**///***./*//.*/////////////*******/*,,******,,*//#/(//(((##*%@@ # @@@@@@@@@@@@@((/(((((/*,,,**//****///**,*//****///***.*//**////***////*(%%##%%/&&&///////////////(((((((((((###*@@@ # @@@@@@@@@@@@@@@@@@@@@@&#/(#####(((//*,,,,**/***//******,,***///**./*/**%%&&&###((&&%**//////////(((((((((((((/*@@@@ # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&#/(####((((/**,,,,**/////****////****/%###%/%&***////////(((((((((((((/,(@@@@@ # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&#/#####(((/(/*,,,,***///****///****/////////(((((((((/**(&@@@@@@ # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&(/#####(((((/*,,,******///////((((//**#(%@@@@@@@@@ # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&((#####((((#%&%%##%%#%@@@@@@@@@@@@@@ # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # # \u2588\u2580\u2584\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2003 \u2003\u2580\u2588\u2580\u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2588\u2003\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003 \u2003\u2588\u2591\u2588\u2591\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003\u2580\u2588\u2003 \u2003\u2588 \u2588 \u2588 # \u2588\u2591\u2580\u2591\u2588\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2584\u2003\u2588\u2584\u2584\u2003\u2588\u2003 \u2003\u2591\u2588\u2591\u2003\u2588\u2580\u2588\u2003\u2588\u2588\u2584\u2003\u2588\u2584\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2588\u2584\u2003 \u2003\u2580\u2584\u2580\u2584\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2584\u2584\u2003\u2588\u2588\u2584\u2003\u2588\u2584\u2003 \u2003\u2584 \u2584 \u2584 # # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588 \u2588 # \u2588 \u2588\u2003 \u2003\u2584\u2584\u2003 \u2003\u2588\u2580\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2580\u2584\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003 \u2003\u2588\u2580\u2003\u2584\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2588\u2580\u2003 \u2003\u2588\u2580\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2580\u2584\u2580\u2588\u2003\u2588\u2580\u2580 \u2588 # \u2588 \u2588\u2003 \u2003\u2591\u2591\u2003 \u2003\u2588\u2580\u2584\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2580\u2591\u2588\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2584\u2003 \u2003\u2584\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2584\u2588\u2003 \u2003\u2588\u2580\u2584\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2580\u2591\u2588\u2003\u2588\u2588\u2584 \u2588 # \u2588 \u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 @swim def baba ( d = 0.5 , i = 0 ): S ( 'juppad:3, juppad:4' , cutoff = 5000 , begin = 0.1 , orbit = 2 , cut = 0 , legato = 1.1 ) . out ( i , 8 , 0.25 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'juppad:3, juppad:4' , cutoff = 5000 , begin = 0.1 , orbit = 2 , cut = 0 , legato = 1.1 ) . out ( i , 8 , 0.25 ) # up # S('bip:r*20', shape=0.4, midinote='quant([0,3,10]+50, C@minor), quant([0,3,10]+50, F@minor)').out(i, 1, 0.25) S ( 'boop:r*40' ) . out () a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): # S('f', shape=0.7).out(i, 4) # -> monter shape pour les harmoniques # S('hhh:3', amp='[0:0.4,0.05]', legato='0.1~0.5').out(i) # -> hhh ramp S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) # S('.., p:6, ., .., p:3, ..', legato=0.5, shape=0.7).out(i, 1) S ( 'juppad:3, juppad:4' , begin = 0.1 , orbit = 2 , cut = 0 , legato = 1.1 ) . out ( i , 8 , 0.25 ) # S('bip:r*20', midinote='adisco((C|[C,F|Ab])!2)').out(i, 2) # petit surplus harmonique a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'f, f, ..' , shape = 0.7 ) . out ( i , 4 ) # -> monter shape pour les harmoniques S ( 'hhh:3' , amp = '[0:0.4, 0.05]' , legato = '0.1~0.5' ) . out ( i ) # -> hhh ramp S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) S ( 'juppad:3, juppad:4' , begin = 0.1 , orbit = 2 , cut = 0 , legato = 1.1 , speed = '1' , crush = 4 ) . out ( i , 8 , 0.25 ) # -> ici il y a de la r\u00e9duction a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'f' , shape = 0.7 ) . out ( i , 4 ) # -> monter shape pour les harmoniques S ( 'hhh:3' , amp = '[0:0.4, 0.05]' , legato = '0.1~0.5' ) . out ( i ) # -> hhh ramp S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) S ( 'laz:r*20' , speed = \"1, 2,4\" , hcutoff = 6000 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.25 ) S ( 'juppad:3, juppad:4' , begin = 0.1 , orbit = 2 , cut = 0 , legato = 1.1 , speed = '1, 2' , crush = 4 ) . out ( i , 8 , 0.25 ) # -> ici il y a de la r\u00e9duction a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'f' , shape = 0.7 ) . out ( i , 4 ) # -> monter shape pour les harmoniques S ( 'hhh:3' , amp = '[0:0.4, 0.05]' , legato = '0.1~0.5' ) . out ( i ) # -> hhh ramp S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) S ( 'laz:r*20' , speed = \"1, 2,4\" , hcutoff = 6000 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.25 ) S ( 'juppad:3, juppad:4' , begin = 0.1 , orbit = 2 , cut = 0 , pan = 'r' , legato = 1.1 , speed = '1|2|4' , leslie = 1 , lesliespeed = 8 , crush = 12 ) . out ( i , 8 , 0.25 ) # -> ici il y a de la r\u00e9duction a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( '., f' , shape = 0.7 ) . out ( i , 4 ) # -> monter shape pour les harmoniques S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) # S('juppad:3, juppad:4', orbit=2, cut=0, legato=1.1).out(i, 8, 0.25) S ( 'laz:r*20' , speed = \"1, 2,4\" , hcutoff = 3000 , legato = 1 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.25 ) S ( 'juppad:3, juppad:4' , speed = 0.75 , squiz = 2 , orbit = 2 , cut = 0 , legato = 1.1 ) . out ( i , 8 , 0.25 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'f' , shape = 0.7 ) . out ( i , 4 ) S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) S ( 'conga:r*20' , speed = \"[1,2,4]/4\" , hcutoff = 2000 , shape = 0.7 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.25 ) S ( 'juppad:3, juppad:4' , speed = 0.75 , squiz = 2 , orbit = 2 , cut = 0 , legato = 1.1 ) . out ( i , 8 , 0.25 ) S ( 'kit2:3' , shape = 0.5 ) . out ( i , 8 ) S ( '., kit2:10, ., kit2:9!2' , shape = 0.5 ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'f' , shape = 0.7 ) . out ( i , 4 ) S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) S ( 'conga:r*20' , speed = \"[1,2,4]/4\" , hcutoff = 2000 , shape = 0.7 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.25 ) S ( 'conga:r*20' , speed = \"[1,2,2]/2\" , hcutoff = 1000 , shape = 0.7 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.5 ) # S('juppad:3, juppad:4', # commenter ce bloc # speed=0.75, squiz=2, # orbit=2, cut=0, # legato=1.1).out(i, 8, 0.25) S ( 'kit2:3' , shape = 0.5 ) . out ( i , 8 ) S ( '., kit2:10, ., kit2:9!2' , shape = 0.5 ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): # S('f', shape=0.7).out(i, 4) S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) S ( 'conga:r*20' , speed = \"[1,2,4]/4\" , hcutoff = 2000 , shape = 0.7 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.25 ) # S('euclid(conga:r*20, 12,16)', speed=\"[1,2,4]/2\", hcutoff=1000, shape=0.7, # room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.4).out(i, 1, 0.25) # S('juppad:3, juppad:4', # commenter ce bloc # speed=0.75, squiz=2, # orbit=2, cut=0, # legato=1.1).out(i, 8, 0.25) S ( 'kit2:3' , shape = 0.5 ) . out ( i , 8 ) S ( '., kit2:10, ., kit2:9!2' , shape = 0.5 ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) # Remonter \u00e0 la ligne 167 pour plus de fun ############################################################################# ## ICI RUPTURE VERS L'INCLUSION DES FOUND SOUNDS ############################################################################# @swim def baba ( d = 0.5 , i = 0 ): # S('f', shape=0.7, cutoff=100).out(i, 8) S ( 'hhh:3' , amp = '[0:0.2,0.01]' , legato = '0.1~0.5' ) . out ( i ) # -> hhh ramp S ( '.., p:(5|10), .' , legato = 0.5 ) . out ( i , 1 ) S ( 'm|c:[4:9]' , legato = 0.2 ) . out ( i , P ( '4!12, 3!12' , i )) S ( 'lost:[1:100]' , # -> lost into jupfx cutoff = 9000 , # -> shape = 0.5 , pan = 'sin($/40)' , # -> X legato = 0.3 , # -> begin = 'r' ) . out ( i ) # -> begin r ou {0, 1, 0.1} a ( baba , d = 1 / 8 , i = i + 1 ) # Inclure @swim def baba ( d = 0.5 , i = 0 ): S ( 'a' , shape = 0.7 ) . out ( i , 4 ) # -> monter shape pour les harmoniques S ( 'c' , shape = 0.7 ) . out ( i , 3 ) # -> monter shape pour les harmoniques S ( 'd:7' , orbit = 3 , room = 0.2 , size = 0.8 , dry = 0.2 ) . out ( i , 8 ) S ( 'hhh:3' , amp = '{0, 0.2, 0.01}' , legato = '0.1~0.5' ) . out ( i ) # -> hhh ramp S ( '.., p:5, .' , legato = 0.5 ) . out ( i , 1 ) # -> refaire entrer \u00e7a S ( 'm|c:[4:9]' , legato = 0.2 ) . out ( i , P ( '4!12, 3!12' , i )) S ( 'lost:[1:100]' , # -> lost into jupfx cutoff = 9000 , # -> shape = 0.5 , pan = 'sin($/40)' , # -> X legato = 0.9 , # -> begin = 'r' ) . out ( i ) # -> begin r ou {0, 1, 0.1} a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): # potentiom\u00e8tre du r\u00e9el S ( 'a' , shape = 0.7 ) . out ( i , P ( '4!12, 5!12' , i )) # -> monter shape pour les harmoniques S ( 'c' , shape = 0.7 ) . out ( i , 3 ) # -> monter shape pour les harmoniques # S('c', shape=0.7).out(i, P('3!12, 2!12, 5!12',i)) # -> monter shape pour les harmoniques # S('hhh', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp S ( 'd:4, d:5, .' , legato = 0.5 ) . out ( i , 3 ) S ( 'm|g:[4:9]' , legato = 0.2 ) . out ( i , P ( '4!12, 1!24' , i )) S ( 'long|(lost:r*8)' , # -> lost into jupfx midinote = 'C' , cutoff = 4000 , # -> pan = '[0:0.5, 0.1], [0.5:1, 0.1]' , # -> X legato = '0.1|0.2|0.7|0.1' , cut = 1 , orbit = 2 , room = 0.5 , size = 0.2 , dry = 0.1 , begin = '[0:1,0.01], [1:0,0.01]' ) . out ( i ) # -> begin r ou {0, 1, 0.1} a ( baba , d = 1 / 8 , i = i + 1 ) # Ici on peut explorer des choses plus ambient et se perdre un peu @swim def baba ( d = 0.5 , i = 0 ): # potentiom\u00e8tre du r\u00e9el S ( 'a' , cutoff = 200 , shape = 0.7 ) . out ( i , P ( '4!12, 5!12' , i )) # S('c', cutoff=100, shape=0.7).out(i, 3) # S('c', shape=0.7).out(i, P('3!12, 2!12, 5!12',i)) # S('hhh', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp # S('d:4, d:5, .', legato=0.5).out(i, 3) S ( 'm|g:[4:9]' , legato = 0.2 ) . out ( i , P ( '4!12, 1!24' , i )) S ( 'long|(lost:r*8)' , # -> lost into jupfx midinote = 'C' , cutoff = 4000 , # -> pan = '[0:0.5, 0.1], [0.5:1, 0.1]' , # -> X legato = '[0.1|0.2|0.7|0.1]+0.6' , # -> facteur de fun cut = '1|0, 1|0, 1!4' , orbit = 2 , room = 0.5 , size = 0.2 , dry = 0.1 , begin = '[0:1,0.01], [1:0,0.01]' ) . out ( i ) # -> begin r ou {0, 1, 0.1} a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): # S('f', shape=0.5).out(i, 4) # S('hhh', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp # S('d:4, d:5, .', legato=0.5).out(i, 3) # S('d:{4,9}', legato=0.5).out(i, 4) # S('z', shape=0.8).out(i, 4) S ( 'hhh:12' , hcutoff = 500 , speed = '[1:10]' , shape = 0.8 ) . out ( i , 1 ) # S('kit5:[6!4,7!2,5!5,4]', shape=0.8).out(i, 3) # S('q:r*8', shape=0.4).out(i, P('1!12, 2!8', i)) S ( 'long:1' , # -> lost into jupfx midinote = 'C' , cutoff = 4000 , # -> pan = '[0:0.5, 0.1], [0.5:1, 0.1]' , # -> X legato = '0.1|0.2|0.3|0.1' , begin = '[0:1,0.01], [1:0,0.01]' ) . out ( i ) # -> begin r ou {0, 1, 0.1} a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): # S('f', shape=0.5).out(i, 4) # S('hhh', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp # S('d:4, d:5, .', legato=0.5).out(i, 3) # S('d:{4,9}', legato=0.5).out(i, 4) # S('z', shape=0.8).out(i, 4) S ( 'hhh:12' , hcutoff = 500 , speed = '[1:10]' , shape = 0.8 ) . out ( i , 1 ) # S('kit5:[6!4,7!2,5!5,4]', shape=0.8).out(i, 3) # S('q:r*8', shape=0.4).out(i, P('1!12, 2!8', i)) S ( 'long:1' , # -> lost into jupfx midinote = 'C' , cutoff = 4000 , # -> pan = '[0:0.5, 0.1], [0.5: 1, 0.1]' , # -> X legato = '0.1|0.2|0.3|0.1' , begin = '[0:1,0.01], [1:0,0.01]' ) . out ( i ) # -> begin r ou {0, 1, 0.1} a ( baba , d = 1 / 8 , i = i + 1 ) panic () S ( 'lost' ) . out () S ( 'lost:2' ) . out () # F\u00eater Halloween S ( 'lost:7' , legato = 7 , speed = 0.5 , release = 7 ) . out () S ( 'lost:0' , legato = 7 , speed = 0.5 , release = 7 ) . out () S ( 'lost:3' , legato = 7 , speed = 0.5 , release = 7 ) . out () panic () # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588 \u2588 # \u2588 \u2588\u2003\u2588\u2003 \u2003\u2584\u2584\u2003 \u2003\u2588\u2591\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2584\u2580\u2588 \u2588 # \u2588 \u2588\u2003\u2588\u2003 \u2003\u2591\u2591\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2580\u2584\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2588\u2580\u2588 \u2588 # \u2588 \u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 @swim def baba ( d = 0.5 , i = 0 ): # S('bip:r*20', shape=0.4, midinote='quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)').out(i, 1, 0.25) # S('bip:r*20+20', shape=0.4, midinote='quant([0+12|24,3,6,10]+62, C@minor), quant([0,3,10]+62|74, F@minor)').out(i, 3, 0.25) S ( 'boop:r*40' ) . out () a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'bip:r*20' , orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , shape = 0.4 , midinote = 'quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)' ) . out ( i , 1 , 0.25 ) S ( 'bip:r*20+20' , orbit = 2 , room = 0.5 , size = 'r' , dry = '0.1' , shape = 0.4 , midinote = 'quant([0+12|24,3,6,10]+62, C@minor), quant([0,3,10]+62|74, F@minor)' ) . out ( i , 3 , 0.25 ) S ( 'boop:r*40' ) . out () a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'bip:r*20' , orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 1 , shape = 0.4 , midinote = 'quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)' ) . out ( i , 1 , 0.25 ) S ( 'bip:r*20, boop:r*200' , orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 1 , shape = 0.4 , midinote = 'quant([0+12|24,1~20,6,0~20]+80, C@minor), quant([0~20,3,10]+50, F@minor)' ) . out ( i , 3 , 1 ) S ( '(ff):r*20' , # ulh electrowave ff orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 0.2 , hcutoff = 500 , shape = 0.4 , midinote = 'quant([0+12|24,1~20,6,0~20]+50, C@minor), quant([0~20,3,10]+50, F@minor)' ) . out ( i , 2 , 1 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'ff' , shape = 0.5 ) . out ( i , 4 ) S ( 'll' , shape = 0.5 ) . out ( i , 4 ) S ( 'gameboysnare' , cutoff = 800 ) . out ( i , 8 ) S ( '., hhh:r*40' , hcutoff = 9000 ) . out ( i , 1 ) S ( '., hhh:r*40' , hcutoff = 9000 , speed = '1~50' ) . out ( i , 1 ) S ( 'bip:r*20' , orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 1 , shape = 0.4 , midinote = 'quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)' ) . out ( i , 1 , 0.25 ) S ( 'bip:r*20, boop:r*200' , orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 1 , shape = 0.4 , midinote = 'quant([0+12|24,1~20,6,0~20]+80, C@minor), quant([0~20,3,10]+50, F@minor)' ) . out ( i , 3 , 1 ) S ( '(ulh):r*20' , # ulh electrowave ff orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 0.2 , hcutoff = 500 , shape = 0.4 , midinote = 'quant([0+12|24,1~20,6,0~20]+50, C@minor), quant([0~20,3,10]+50, F@minor)' ) . out ( i , 2 , 1 ) a ( baba , d = 1 / 8 , i = i + 1 ) # <-> des allers retours @swim def baba ( d = 0.5 , i = 0 ): # S('ff, gg:r*29', shape=0.8, leslie=1, leslierate=5, lesliespeed=2).out(i, 2) # S('ll', shape=0.8).out(i, 4) S ( 'gameboysnare' , cutoff = 800 ) . out ( i , 8 ) # S('., hhh:r*40', hcutoff=9000).out(i, 1) S ( '., hhh:r*40' , hcutoff = 9000 , speed = '1~50' ) . out ( i , 1 ) # S('bip:r*20', lesliespeed='2*8', leslierate='r*5', leslie=1, # orbit=2, room=0.7, size='r', dry='0.1', legato=1, # shape=0.4, midinote='quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)').out(i, 1, 0.25) S ( 'bip:r*20, boop:r*200' , lesliespeed = '2*8' , leslierate = 'r*5' , leslie = 1 , orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 1 , shape = 0.4 , midinote = 'quant([0+12|24,1~20,6,0~20]+80, C@minor), quant([0~20,3,10]+50, F@minor)' ) . out ( i , 3 , 1 ) S ( '(ulh):r*20' , # ulh electrowave ff orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 0.2 , hcutoff = 500 , shape = 0.4 , midinote = 'quant([0+12|24,1~20,6,0~20]+50, C@minor), quant([0~20,3,10]+50, F@minor)' ) . out ( i , 2 , 1 ) a ( baba , d = 1 / 8 , i = i + 1 ) # --|--> transition du coq \u00e0 l'\u00e2ne @swim def baba ( d = 0.5 , i = 0 ): S ( 'm, ..., m, ...' , shape = 0.5 ) . out ( i , 2 ) S ( 'rev([s,a,l,u,t, z,o,r,b,a]:r*8)' , legato = 0.1 , pan = 'tan(r/100)' , accelerate = 0.2 , room = 0.1 , dry = 0.1 , size = 0.1 , ) . out ( i , 2 ) S ( 'perca:[1:20], ..' , speed = 2 if rarely () else 'r*4' , ) . out ( i , 2 ) a ( baba , d = 1 / 16 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'm, ..., m, ...' , shape = 0.5 ) . out ( i , 2 ) S ( 'long:13' , shape = 0.5 , begin = '0.5, 0.5, 0.42, 0.5!2, 0.6' , orbit = 3 , cut = 1 , legato = 2 ) . out ( i , 8 , 0.25 ) S ( 'perca:[1:20], ..' , speed = 2 ) . out ( i , 2 ) a ( baba , d = 1 / 16 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'f, ..., f, ...' ) . out ( i , 2 ) S ( 'gg, ...' , shape = 0.5 , orbit = 4 , room = 0.2 , size = 0.2 , dry = 0.2 ) . out ( i , 2 ) S ( 'perca:[1: 20], ..' , speed = '1+r*4' , cutoff = '200+r*8000' ) . out ( i , 2 ) S ( 'perca:[20: 1], .' , speed = '0.1+sin($)' , cutoff = '200+r*8000' ) . out ( i , 3 ) S ( 'long:13' , shape = 0.7 , begin = '0.1, 0.2, 0.3, 0.5' , orbit = 3 , cut = 1 ) . out ( i , 8 , 0.25 ) # 0.5 0.6 a ( baba , d = 1 / 16 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'm, ..., m, ...' , shape = 0.5 ) . out ( i , 2 ) S ( 'hhh:r*49' , amp = 0.3 , hcutoff = 'sin(i.i/40)*7000' ) . out ( i , 2 ) S ( 'long:13' , shape = 0.5 , begin = '0.6, 0.5, 0.42, 0.6, 0.7' , orbit = 3 , cut = 1 , legato = 2 ) . out ( i , 8 , 0.25 ) S ( 'q:[1:20], ..' , speed = 2 ) . out ( i , 2 ) a ( baba , d = 1 / 16 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'm, ..., m, ...' , shape = 0.5 ) . out ( i , 2 ) S ( 'hhh:r*49' , amp = 0.3 , hcutoff = 'sin(i.i/40)*7000' ) . out ( i , 2 ) S ( 'long:13' , shape = 0.5 , begin = '0.5, 0.5, 0.42, 0.5!2, 0.6' , orbit = 3 , cut = 1 , legato = 2 ) . out ( i , 8 , 0.25 ) S ( 'q:[1:20], ..' , speed = 2 ) . out ( i , 2 ) a ( baba , d = 1 / 16 , i = i + 1 ) # une petite transition jsp @swim def baba ( d = 0.5 , i = 0 ): # S('m, ..., m, ...', shape=0.5).out(i, 2) # S('hhh:r*49', amp=0.3, hcutoff='sin(i.i/40)*7000').out(i, 2) S ( 'jupfx:r*20' , shape = 0.5 , hcutoff = '200 + r*8000' , begin = '0.5, 0.5, 0.42, 0.5!2, 0.6' , orbit = 3 , cut = 1 , legato = 2 ) . out ( i , 8 , 0.25 ) S ( 'q:[1:20], ..' , speed = 2 ) . out ( i , 2 ) a ( baba , d = 1 / 16 , i = i + 1 ) # D\u00e9brouille toi # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588 \u2588 # \u2588 \u2588\u2003\u2588\u2003\u2588\u2003 \u2003\u2584\u2584\u2003 \u2003\u2580\u2588\u2580\u2003\u2584\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2580\u2588\u2580\u2003\u2588\u2580\u2580\u2003 \u2003\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2580\u2588\u2580\u2003\u2588\u2580\u2588\u2003 \u2003\u2580\u2588\u2580\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588 \u2588 # \u2588 \u2588\u2003\u2588\u2003\u2588\u2003 \u2003\u2591\u2591\u2003 \u2003\u2591\u2588\u2591\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2584\u2003\u2591\u2588\u2591\u2003\u2588\u2588\u2584\u2003 \u2003\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2591\u2588\u2591\u2003\u2588\u2584\u2588\u2003 \u2003\u2591\u2588\u2591\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2584 \u2588 # \u2588 \u2588 # \u2588 \u2588\u2580\u2003\u2584\u2580\u2588\u2003\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2580\u2588\u2580\u2003\u2584\u2584\u2003\u2588\u2580\u2580\u2003\u2580\u2588\u2580\u2003\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2584\u2591\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2588\u2580\u2580 \u2588 # \u2588 \u2584\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2591\u2588\u2591\u2003\u2591\u2591\u2003\u2588\u2588\u2584\u2003\u2591\u2588\u2591\u2003\u2588\u2003\u2588\u2588\u2584\u2003\u2588\u2591\u2580\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2588\u2588\u2584 \u2588 # \u2588 \u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 , * ,,,,,,,,,,,, . ,,,, ..***** ,, . .. , * , . . .. ........ ,,, . ,,,,,,,,,, . ,, .* * ( **/** , /* ( ** , **///** ,, *////* ,, .. ,, //.. .. , . .... ,,,,,,,, ********** ( // ((( */***/*** , /******/ , . . .... ,,,, .. ,, **. ... .. , ..... ,, . ,,,,, ********* ((( //* * (( *//** ,, / ,,,,, * , . .. .... ,,, .../ #%%%%#(,.. .,,,....,...,,,,.,,,,**,,****(/ *****/ ,, * , ** , ** ,,, ... , . , . , */ #%%%%%%%%%%%%%%%#(. .,,..,,...,...,..,..,,,,****/*** *// , **//*****/** , .....% #%&&%%&&&&%&%%%%%%%%%%%%##%#...... ,,..,..*.,,,,/**/*,,** *//* ,, * ,, ****** ,, / ,, . #%&&&&&&&&&&&&&%#%&%%&%%%%###%( .. ..,,..,,,..,,..,.****,** *//* ,,,, **** ,,,,,,,, #%&&&&&&&%&%&%%%%&&&%&&&%%%%%###(#* ....,,,,.,........,,**, *//***** , ***...... #%&%&&&%&%%&%%%%#%%%&&&&&%%%%%%%%%%%#**,*,....,,.,*.......,,, */******* ,,, ...... #%%&%&%&&&%%%&&%%%%%#%%%%%%%%%###%%#%%(,,,,*, .... ,..,,,,./ */***** ,, * , ..... ,( &&&%&&&% ( *** ( &** , **** ,, * (( ##%/#/#%%%#%%(////**,,......,,,,,.*, */* ,,,,,, . , * , .. #%%&&&&%#/***************,**,... .*#%%%%%#//*.,..........,*/*,., */**** ,,, ... , . , . #%&&&&%(/********,,,****,***,... ,/%%#(*.............,.,,,..,* */** ,,,,,,,, .... , %%%&&&/**/////*** , **/*** ,, * , * , ... ./ ( #,...,..,.,,..,,,,...,,,* */**** , ** , ** , * , ..*%&&&/** #(///(//((/*/*,**/////***,..#%(, .....,.....,,. ....,*, *//********** ,,,, //%%%**// ( % #&%#////(,,#/*(*###*/*.../#(/,.,.,,.. ... . .,,.., *//*///** ,,,, *** ,, //%%***/ (((((( // ((,,,,(( / ((( //.*... , #/,...,,.,...,.. .,......, */// ( **//*****/*** ,( % #****///**/****,,,,.,**,,,,,.,,,(#*..,,...,.. ............, *//*/* ,, ** ,,,, **/*** #%(**********/****,....,,,,,.....#(*,,......,. .,,.,**,,,.. *//*/* , */** , * ,,,,,, . , ##//**********,**,,..,,,,.... ,((******//(*.....*,,.,....* *//*///**// ,, .** , .. ,,, % #***********((/./(,*,,,,. ..,*((,,,....,,..,.,,,*,.,...,* / #/((***/,***,,,.,,,**(((***,*,****((#/*/,,,... .,(#,,....... ..,,,***,,,.,.* * (( / ( /***.* ,,, .. , . , * , // ( #(//****//(((((/(///.*...,.//(/***,.,*.. ....,***,...,* * (( //* ,,,,, ....... ,, .. , * ( ##(//***//((//(*(*,*,...,*/*,... .. . ......,..,.,, / (((( / ,,,, ........... ,, **/ ( #((/**/***/*,,,***,.,.////*******,,.,,. .... ...,., * ((( /* ,,,,,,, ./ , .......* ,, / ###(/********,,.,*(*,.,,.....,,,.. .. ......,.. * (( //** ,, . ,, **** , . ,,, ...*% ( .. ( ###%#((((((//(#(/. ,.*,,,,..,.. ..... ......,. * (( ///* , . , * , ****... , */.&&&% , . ,, * ( ##%%%%%%%##(/. .%#((,.,.., ...........,,,,,,. / ( / ( ** ,,, .. ,,,,, **/**/&&@&&&/* , /. , * (((((((( . ... ,( % #%%%%%,,,,....... ...,.,,,, * ( //** , *** , ** , ***** ( %&&&@&&@&%* , . ,, *// ((( / , .. , /%%%%%%%%%% ##*,*,...............,. * ( //*** ,, */ , * ,,( &&&&@&@@@&&&& (,,,,,,, * ( #,,,,,,*#%%%%%%%%%%%%%#**.........,/***** * ( ///**** ,,( &&&&@@@@@@&&@&&&& ##%&&&&&&&&&&&&%##%%&&&%%&%%%%%%%#(%(/*....***,*,,, * (((((( &@&&&&@@@@&&@&@&&&&&%%&&&&&@&&&&&@@@&&%%%%%%%%%%%%% #%%#%%*,,...,,,*,,***, /%&%&@&%&@@@@@&&&&&%%&&@&&&@&&@@&&& #,,,,,##&%(%%&%%%%#%%##%/. /#/...,,..,,,,... /&&&%&&&&&%&&@&&&&&&&&&&&&&&% #%&&&&%(.,,,,,,/&&&&%%%%%##**,. ,,/,.,.,.*,*,(#&(.. /&&% #%%%###%&@&&&&&%%%%%%%&&&&&%&%&%*,.,,...%%%&%%%(%#*,,.,,./,,.,,,./(#(*#(%(#( /&&@&@&%&@@@&@&&&% ( #%%%#%&&&&&&&%%&&%#.... %%%%&&%#(*,,...(/,,,*,(%%###(####/*%( /&@@@&@&& #%##&%(/*/(#%%%#%&@&&%#%%&&%&%,./&&&%%%#***....**,*/*%%%%&%(#%#####(/(* / #%&@%%##&&&%(/((,,(%&%#%%%&&%%#%#%%&%&%&&&&%%(*.....(.*.,/#%%%&%%%%###%#%%###(. / ######/(%%&%(%%#(((/#%&@&&&&&%&&%%&&%&&&&&%/,,.. ,.,.,(#%&%&%%%&%%%#%%%(((//%%( /%%% #(#%%%%%%%%#######(((%&&@&&%%%%%&&%%%(,,,,..,,,(%%&&%#%%%####((%#%(/(#%#(#** /%%%%%%%&&&%&&%%%% #(((((((#*%&@&%%&&%%%/,*,,.*,//&%%&%%%%&&%####(/*#%(/(#%%#**,* /&&%&%%%%%%% ##%%###(#((#*#%((//(////***/*.**##%%%#%##%&%#(##%%%%#*/#//*/#(/#(*** # C'EST PIERRE BONNARD, IL FAUT ALLER LE VOIR. @swim def baba ( d = 0.5 , i = 0 ): M ( velocity = '90~110' , note = 'inrot(C@maj7, F@maj7)-12' ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): M ( velocity = '90~110' , dur = 1 , note = 'inrot(C@maj7, F@maj7)-12' ) . out ( i , 2 ) M ( velocity = '90~110|70' , dur = '15~20' , note = \"F', ..., G'', ..., [D, E, F, A]+12\" ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): M ( velocity = '90~110' , dur = 1 , note = 'inrot(C@maj7, F@maj7)-12' ) . out ( i , 2 ) M ( velocity = '90~110|90' , dur = '15~20' , note = \"F., ..., F.., ...\" ) . out ( i , 2 ) M ( velocity = '90~110|90' , dur = '15~20' , note = \"F., A, .., F.., ...\" ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) # <-> alterner @swim def baba ( d = 0.5 , i = 0 ): M ( dur = '2~5' , note = 'inrot(C@maj7, F@maj7)-12' ) . out ( i , 2 ) M ( dur = '2~5' , note = 'disco(inrot(C@maj7, F@maj7))' ) . out ( i , 5 ) M ( dur = '2~12' , note = 'adisco(inrot(inrot(C@maj7, F@maj7), G@fifths))' ) . out ( i , 4 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): M ( note = 'inrot(C@maj7, F@maj7)-12' ) . out ( i , 2 ) if rarely (): M ( note = 'disco(inrot(C@maj7, F@maj7))' ) . out ( i , 5 ) if sometimes (): M ( note = 'adisco(inrot(inrot(C@maj7, F@maj7), G@fifths))' ) . out ( i , 4 ) a ( baba , d = 1 / 8 , i = i + 1 ) c . _midi_nudge = 0.30 @swim def baba ( d = 0.5 , i = 0 ): S ( 'ff' ) . out ( i , 4 ) M ( velocity = '90~110' , dur = 1 , note = 'inrot(C@maj7, F@maj7)-12' ) . out ( i , 2 ) M ( velocity = '90~110|90' , dur = '15~20' , note = \"F., ..., F.., ...\" ) . out ( i , 2 ) M ( velocity = '90~110|90' , dur = '15~20' , note = \"F., A, .., F.., ...\" ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588 \u2588 # \u2588 \u2588\u2003\u2588\u2591\u2588\u2003 \u2003\u2584\u2584\u2003 \u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2588\u2580\u2588\u2003 \u2003\u2584\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2588\u2003 \u2588 # \u2588 \u2588\u2003\u2580\u2584\u2580\u2003 \u2003\u2591\u2591\u2003 \u2003\u2588\u2584\u2584\u2003\u2588\u2588\u2584\u2003 \u2003\u2588\u2580\u2580\u2003\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2588\u2584\u2588\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2584\u2588\u2003 \u2588 # \u2588 \u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 panic () @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit3:[1,2,1,2,4,5,4,6]' , legato = 1 ) . out ( i , 8 ) S ( 'long:42' , begin = 'r' , cut = 1 ) . out ( i , 8 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) if sometimes (): S ( 'z:6' if random () > 0.5 else 'z:7' , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit3:[1,2~10,1,2,4~10,5,4,6]' , legato = 1 ) . out ( i , 8 ) S ( 'long:42' , begin = 'r' , cut = 1 ) . out ( i , 8 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): # Ce truc est quand m\u00eame giga fade :'((((((((((((( S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) if sometimes (): S ( 'z:6' if random () > 0.5 else 'z:7' , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) # Du du du du dudududududu dudu du du dud udu dudu a ( baba , d = 1 / 32 , i = i + 1 ) # R\u00e9ponse : @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit3:[0, 1,2,1,2,4,5,4,6,7,8, 1, 0]' , legato = 1 ) . out ( i , 8 ) S ( 'long:42' , begin = 'r' , cut = 1 ) . out ( i , 8 ) S ( 'long:42~46' , begin = 'r' , cut = 1 , speed = 0.5 ) . out ( i , 8 ) S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) if sometimes (): S ( 'z:6' if random () > 0.1 else 'z:7' , pan = 'r' , legato = 1 , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) if sometimes (): S ( 'dd:6|7|8' if random () > 0.5 else 'j:0~7' , pan = 'r' , legato = 1 , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) S ( 'long:20~33' , begin = 'r' , cut = 1 ) . out ( i , 8 ) S ( 'long:42~46' , begin = 'r' , cut = 1 , speed = 0.5 ) . out ( i , 8 ) S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) if sometimes (): S ( 'z:6' if random () > 0.1 else 'z:8~400' , pan = 'r' , legato = 1 , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) if sometimes (): S ( 'dd:6|7|8' if random () > 0.5 else 'z:7~200' , pan = 'r' , legato = 1 , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) # S('long:42', begin='{0,2,0.4}', cut=1).out(i, 16) S ( 'long:42' , begin = '[0:1, 0.08]' , cut = 1 ) . out ( i , 16 ) # -> \u00e9plucher comme un oignon (solo de fichier .wav) # S('long:42~46', begin='r', cut=1, speed=0.5).out(i, 8) # S('jupbass:28|44, jupbass:28', octave=4, # legato=1, cut=1, orbit=3).out(i, 24, 1) if sometimes (): S ( 'z:6' if random () > 0.1 else 'z:8~400' , pan = 'r' , legato = 1 , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) if sometimes (): S ( 'dd:6|7|8' if random () > 0.5 else 'z:7~200' , pan = 'r' , legato = 1 , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) S ( 'long:10~33' , begin = 'r' , cut = 1 , speed = \"1~8\" ) . out ( i , 8 ) S ( 'long:20~46' , begin = 'r' , cut = 1 , speed = \"1~8\" ) . out ( i , 8 ) a ( baba , d = 1 / 32 , i = i + 1 ) # R\u00e9ponse : @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit2:[0, 1,2, 0, 1,2,4,5,4,0,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) S ( 'kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) S ( 'long:103' , begin = '0.1, 0.5' , cut = 1 , speed = \"1~8\" ) . out ( i , 16 ) S ( 'long:20' , begin = '0.1, 0.5' , cut = 1 , speed = \"1~8\" ) . out ( i , 8 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'cc' ) . out ( i , 12 ) S ( 'kit2:[0, 1,2, 0, 1,2,4,5,4,0,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) S ( 'kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) S ( 'long:103' , begin = '0.1, 0.5' , cut = 1 , speed = \"1~8\" ) . out ( i , 16 ) S ( 'long:20' , begin = '0.1, 0.5' , cut = 1 , speed = \"1~8\" ) . out ( i , 8 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) S ( 'kit4:r*20' , legato = 0.4 , begin = 0.01 ) . out ( i , 12 ) S ( 'kit3:[1,2,1,2,4,5,4,6]' ) . out ( i , 8 ) S ( 'long:40' , begin = '0.60!4, 0.555!2, 0.27!4, 0.25!2' , orbit = 2 , cut = 1 ) . out ( i , 32 ) S ( 'long:40' , speed = 1.01 , begin = '0.60!4, 0.555!2, 0.27!4, 0.25!2' , orbit = 2 , cut = 1 ) . out ( i , 32 ) if sometimes (): S ( 'z:6' , shape = 0.9 , hcutoff = 5000 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) panic () @swim def baba ( d = 0.5 , i = 0 ): S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) S ( 'kit4:r*20' , legato = 0.4 , begin = 0.01 ) . out ( i , 12 ) S ( 'kit3:[1,2,1,2,4,5,4,6]' ) . out ( i , 8 ) S ( 'long:26' , amp = 0.5 , begin = '0.60!4, 0.555!2, 0.27!4, 0.25!2' , orbit = 2 , cut = 1 ) . out ( i , 32 ) S ( 'long:26' , speed = 1.01 , begin = '0.60!4, 0.555!2, 0.27!4, 0.25!2' , orbit = 2 , cut = 1 ) . out ( i , 32 ) if sometimes (): S ( 'z:6' , shape = 0.9 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) # Variation 3 @swim def baba ( d = 0.5 , i = 0 ): S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) S ( 'kit4:r*20' , legato = 0.4 , begin = 0.01 ) . out ( i , 12 ) S ( 'kit3:[1,2,1,2,4,5,4,6]' ) . out ( i , 8 ) S ( 'long:40' , begin = '0.60!4, 0.555!2, 0.27!4, 0.25!2' , orbit = 2 , cut = 1 ) . out ( i , 32 ) S ( 'long:40' , speed = 1.01 , begin = '0.60!4, 0.555!2, 0.27!4, 0.25!2' , orbit = 2 , cut = 1 ) . out ( i , 32 ) if sometimes (): S ( 'z:6' , shape = 0.9 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) panic ()","title":"Zorba in Belleville"},{"location":"documentation/demos/zorba_in_belleville/#zorba-in-belleville-11112022","text":"","title":"Zorba in Belleville (11/11/2022)"},{"location":"documentation/demos/zorba_in_belleville/#description","text":"This code is taken from an algorave that took place at the Zorba ( Belleville , Paris) in early november (2022). It is a very straightforward dance oriented performance that plays a lot with simple audio sample manipulations. As stated in the opening banner, this performance was meant to test the stability of Sardine after introducing new features and control mechanisms. Everything lives in the baba function, meaning that you only need to keep track one function during the whole performance. Sounds are extracted from a very heavy sound library, lazy-loaded when needed. This is how I like to make music, extracting a lof of raw audio files from my hard disk :)","title":"Description"},{"location":"documentation/demos/zorba_in_belleville/#performance","text":"","title":"Performance"},{"location":"documentation/demos/zorba_in_belleville/#source-code","text":"# \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588 # \u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588 # \u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588 # \u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588 # \u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588 # \u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588 # \u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2584\u2580\u2591\u2591\u2588\u2591\u2591\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2584\u2580\u2591\u2591\u2588 # \u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2580\u2003\u2588\u2591\u2588\u2003 \u2003\u2580\u2588\u2580\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2003\u2580\u2588\u2580\u2003 \u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2003\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003 \u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2588\u2003\u2584\u2580\u2588\u2003 \u2003\u2588\u2580\u2588\u2003\u2591\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2584\u2588 # \u2588\u2584\u2584\u2003\u2588\u2580\u2584\u2003\u2588\u2580\u2588\u2003\u2584\u2588\u2003\u2588\u2580\u2588\u2003 \u2003\u2591\u2588\u2591\u2003\u2588\u2588\u2584\u2003\u2584\u2588\u2003\u2591\u2588\u2591\u2003 \u2003\u2580\u2584\u2580\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2584\u2003\u2584\u2588\u2003\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2591\u2580\u2588\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003 \u2003\u2588\u2584\u2588\u2003\u2584\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2588\u2003\u2591\u2588 # @@@@@@@@@@@@@@@@@@@@@@@@@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ # @@@@@@@@@@@@@@@@@....,.....,..,,,,,,,,,,,,,*(&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ # @@@@@@@@@@@@&.,,,,/*//////////**,*.*,*..,***,,,,**********/(%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ # @@@@@@@@@@(..,*//**/***,,,,,(%((%%,/,%%%%(****,,.,,********,,,*/*/*****///(%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ # @@@@@@@@@ .,(/////*,,,,,,,/%%%(*.((,/%%(/.((/%/%//,//,/#%(*****************,,*****///////(&@@@@@@@@@@@@@@@@@@@@@@@@ # @@@@@@@@ ./(//*,*,,**,,,,,,,,,,*,*,,**,*/#%%%%%,*#(*(,,(*%(,(*,/*(%(#,/%%/****************,*//*//****/&@@@@@@@@@@@@ # @@@@@@@ .(##***,*,,,,,,,,,,,,,,,,,,,,,*,*,,****,*,****,*(%%%/##/(%,./*//(%(,(%(./((/,*%**************.,****%@@@@@@@ # @@@@@@.*///*********,*,**,,*,,,,,,,%%%%%((#%%%%%,,(%%%%%%%%%%%##%%#,,**/%&%%(/,&(,((/#%%%*,,,,,,,,,,,,,,,..***(@@@@ # @@@@@%/**/*****,,***,,,,,,,,,,,%%%%##/##%%%%%%%%%%%#((**###%%%%####%#####%#(,,********/#%***,,,,,,,,,,,,,,,,.,**/@@ # @@@@@,/**,**************,,,,,*%%%/.((*%*/,/((*#./*. .. ..*,/(##/*,,###*/#/(#%%%#(#,*,#%%%%%%%%%/,,*,,,,,,,,,,..***@ # @@@@ ,/**********,*******,,,,*,% #*,,//#%(.#*,,**#,(##(/**##%##%##/,/#%(//(//,.(#(#%#((,#%%##*##%%%,,,,,,,,,,,. *** # @@@ .,///*******,*,*,**,,**,,*,,*./ /((..((/(%,,/#(/(/*,*#,.*#/###%%##/**/(/(/.(//%%%%%/###%##,,,%%%***,,,,,,.. .** # @@@...////*************,***,,,/(((((*.(., #*( *(..#/(/*(///(##(#(####(/#(*##%(/((%%%%%%%/((#%%%%%%%#***,,,**, ,* # @@,..../(//********,,***,,,***(((((( ((*((,,##,,,/###(//*(##((((((#(, ,(%%#%%,.,(####%###,/%&******,*,*, .( # @@*/.,..*(*/***********,*,,*,,,,,**(.((.(((((((((**,(%%%%%%%%###########(*//(#((//*/. *,/(#%##,.,******,**,*,, ,% # @@,/*,*.,..(***************,,*,,,*,#*&(**(,* (( .(((((..((((/********,,*,****/((((((,***********************, *( # @/,*/**,,*,,...,*,,*,*,..,,*,,,,,,*,*,**,(#&(,*,/((./(( (( /(. ...(((*../( (#((((((((((********************** .*#, # @, *//********/.,,.........,,,,,,,,,,*,,..,,,**,,**##(%&#*****/((#(((((((((((/*,***************************,...**%# # @% ,*/******//////////**/****,.,,.........,,**/*,,,,,,,,,,,*,*******,************************************,.. **,#,@ # @@* .********/*///////////*/////////*********,,,,,,***//*//////***,*,,,,,,****************************,... ,***/#/@ # @@@#/..********///////////**/*,*,/#.//////////////**********,,.,,**********//*,,,,,,,.,***********,.....,*/*,*(#(&@ # @@@@@&(*,,******///////./,//**/.**//////,/***,/#,,//**,/.////////******/***,,..,,*,...,,**/*,,**,*//*/*****/((#%*@@ # @@@@@@@@%/(/,,,***///////*,,**/**////,**/*/,,**////**///***./*//.*/////////////*******/*,,******,,*//#/(//(((##*%@@ # @@@@@@@@@@@@@((/(((((/*,,,**//****///**,*//****///***.*//**////***////*(%%##%%/&&&///////////////(((((((((((###*@@@ # @@@@@@@@@@@@@@@@@@@@@@&#/(#####(((//*,,,,**/***//******,,***///**./*/**%%&&&###((&&%**//////////(((((((((((((/*@@@@ # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&#/(####((((/**,,,,**/////****////****/%###%/%&***////////(((((((((((((/,(@@@@@ # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&#/#####(((/(/*,,,,***///****///****/////////(((((((((/**(&@@@@@@ # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&(/#####(((((/*,,,******///////((((//**#(%@@@@@@@@@ # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&((#####((((#%&%%##%%#%@@@@@@@@@@@@@@ # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # # \u2588\u2580\u2584\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2003 \u2003\u2580\u2588\u2580\u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2588\u2003\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003 \u2003\u2588\u2591\u2588\u2591\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003\u2580\u2588\u2003 \u2003\u2588 \u2588 \u2588 # \u2588\u2591\u2580\u2591\u2588\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2584\u2003\u2588\u2584\u2584\u2003\u2588\u2003 \u2003\u2591\u2588\u2591\u2003\u2588\u2580\u2588\u2003\u2588\u2588\u2584\u2003\u2588\u2584\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2588\u2584\u2003 \u2003\u2580\u2584\u2580\u2584\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2584\u2584\u2003\u2588\u2588\u2584\u2003\u2588\u2584\u2003 \u2003\u2584 \u2584 \u2584 # # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588 \u2588 # \u2588 \u2588\u2003 \u2003\u2584\u2584\u2003 \u2003\u2588\u2580\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2580\u2584\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003 \u2003\u2588\u2580\u2003\u2584\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2588\u2580\u2003 \u2003\u2588\u2580\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2580\u2584\u2580\u2588\u2003\u2588\u2580\u2580 \u2588 # \u2588 \u2588\u2003 \u2003\u2591\u2591\u2003 \u2003\u2588\u2580\u2584\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2580\u2591\u2588\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2584\u2003 \u2003\u2584\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2584\u2588\u2003 \u2003\u2588\u2580\u2584\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2580\u2591\u2588\u2003\u2588\u2588\u2584 \u2588 # \u2588 \u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 @swim def baba ( d = 0.5 , i = 0 ): S ( 'juppad:3, juppad:4' , cutoff = 5000 , begin = 0.1 , orbit = 2 , cut = 0 , legato = 1.1 ) . out ( i , 8 , 0.25 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'juppad:3, juppad:4' , cutoff = 5000 , begin = 0.1 , orbit = 2 , cut = 0 , legato = 1.1 ) . out ( i , 8 , 0.25 ) # up # S('bip:r*20', shape=0.4, midinote='quant([0,3,10]+50, C@minor), quant([0,3,10]+50, F@minor)').out(i, 1, 0.25) S ( 'boop:r*40' ) . out () a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): # S('f', shape=0.7).out(i, 4) # -> monter shape pour les harmoniques # S('hhh:3', amp='[0:0.4,0.05]', legato='0.1~0.5').out(i) # -> hhh ramp S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) # S('.., p:6, ., .., p:3, ..', legato=0.5, shape=0.7).out(i, 1) S ( 'juppad:3, juppad:4' , begin = 0.1 , orbit = 2 , cut = 0 , legato = 1.1 ) . out ( i , 8 , 0.25 ) # S('bip:r*20', midinote='adisco((C|[C,F|Ab])!2)').out(i, 2) # petit surplus harmonique a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'f, f, ..' , shape = 0.7 ) . out ( i , 4 ) # -> monter shape pour les harmoniques S ( 'hhh:3' , amp = '[0:0.4, 0.05]' , legato = '0.1~0.5' ) . out ( i ) # -> hhh ramp S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) S ( 'juppad:3, juppad:4' , begin = 0.1 , orbit = 2 , cut = 0 , legato = 1.1 , speed = '1' , crush = 4 ) . out ( i , 8 , 0.25 ) # -> ici il y a de la r\u00e9duction a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'f' , shape = 0.7 ) . out ( i , 4 ) # -> monter shape pour les harmoniques S ( 'hhh:3' , amp = '[0:0.4, 0.05]' , legato = '0.1~0.5' ) . out ( i ) # -> hhh ramp S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) S ( 'laz:r*20' , speed = \"1, 2,4\" , hcutoff = 6000 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.25 ) S ( 'juppad:3, juppad:4' , begin = 0.1 , orbit = 2 , cut = 0 , legato = 1.1 , speed = '1, 2' , crush = 4 ) . out ( i , 8 , 0.25 ) # -> ici il y a de la r\u00e9duction a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'f' , shape = 0.7 ) . out ( i , 4 ) # -> monter shape pour les harmoniques S ( 'hhh:3' , amp = '[0:0.4, 0.05]' , legato = '0.1~0.5' ) . out ( i ) # -> hhh ramp S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) S ( 'laz:r*20' , speed = \"1, 2,4\" , hcutoff = 6000 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.25 ) S ( 'juppad:3, juppad:4' , begin = 0.1 , orbit = 2 , cut = 0 , pan = 'r' , legato = 1.1 , speed = '1|2|4' , leslie = 1 , lesliespeed = 8 , crush = 12 ) . out ( i , 8 , 0.25 ) # -> ici il y a de la r\u00e9duction a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( '., f' , shape = 0.7 ) . out ( i , 4 ) # -> monter shape pour les harmoniques S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) # S('juppad:3, juppad:4', orbit=2, cut=0, legato=1.1).out(i, 8, 0.25) S ( 'laz:r*20' , speed = \"1, 2,4\" , hcutoff = 3000 , legato = 1 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.25 ) S ( 'juppad:3, juppad:4' , speed = 0.75 , squiz = 2 , orbit = 2 , cut = 0 , legato = 1.1 ) . out ( i , 8 , 0.25 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'f' , shape = 0.7 ) . out ( i , 4 ) S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) S ( 'conga:r*20' , speed = \"[1,2,4]/4\" , hcutoff = 2000 , shape = 0.7 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.25 ) S ( 'juppad:3, juppad:4' , speed = 0.75 , squiz = 2 , orbit = 2 , cut = 0 , legato = 1.1 ) . out ( i , 8 , 0.25 ) S ( 'kit2:3' , shape = 0.5 ) . out ( i , 8 ) S ( '., kit2:10, ., kit2:9!2' , shape = 0.5 ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'f' , shape = 0.7 ) . out ( i , 4 ) S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) S ( 'conga:r*20' , speed = \"[1,2,4]/4\" , hcutoff = 2000 , shape = 0.7 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.25 ) S ( 'conga:r*20' , speed = \"[1,2,2]/2\" , hcutoff = 1000 , shape = 0.7 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.5 ) # S('juppad:3, juppad:4', # commenter ce bloc # speed=0.75, squiz=2, # orbit=2, cut=0, # legato=1.1).out(i, 8, 0.25) S ( 'kit2:3' , shape = 0.5 ) . out ( i , 8 ) S ( '., kit2:10, ., kit2:9!2' , shape = 0.5 ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): # S('f', shape=0.7).out(i, 4) S ( '.., p:5, .' , legato = 0.5 , shape = 0.7 ) . out ( i , 1 ) S ( 'conga:r*20' , speed = \"[1,2,4]/4\" , hcutoff = 2000 , shape = 0.7 , room = 0.5 , size = 0.2 , dry = 0.1 , orbit = 3 , amp = 0.4 ) . out ( i , 1 , 0.25 ) # S('euclid(conga:r*20, 12,16)', speed=\"[1,2,4]/2\", hcutoff=1000, shape=0.7, # room=0.5, size=0.2, dry=0.1, orbit=3, amp=0.4).out(i, 1, 0.25) # S('juppad:3, juppad:4', # commenter ce bloc # speed=0.75, squiz=2, # orbit=2, cut=0, # legato=1.1).out(i, 8, 0.25) S ( 'kit2:3' , shape = 0.5 ) . out ( i , 8 ) S ( '., kit2:10, ., kit2:9!2' , shape = 0.5 ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) # Remonter \u00e0 la ligne 167 pour plus de fun ############################################################################# ## ICI RUPTURE VERS L'INCLUSION DES FOUND SOUNDS ############################################################################# @swim def baba ( d = 0.5 , i = 0 ): # S('f', shape=0.7, cutoff=100).out(i, 8) S ( 'hhh:3' , amp = '[0:0.2,0.01]' , legato = '0.1~0.5' ) . out ( i ) # -> hhh ramp S ( '.., p:(5|10), .' , legato = 0.5 ) . out ( i , 1 ) S ( 'm|c:[4:9]' , legato = 0.2 ) . out ( i , P ( '4!12, 3!12' , i )) S ( 'lost:[1:100]' , # -> lost into jupfx cutoff = 9000 , # -> shape = 0.5 , pan = 'sin($/40)' , # -> X legato = 0.3 , # -> begin = 'r' ) . out ( i ) # -> begin r ou {0, 1, 0.1} a ( baba , d = 1 / 8 , i = i + 1 ) # Inclure @swim def baba ( d = 0.5 , i = 0 ): S ( 'a' , shape = 0.7 ) . out ( i , 4 ) # -> monter shape pour les harmoniques S ( 'c' , shape = 0.7 ) . out ( i , 3 ) # -> monter shape pour les harmoniques S ( 'd:7' , orbit = 3 , room = 0.2 , size = 0.8 , dry = 0.2 ) . out ( i , 8 ) S ( 'hhh:3' , amp = '{0, 0.2, 0.01}' , legato = '0.1~0.5' ) . out ( i ) # -> hhh ramp S ( '.., p:5, .' , legato = 0.5 ) . out ( i , 1 ) # -> refaire entrer \u00e7a S ( 'm|c:[4:9]' , legato = 0.2 ) . out ( i , P ( '4!12, 3!12' , i )) S ( 'lost:[1:100]' , # -> lost into jupfx cutoff = 9000 , # -> shape = 0.5 , pan = 'sin($/40)' , # -> X legato = 0.9 , # -> begin = 'r' ) . out ( i ) # -> begin r ou {0, 1, 0.1} a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): # potentiom\u00e8tre du r\u00e9el S ( 'a' , shape = 0.7 ) . out ( i , P ( '4!12, 5!12' , i )) # -> monter shape pour les harmoniques S ( 'c' , shape = 0.7 ) . out ( i , 3 ) # -> monter shape pour les harmoniques # S('c', shape=0.7).out(i, P('3!12, 2!12, 5!12',i)) # -> monter shape pour les harmoniques # S('hhh', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp S ( 'd:4, d:5, .' , legato = 0.5 ) . out ( i , 3 ) S ( 'm|g:[4:9]' , legato = 0.2 ) . out ( i , P ( '4!12, 1!24' , i )) S ( 'long|(lost:r*8)' , # -> lost into jupfx midinote = 'C' , cutoff = 4000 , # -> pan = '[0:0.5, 0.1], [0.5:1, 0.1]' , # -> X legato = '0.1|0.2|0.7|0.1' , cut = 1 , orbit = 2 , room = 0.5 , size = 0.2 , dry = 0.1 , begin = '[0:1,0.01], [1:0,0.01]' ) . out ( i ) # -> begin r ou {0, 1, 0.1} a ( baba , d = 1 / 8 , i = i + 1 ) # Ici on peut explorer des choses plus ambient et se perdre un peu @swim def baba ( d = 0.5 , i = 0 ): # potentiom\u00e8tre du r\u00e9el S ( 'a' , cutoff = 200 , shape = 0.7 ) . out ( i , P ( '4!12, 5!12' , i )) # S('c', cutoff=100, shape=0.7).out(i, 3) # S('c', shape=0.7).out(i, P('3!12, 2!12, 5!12',i)) # S('hhh', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp # S('d:4, d:5, .', legato=0.5).out(i, 3) S ( 'm|g:[4:9]' , legato = 0.2 ) . out ( i , P ( '4!12, 1!24' , i )) S ( 'long|(lost:r*8)' , # -> lost into jupfx midinote = 'C' , cutoff = 4000 , # -> pan = '[0:0.5, 0.1], [0.5:1, 0.1]' , # -> X legato = '[0.1|0.2|0.7|0.1]+0.6' , # -> facteur de fun cut = '1|0, 1|0, 1!4' , orbit = 2 , room = 0.5 , size = 0.2 , dry = 0.1 , begin = '[0:1,0.01], [1:0,0.01]' ) . out ( i ) # -> begin r ou {0, 1, 0.1} a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): # S('f', shape=0.5).out(i, 4) # S('hhh', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp # S('d:4, d:5, .', legato=0.5).out(i, 3) # S('d:{4,9}', legato=0.5).out(i, 4) # S('z', shape=0.8).out(i, 4) S ( 'hhh:12' , hcutoff = 500 , speed = '[1:10]' , shape = 0.8 ) . out ( i , 1 ) # S('kit5:[6!4,7!2,5!5,4]', shape=0.8).out(i, 3) # S('q:r*8', shape=0.4).out(i, P('1!12, 2!8', i)) S ( 'long:1' , # -> lost into jupfx midinote = 'C' , cutoff = 4000 , # -> pan = '[0:0.5, 0.1], [0.5:1, 0.1]' , # -> X legato = '0.1|0.2|0.3|0.1' , begin = '[0:1,0.01], [1:0,0.01]' ) . out ( i ) # -> begin r ou {0, 1, 0.1} a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): # S('f', shape=0.5).out(i, 4) # S('hhh', amp='{0, 0.2, 0.01}', legato='0.1~0.5').out(i) # -> hhh ramp # S('d:4, d:5, .', legato=0.5).out(i, 3) # S('d:{4,9}', legato=0.5).out(i, 4) # S('z', shape=0.8).out(i, 4) S ( 'hhh:12' , hcutoff = 500 , speed = '[1:10]' , shape = 0.8 ) . out ( i , 1 ) # S('kit5:[6!4,7!2,5!5,4]', shape=0.8).out(i, 3) # S('q:r*8', shape=0.4).out(i, P('1!12, 2!8', i)) S ( 'long:1' , # -> lost into jupfx midinote = 'C' , cutoff = 4000 , # -> pan = '[0:0.5, 0.1], [0.5: 1, 0.1]' , # -> X legato = '0.1|0.2|0.3|0.1' , begin = '[0:1,0.01], [1:0,0.01]' ) . out ( i ) # -> begin r ou {0, 1, 0.1} a ( baba , d = 1 / 8 , i = i + 1 ) panic () S ( 'lost' ) . out () S ( 'lost:2' ) . out () # F\u00eater Halloween S ( 'lost:7' , legato = 7 , speed = 0.5 , release = 7 ) . out () S ( 'lost:0' , legato = 7 , speed = 0.5 , release = 7 ) . out () S ( 'lost:3' , legato = 7 , speed = 0.5 , release = 7 ) . out () panic () # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588 \u2588 # \u2588 \u2588\u2003\u2588\u2003 \u2003\u2584\u2584\u2003 \u2003\u2588\u2591\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2584\u2580\u2588 \u2588 # \u2588 \u2588\u2003\u2588\u2003 \u2003\u2591\u2591\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2580\u2584\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2588\u2580\u2588 \u2588 # \u2588 \u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 @swim def baba ( d = 0.5 , i = 0 ): # S('bip:r*20', shape=0.4, midinote='quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)').out(i, 1, 0.25) # S('bip:r*20+20', shape=0.4, midinote='quant([0+12|24,3,6,10]+62, C@minor), quant([0,3,10]+62|74, F@minor)').out(i, 3, 0.25) S ( 'boop:r*40' ) . out () a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'bip:r*20' , orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , shape = 0.4 , midinote = 'quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)' ) . out ( i , 1 , 0.25 ) S ( 'bip:r*20+20' , orbit = 2 , room = 0.5 , size = 'r' , dry = '0.1' , shape = 0.4 , midinote = 'quant([0+12|24,3,6,10]+62, C@minor), quant([0,3,10]+62|74, F@minor)' ) . out ( i , 3 , 0.25 ) S ( 'boop:r*40' ) . out () a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'bip:r*20' , orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 1 , shape = 0.4 , midinote = 'quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)' ) . out ( i , 1 , 0.25 ) S ( 'bip:r*20, boop:r*200' , orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 1 , shape = 0.4 , midinote = 'quant([0+12|24,1~20,6,0~20]+80, C@minor), quant([0~20,3,10]+50, F@minor)' ) . out ( i , 3 , 1 ) S ( '(ff):r*20' , # ulh electrowave ff orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 0.2 , hcutoff = 500 , shape = 0.4 , midinote = 'quant([0+12|24,1~20,6,0~20]+50, C@minor), quant([0~20,3,10]+50, F@minor)' ) . out ( i , 2 , 1 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'ff' , shape = 0.5 ) . out ( i , 4 ) S ( 'll' , shape = 0.5 ) . out ( i , 4 ) S ( 'gameboysnare' , cutoff = 800 ) . out ( i , 8 ) S ( '., hhh:r*40' , hcutoff = 9000 ) . out ( i , 1 ) S ( '., hhh:r*40' , hcutoff = 9000 , speed = '1~50' ) . out ( i , 1 ) S ( 'bip:r*20' , orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 1 , shape = 0.4 , midinote = 'quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)' ) . out ( i , 1 , 0.25 ) S ( 'bip:r*20, boop:r*200' , orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 1 , shape = 0.4 , midinote = 'quant([0+12|24,1~20,6,0~20]+80, C@minor), quant([0~20,3,10]+50, F@minor)' ) . out ( i , 3 , 1 ) S ( '(ulh):r*20' , # ulh electrowave ff orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 0.2 , hcutoff = 500 , shape = 0.4 , midinote = 'quant([0+12|24,1~20,6,0~20]+50, C@minor), quant([0~20,3,10]+50, F@minor)' ) . out ( i , 2 , 1 ) a ( baba , d = 1 / 8 , i = i + 1 ) # <-> des allers retours @swim def baba ( d = 0.5 , i = 0 ): # S('ff, gg:r*29', shape=0.8, leslie=1, leslierate=5, lesliespeed=2).out(i, 2) # S('ll', shape=0.8).out(i, 4) S ( 'gameboysnare' , cutoff = 800 ) . out ( i , 8 ) # S('., hhh:r*40', hcutoff=9000).out(i, 1) S ( '., hhh:r*40' , hcutoff = 9000 , speed = '1~50' ) . out ( i , 1 ) # S('bip:r*20', lesliespeed='2*8', leslierate='r*5', leslie=1, # orbit=2, room=0.7, size='r', dry='0.1', legato=1, # shape=0.4, midinote='quant([0+12|24,3,6,10]+50, C@minor), quant([0,3,10]+50, F@minor)').out(i, 1, 0.25) S ( 'bip:r*20, boop:r*200' , lesliespeed = '2*8' , leslierate = 'r*5' , leslie = 1 , orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 1 , shape = 0.4 , midinote = 'quant([0+12|24,1~20,6,0~20]+80, C@minor), quant([0~20,3,10]+50, F@minor)' ) . out ( i , 3 , 1 ) S ( '(ulh):r*20' , # ulh electrowave ff orbit = 2 , room = 0.7 , size = 'r' , dry = '0.1' , legato = 0.2 , hcutoff = 500 , shape = 0.4 , midinote = 'quant([0+12|24,1~20,6,0~20]+50, C@minor), quant([0~20,3,10]+50, F@minor)' ) . out ( i , 2 , 1 ) a ( baba , d = 1 / 8 , i = i + 1 ) # --|--> transition du coq \u00e0 l'\u00e2ne @swim def baba ( d = 0.5 , i = 0 ): S ( 'm, ..., m, ...' , shape = 0.5 ) . out ( i , 2 ) S ( 'rev([s,a,l,u,t, z,o,r,b,a]:r*8)' , legato = 0.1 , pan = 'tan(r/100)' , accelerate = 0.2 , room = 0.1 , dry = 0.1 , size = 0.1 , ) . out ( i , 2 ) S ( 'perca:[1:20], ..' , speed = 2 if rarely () else 'r*4' , ) . out ( i , 2 ) a ( baba , d = 1 / 16 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'm, ..., m, ...' , shape = 0.5 ) . out ( i , 2 ) S ( 'long:13' , shape = 0.5 , begin = '0.5, 0.5, 0.42, 0.5!2, 0.6' , orbit = 3 , cut = 1 , legato = 2 ) . out ( i , 8 , 0.25 ) S ( 'perca:[1:20], ..' , speed = 2 ) . out ( i , 2 ) a ( baba , d = 1 / 16 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'f, ..., f, ...' ) . out ( i , 2 ) S ( 'gg, ...' , shape = 0.5 , orbit = 4 , room = 0.2 , size = 0.2 , dry = 0.2 ) . out ( i , 2 ) S ( 'perca:[1: 20], ..' , speed = '1+r*4' , cutoff = '200+r*8000' ) . out ( i , 2 ) S ( 'perca:[20: 1], .' , speed = '0.1+sin($)' , cutoff = '200+r*8000' ) . out ( i , 3 ) S ( 'long:13' , shape = 0.7 , begin = '0.1, 0.2, 0.3, 0.5' , orbit = 3 , cut = 1 ) . out ( i , 8 , 0.25 ) # 0.5 0.6 a ( baba , d = 1 / 16 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'm, ..., m, ...' , shape = 0.5 ) . out ( i , 2 ) S ( 'hhh:r*49' , amp = 0.3 , hcutoff = 'sin(i.i/40)*7000' ) . out ( i , 2 ) S ( 'long:13' , shape = 0.5 , begin = '0.6, 0.5, 0.42, 0.6, 0.7' , orbit = 3 , cut = 1 , legato = 2 ) . out ( i , 8 , 0.25 ) S ( 'q:[1:20], ..' , speed = 2 ) . out ( i , 2 ) a ( baba , d = 1 / 16 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'm, ..., m, ...' , shape = 0.5 ) . out ( i , 2 ) S ( 'hhh:r*49' , amp = 0.3 , hcutoff = 'sin(i.i/40)*7000' ) . out ( i , 2 ) S ( 'long:13' , shape = 0.5 , begin = '0.5, 0.5, 0.42, 0.5!2, 0.6' , orbit = 3 , cut = 1 , legato = 2 ) . out ( i , 8 , 0.25 ) S ( 'q:[1:20], ..' , speed = 2 ) . out ( i , 2 ) a ( baba , d = 1 / 16 , i = i + 1 ) # une petite transition jsp @swim def baba ( d = 0.5 , i = 0 ): # S('m, ..., m, ...', shape=0.5).out(i, 2) # S('hhh:r*49', amp=0.3, hcutoff='sin(i.i/40)*7000').out(i, 2) S ( 'jupfx:r*20' , shape = 0.5 , hcutoff = '200 + r*8000' , begin = '0.5, 0.5, 0.42, 0.5!2, 0.6' , orbit = 3 , cut = 1 , legato = 2 ) . out ( i , 8 , 0.25 ) S ( 'q:[1:20], ..' , speed = 2 ) . out ( i , 2 ) a ( baba , d = 1 / 16 , i = i + 1 ) # D\u00e9brouille toi # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588 \u2588 # \u2588 \u2588\u2003\u2588\u2003\u2588\u2003 \u2003\u2584\u2584\u2003 \u2003\u2580\u2588\u2580\u2003\u2584\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2580\u2588\u2580\u2003\u2588\u2580\u2580\u2003 \u2003\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2580\u2588\u2580\u2003\u2588\u2580\u2588\u2003 \u2003\u2580\u2588\u2580\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588 \u2588 # \u2588 \u2588\u2003\u2588\u2003\u2588\u2003 \u2003\u2591\u2591\u2003 \u2003\u2591\u2588\u2591\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2584\u2003\u2591\u2588\u2591\u2003\u2588\u2588\u2584\u2003 \u2003\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2591\u2588\u2591\u2003\u2588\u2584\u2588\u2003 \u2003\u2591\u2588\u2591\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2584 \u2588 # \u2588 \u2588 # \u2588 \u2588\u2580\u2003\u2584\u2580\u2588\u2003\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2580\u2588\u2580\u2003\u2584\u2584\u2003\u2588\u2580\u2580\u2003\u2580\u2588\u2580\u2003\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2584\u2591\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2588\u2580\u2580 \u2588 # \u2588 \u2584\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2591\u2588\u2591\u2003\u2591\u2591\u2003\u2588\u2588\u2584\u2003\u2591\u2588\u2591\u2003\u2588\u2003\u2588\u2588\u2584\u2003\u2588\u2591\u2580\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2588\u2588\u2584 \u2588 # \u2588 \u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 , * ,,,,,,,,,,,, . ,,,, ..***** ,, . .. , * , . . .. ........ ,,, . ,,,,,,,,,, . ,, .* * ( **/** , /* ( ** , **///** ,, *////* ,, .. ,, //.. .. , . .... ,,,,,,,, ********** ( // ((( */***/*** , /******/ , . . .... ,,,, .. ,, **. ... .. , ..... ,, . ,,,,, ********* ((( //* * (( *//** ,, / ,,,,, * , . .. .... ,,, .../ #%%%%#(,.. .,,,....,...,,,,.,,,,**,,****(/ *****/ ,, * , ** , ** ,,, ... , . , . , */ #%%%%%%%%%%%%%%%#(. .,,..,,...,...,..,..,,,,****/*** *// , **//*****/** , .....% #%&&%%&&&&%&%%%%%%%%%%%%##%#...... ,,..,..*.,,,,/**/*,,** *//* ,, * ,, ****** ,, / ,, . #%&&&&&&&&&&&&&%#%&%%&%%%%###%( .. ..,,..,,,..,,..,.****,** *//* ,,,, **** ,,,,,,,, #%&&&&&&&%&%&%%%%&&&%&&&%%%%%###(#* ....,,,,.,........,,**, *//***** , ***...... #%&%&&&%&%%&%%%%#%%%&&&&&%%%%%%%%%%%#**,*,....,,.,*.......,,, */******* ,,, ...... #%%&%&%&&&%%%&&%%%%%#%%%%%%%%%###%%#%%(,,,,*, .... ,..,,,,./ */***** ,, * , ..... ,( &&&%&&&% ( *** ( &** , **** ,, * (( ##%/#/#%%%#%%(////**,,......,,,,,.*, */* ,,,,,, . , * , .. #%%&&&&%#/***************,**,... .*#%%%%%#//*.,..........,*/*,., */**** ,,, ... , . , . #%&&&&%(/********,,,****,***,... ,/%%#(*.............,.,,,..,* */** ,,,,,,,, .... , %%%&&&/**/////*** , **/*** ,, * , * , ... ./ ( #,...,..,.,,..,,,,...,,,* */**** , ** , ** , * , ..*%&&&/** #(///(//((/*/*,**/////***,..#%(, .....,.....,,. ....,*, *//********** ,,,, //%%%**// ( % #&%#////(,,#/*(*###*/*.../#(/,.,.,,.. ... . .,,.., *//*///** ,,,, *** ,, //%%***/ (((((( // ((,,,,(( / ((( //.*... , #/,...,,.,...,.. .,......, */// ( **//*****/*** ,( % #****///**/****,,,,.,**,,,,,.,,,(#*..,,...,.. ............, *//*/* ,, ** ,,,, **/*** #%(**********/****,....,,,,,.....#(*,,......,. .,,.,**,,,.. *//*/* , */** , * ,,,,,, . , ##//**********,**,,..,,,,.... ,((******//(*.....*,,.,....* *//*///**// ,, .** , .. ,,, % #***********((/./(,*,,,,. ..,*((,,,....,,..,.,,,*,.,...,* / #/((***/,***,,,.,,,**(((***,*,****((#/*/,,,... .,(#,,....... ..,,,***,,,.,.* * (( / ( /***.* ,,, .. , . , * , // ( #(//****//(((((/(///.*...,.//(/***,.,*.. ....,***,...,* * (( //* ,,,,, ....... ,, .. , * ( ##(//***//((//(*(*,*,...,*/*,... .. . ......,..,.,, / (((( / ,,,, ........... ,, **/ ( #((/**/***/*,,,***,.,.////*******,,.,,. .... ...,., * ((( /* ,,,,,,, ./ , .......* ,, / ###(/********,,.,*(*,.,,.....,,,.. .. ......,.. * (( //** ,, . ,, **** , . ,,, ...*% ( .. ( ###%#((((((//(#(/. ,.*,,,,..,.. ..... ......,. * (( ///* , . , * , ****... , */.&&&% , . ,, * ( ##%%%%%%%##(/. .%#((,.,.., ...........,,,,,,. / ( / ( ** ,,, .. ,,,,, **/**/&&@&&&/* , /. , * (((((((( . ... ,( % #%%%%%,,,,....... ...,.,,,, * ( //** , *** , ** , ***** ( %&&&@&&@&%* , . ,, *// ((( / , .. , /%%%%%%%%%% ##*,*,...............,. * ( //*** ,, */ , * ,,( &&&&@&@@@&&&& (,,,,,,, * ( #,,,,,,*#%%%%%%%%%%%%%#**.........,/***** * ( ///**** ,,( &&&&@@@@@@&&@&&&& ##%&&&&&&&&&&&&%##%%&&&%%&%%%%%%%#(%(/*....***,*,,, * (((((( &@&&&&@@@@&&@&@&&&&&%%&&&&&@&&&&&@@@&&%%%%%%%%%%%%% #%%#%%*,,...,,,*,,***, /%&%&@&%&@@@@@&&&&&%%&&@&&&@&&@@&&& #,,,,,##&%(%%&%%%%#%%##%/. /#/...,,..,,,,... /&&&%&&&&&%&&@&&&&&&&&&&&&&&% #%&&&&%(.,,,,,,/&&&&%%%%%##**,. ,,/,.,.,.*,*,(#&(.. /&&% #%%%###%&@&&&&&%%%%%%%&&&&&%&%&%*,.,,...%%%&%%%(%#*,,.,,./,,.,,,./(#(*#(%(#( /&&@&@&%&@@@&@&&&% ( #%%%#%&&&&&&&%%&&%#.... %%%%&&%#(*,,...(/,,,*,(%%###(####/*%( /&@@@&@&& #%##&%(/*/(#%%%#%&@&&%#%%&&%&%,./&&&%%%#***....**,*/*%%%%&%(#%#####(/(* / #%&@%%##&&&%(/((,,(%&%#%%%&&%%#%#%%&%&%&&&&%%(*.....(.*.,/#%%%&%%%%###%#%%###(. / ######/(%%&%(%%#(((/#%&@&&&&&%&&%%&&%&&&&&%/,,.. ,.,.,(#%&%&%%%&%%%#%%%(((//%%( /%%% #(#%%%%%%%%#######(((%&&@&&%%%%%&&%%%(,,,,..,,,(%%&&%#%%%####((%#%(/(#%#(#** /%%%%%%%&&&%&&%%%% #(((((((#*%&@&%%&&%%%/,*,,.*,//&%%&%%%%&&%####(/*#%(/(#%%#**,* /&&%&%%%%%%% ##%%###(#((#*#%((//(////***/*.**##%%%#%##%&%#(##%%%%#*/#//*/#(/#(*** # C'EST PIERRE BONNARD, IL FAUT ALLER LE VOIR. @swim def baba ( d = 0.5 , i = 0 ): M ( velocity = '90~110' , note = 'inrot(C@maj7, F@maj7)-12' ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): M ( velocity = '90~110' , dur = 1 , note = 'inrot(C@maj7, F@maj7)-12' ) . out ( i , 2 ) M ( velocity = '90~110|70' , dur = '15~20' , note = \"F', ..., G'', ..., [D, E, F, A]+12\" ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): M ( velocity = '90~110' , dur = 1 , note = 'inrot(C@maj7, F@maj7)-12' ) . out ( i , 2 ) M ( velocity = '90~110|90' , dur = '15~20' , note = \"F., ..., F.., ...\" ) . out ( i , 2 ) M ( velocity = '90~110|90' , dur = '15~20' , note = \"F., A, .., F.., ...\" ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) # <-> alterner @swim def baba ( d = 0.5 , i = 0 ): M ( dur = '2~5' , note = 'inrot(C@maj7, F@maj7)-12' ) . out ( i , 2 ) M ( dur = '2~5' , note = 'disco(inrot(C@maj7, F@maj7))' ) . out ( i , 5 ) M ( dur = '2~12' , note = 'adisco(inrot(inrot(C@maj7, F@maj7), G@fifths))' ) . out ( i , 4 ) a ( baba , d = 1 / 8 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): M ( note = 'inrot(C@maj7, F@maj7)-12' ) . out ( i , 2 ) if rarely (): M ( note = 'disco(inrot(C@maj7, F@maj7))' ) . out ( i , 5 ) if sometimes (): M ( note = 'adisco(inrot(inrot(C@maj7, F@maj7), G@fifths))' ) . out ( i , 4 ) a ( baba , d = 1 / 8 , i = i + 1 ) c . _midi_nudge = 0.30 @swim def baba ( d = 0.5 , i = 0 ): S ( 'ff' ) . out ( i , 4 ) M ( velocity = '90~110' , dur = 1 , note = 'inrot(C@maj7, F@maj7)-12' ) . out ( i , 2 ) M ( velocity = '90~110|90' , dur = '15~20' , note = \"F., ..., F.., ...\" ) . out ( i , 2 ) M ( velocity = '90~110|90' , dur = '15~20' , note = \"F., A, .., F.., ...\" ) . out ( i , 2 ) a ( baba , d = 1 / 8 , i = i + 1 ) # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 # \u2588 \u2588 # \u2588 \u2588\u2003\u2588\u2591\u2588\u2003 \u2003\u2584\u2584\u2003 \u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2588\u2580\u2588\u2003 \u2003\u2584\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2588\u2003 \u2588 # \u2588 \u2588\u2003\u2580\u2584\u2580\u2003 \u2003\u2591\u2591\u2003 \u2003\u2588\u2584\u2584\u2003\u2588\u2588\u2584\u2003 \u2003\u2588\u2580\u2580\u2003\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2588\u2584\u2588\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2584\u2588\u2003 \u2588 # \u2588 \u2588 # \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 panic () @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit3:[1,2,1,2,4,5,4,6]' , legato = 1 ) . out ( i , 8 ) S ( 'long:42' , begin = 'r' , cut = 1 ) . out ( i , 8 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) if sometimes (): S ( 'z:6' if random () > 0.5 else 'z:7' , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit3:[1,2~10,1,2,4~10,5,4,6]' , legato = 1 ) . out ( i , 8 ) S ( 'long:42' , begin = 'r' , cut = 1 ) . out ( i , 8 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): # Ce truc est quand m\u00eame giga fade :'((((((((((((( S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) if sometimes (): S ( 'z:6' if random () > 0.5 else 'z:7' , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) # Du du du du dudududududu dudu du du dud udu dudu a ( baba , d = 1 / 32 , i = i + 1 ) # R\u00e9ponse : @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit3:[0, 1,2,1,2,4,5,4,6,7,8, 1, 0]' , legato = 1 ) . out ( i , 8 ) S ( 'long:42' , begin = 'r' , cut = 1 ) . out ( i , 8 ) S ( 'long:42~46' , begin = 'r' , cut = 1 , speed = 0.5 ) . out ( i , 8 ) S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) if sometimes (): S ( 'z:6' if random () > 0.1 else 'z:7' , pan = 'r' , legato = 1 , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) if sometimes (): S ( 'dd:6|7|8' if random () > 0.5 else 'j:0~7' , pan = 'r' , legato = 1 , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) S ( 'long:20~33' , begin = 'r' , cut = 1 ) . out ( i , 8 ) S ( 'long:42~46' , begin = 'r' , cut = 1 , speed = 0.5 ) . out ( i , 8 ) S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) if sometimes (): S ( 'z:6' if random () > 0.1 else 'z:8~400' , pan = 'r' , legato = 1 , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) if sometimes (): S ( 'dd:6|7|8' if random () > 0.5 else 'z:7~200' , pan = 'r' , legato = 1 , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) # S('long:42', begin='{0,2,0.4}', cut=1).out(i, 16) S ( 'long:42' , begin = '[0:1, 0.08]' , cut = 1 ) . out ( i , 16 ) # -> \u00e9plucher comme un oignon (solo de fichier .wav) # S('long:42~46', begin='r', cut=1, speed=0.5).out(i, 8) # S('jupbass:28|44, jupbass:28', octave=4, # legato=1, cut=1, orbit=3).out(i, 24, 1) if sometimes (): S ( 'z:6' if random () > 0.1 else 'z:8~400' , pan = 'r' , legato = 1 , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) if sometimes (): S ( 'dd:6|7|8' if random () > 0.5 else 'z:7~200' , pan = 'r' , legato = 1 , shape = 0.9 , hcutoff = 7000 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) S ( 'long:10~33' , begin = 'r' , cut = 1 , speed = \"1~8\" ) . out ( i , 8 ) S ( 'long:20~46' , begin = 'r' , cut = 1 , speed = \"1~8\" ) . out ( i , 8 ) a ( baba , d = 1 / 32 , i = i + 1 ) # R\u00e9ponse : @swim def baba ( d = 0.5 , i = 0 ): S ( 'kit2:[0, 1,2, 0, 1,2,4,5,4,0,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) S ( 'kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) S ( 'long:103' , begin = '0.1, 0.5' , cut = 1 , speed = \"1~8\" ) . out ( i , 16 ) S ( 'long:20' , begin = '0.1, 0.5' , cut = 1 , speed = \"1~8\" ) . out ( i , 8 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'cc' ) . out ( i , 12 ) S ( 'kit2:[0, 1,2, 0, 1,2,4,5,4,0,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) S ( 'kit3:[1,2,1,2,4,5,4,6,1,2,3,1,2,3,2,3,4,5~8!5]' , legato = 1 ) . out ( i , 8 ) S ( 'long:103' , begin = '0.1, 0.5' , cut = 1 , speed = \"1~8\" ) . out ( i , 16 ) S ( 'long:20' , begin = '0.1, 0.5' , cut = 1 , speed = \"1~8\" ) . out ( i , 8 ) a ( baba , d = 1 / 32 , i = i + 1 ) @swim def baba ( d = 0.5 , i = 0 ): S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) S ( 'kit4:r*20' , legato = 0.4 , begin = 0.01 ) . out ( i , 12 ) S ( 'kit3:[1,2,1,2,4,5,4,6]' ) . out ( i , 8 ) S ( 'long:40' , begin = '0.60!4, 0.555!2, 0.27!4, 0.25!2' , orbit = 2 , cut = 1 ) . out ( i , 32 ) S ( 'long:40' , speed = 1.01 , begin = '0.60!4, 0.555!2, 0.27!4, 0.25!2' , orbit = 2 , cut = 1 ) . out ( i , 32 ) if sometimes (): S ( 'z:6' , shape = 0.9 , hcutoff = 5000 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) panic () @swim def baba ( d = 0.5 , i = 0 ): S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) S ( 'kit4:r*20' , legato = 0.4 , begin = 0.01 ) . out ( i , 12 ) S ( 'kit3:[1,2,1,2,4,5,4,6]' ) . out ( i , 8 ) S ( 'long:26' , amp = 0.5 , begin = '0.60!4, 0.555!2, 0.27!4, 0.25!2' , orbit = 2 , cut = 1 ) . out ( i , 32 ) S ( 'long:26' , speed = 1.01 , begin = '0.60!4, 0.555!2, 0.27!4, 0.25!2' , orbit = 2 , cut = 1 ) . out ( i , 32 ) if sometimes (): S ( 'z:6' , shape = 0.9 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) # Variation 3 @swim def baba ( d = 0.5 , i = 0 ): S ( 'jupbass:28|44, jupbass:28' , octave = 4 , legato = 1 , cut = 1 , orbit = 3 ) . out ( i , 24 , 1 ) S ( 'kit4:r*20' , legato = 0.4 , begin = 0.01 ) . out ( i , 12 ) S ( 'kit3:[1,2,1,2,4,5,4,6]' ) . out ( i , 8 ) S ( 'long:40' , begin = '0.60!4, 0.555!2, 0.27!4, 0.25!2' , orbit = 2 , cut = 1 ) . out ( i , 32 ) S ( 'long:40' , speed = 1.01 , begin = '0.60!4, 0.555!2, 0.27!4, 0.25!2' , orbit = 2 , cut = 1 ) . out ( i , 32 ) if sometimes (): S ( 'z:6' , shape = 0.9 ) . out ( i , 4 ) a ( baba , d = 1 / 32 , i = i + 1 ) panic ()","title":"Source code"},{"location":"documentation/sardinopedia/basic_swimming_lessons/","text":"Sardine users refer to the functions they use as swimming functions . This section will help you to grow more confident using them! Swimming functions must dance before your eyes like sardines in the ocean. You must fell comfortable writing them and manipulating them. These functions are the foundation of Sardine and nothing really makes sense without them. Joking aside, and for those of you who already know how to program, swimming functions are temporally recursive functions. These functions run and schedule themselves later in time instead of returning. This is a very primitive but very powerful mechanism that has been harnassed by live-coders in multiple programming environments since the inception of that type of computer music performance. I - Swimming Functions Out-of-time S ( 'bd' ) . out () This command will play a single bassdrum with the SuperDirt sound engine. We are not currently using a swimming function , this event is atomic and non-repeating. It is a one-shot event, a single instruction sent to the Python interpreter. We haven't learned anything yet, you don't know anything about Senders , swimming functions , etc... Just note that these one-letter objects are constantly and repeatedly used to trigger different types of messages. We will need to pattern them and to arrange or compose them in time. You can use Sender objects outside of a recursive function. It will work, but you will be un-timed , or out-of-time , just like your regular Python script that doesn't really care about time or about when or how things happen. By using Python with Sardine , you will constantly run into things that either are timed or un-timed . It can help if you like manipulating only certain parts of your interactive programs with time constraints or if you like to store options and configuration in a part of your script, apart from your musical patterns. Swimming @swim # or @die def basic (): print ( 'I am swimming now!' ) again ( basic ) hush ( basic ) # or panic() This is the most basic and iconic swimming function you can write. We could make a sweatshirt out of it. It is just like your regular Python function to the exception of two little details : the @swim or @die decorators. the again , anew , a final recursive call. Behind the stage, the @swim decorator will provide all the necessary plumbing to properly handle time and repetition. The again(...) function is actually the same thing as @swim . It is how the recursion happens, where the function enters the infinite time loop defined by the clock. Updating the function with the @die decorator will stop the recursivity, ending the production of sound. Using hush(function_name) or just hush() will halt the function execution. There is also panic() which is a bit more extreme but needed in some cases where sound doesn't stop after running hush() . hush() will just stop the function / all functions while panic() will do the same but also violently stop every sound sample / synthesizer currently being used. This is useful if you feel that you are loosing control when playing with loud or very long samples. Swimming with style @swim def basic ( d = 0.5 , i = 0 ): print ( 'I am swimming now!' ) again ( basic , d = 0.5 , i = i + 1 ) hush ( basic ) This is a swimming function with some minor improvements. The function is passed a duration ( d ) and an iterator ( i ) as arguments. This is the function you will want/need to save as a snippet somewhere in your text editor. Sardine users write this skeleton constantly, mechanically, without even thinking about it. The d parameter is the function's duration , the 0.5 value representing half of a beat. The i parameter is an hand-crafted iterator , progressively incremented by recursion. Don't be scared by all this jargon. It just means that the value increases by one each time the function is repeated. Drowning in numbers @swim def basic ( d = 0.5 , i = 0 , j = 0 , k = 0 ): print ( f 'I am swimming with { i } , { j } , and { k } !' ) again ( basic , d = 0.5 , i = i + 1 , j = j + 2 , k = P ( 'r*10' , i )) hush ( basic ) A function with three different iterators. Why not? Notice how the iterator values are evolving independently. i is a basic increment, while j walks through even numbers. And k is randomized using the notation P('r*10', i) . To learn more about this, please refer to the section about Patterns and about the pattern Language. You will sometimes encounter features you don't know about yet while scrolling through these examples. Don't worry, they are covered somewhere! Swimming with friends def calling_you (): print ( 'I hear you' ) @swim def basic (): calling_you () again ( basic ) hush ( basic ) A swimming function can call a regular function ( i.e. a function with no Sardine decorator). This example is boring as hell but it demonstrates one thing: Sardine is just regular Python with a twist. Be creative, import your favorite packages and make your computer crash in rhythm! Synchronized Swimming @swim def first (): print ( 'first!' ) again ( second ) def second (): print ( 'second!' ) again ( first ) A swimming function calling another one, which will call back the first one in return. This is a loop of looping functions. You can make use of this to organise longer pieces if you'd like to. Sardines playing Waterpolo @swim def first ( d = 0.5 , rng = 0 ): print ( f \"Received: { rng } \" ) rng = randint ( 1 , 10 ) print ( f \"Sending: { rng } \" ) again ( second , d = 0.5 , rng = rng ) # evaluate me first def second ( d = 0.5 , rng = 0 ): print ( f \"Received: { rng } \" ) rng = randint ( 1 , 10 ) print ( f \"Sending: { rng } \" ) again ( first , d = 0.5 , rng = rng ) Exchanging data between swimming functions just like sardines playing waterpolo. This is just an extension of some on the materials depicted above. There is no limit to the things you can do by recursion. It will only gradually cause more headaches as you go along. II - Surfing: concise syntax There is an alternative jam-oriented way of using swimming functions inspired by FoxDot , another very cool live-coding library for Python created by Ryan Kirkbride . This technique is an emulation or simulation of FoxDot mode of operation. It uses the same syntax and the same philosophy of patterning but it relies on Sardine 's foundations. This mode of swimming is basically assigning Senders to an invisible swimming function that runs automatically behind your back. Warning If you don't know yet what a Sender is, you better go consult the page about it first before reading this section. Surfboards (Players) By default, there are 48 Players ready for surfing. This is more than you will ever need! Nobody can play with that many patterns live. They are named in a consistent way from Pa , to PZ : [Pa, Pb, Pc, Pd, Pe, Pf, ..., PA, PB, PC, ... PZ] . These objects use a central method: >> . Just like anything else with Sardine , you can also fine-tune your patterns with some setters that will alter how the pattern is interpreted by the clock. We will use Pa for demonstration purposes: Pa.rate : time spent on a single event in a linear sequence of events (step speed). Pa.dur : duration of a single event in a linear sequence of events (step duration). While playing/patterning with surfboards , you will only ever need to deal with these three methods. All the rest is integrated with the rest of the Sardine ecosystem: # The sun is high, let's go surfing Pa >> play ( 'bd, ., hh' ) Pa . rate = 1 # Ok, I'm done surfing for today.. Time to eat marshmallows.. hush () In addition to that, take note of the play() method used for assigning a Sender to Players . There is one method per available default Sender . It behaves exactly like your typical senders : play(*args, **kwargs) : the default SuperDirt (or S ) Sender. play_midi(*args, **kwargs) : the default MIDI (or M ) Sender. play_osc(*args, **kwargs) : the default OSC (or O ) Sender. run(func: Callable) : run any function like if it was a surfboard! I repeat, these functions are basically senders with a different name! You will have to learn how to use Senders to be truly efficient with the surfing mode. You can spend your life using Sardine this way or combine it with swimming functions , this is entirely up to you! This mode was initially designed in order to demonstrate the syntax of FoxDot . I find it to be a fun and efficient way to jam along with friends as well :) You can just fire up a Sardine session and write pretty fast. The efficiency of surfing PB >> play ( 'jvbass:r*8, ..., pluck, ...' ) PA >> play ( 'bd, ., hh, sn, hh' , amp = 0.4 , legato = '0.3~1' , speed = '1' ) By using the play() method and combining it with regular patterns, you can more quickly generate efficient drum patterns without having to type too much! Your drum patterns will only take a few lines, and more complex swimming functions can be reserved for more complex tasks. Surfing on MIDI Cables PA >> play_midi ( '<C@maj7>' , dur = '1~8' ) PA . dur = 3 PB >> play_midi ( \"C.., C|C'|C''\" , dur = '1~8' ) PB . rate = 2 The play_midi() function is the good old M() Sender . The note= parameter has been promoted to an arg in this mode in order to save you from having to type 5 more letters :) How to stop surfing Surfing patterns are fully integrated with the rest of Sardine . You can shut them down by calling the hush() or panic() function just like for other swimming functions . You can also use direct the Player value to \"None\" (PB >> None). This will stop the output for that player - which is useful if you have multiple Players. To start again, just load the PB >> play() line again. PA >> play ( 'bd, ., hhh, .' ) PA . rate = 1 PB >> play ( 'cp' ) PB . dur = 0.5 PB >> None # stops only the PB Player hush () # stops all Players III - Fast swimming functions This section requires a good understanding of general Sardine concepts. You need to understand patterns , senders , and a few other concepts. You need to have at least a very vague idea about the temporal system Sardine is using and how patterns are written/interpreted, etc... It will open up a very cool world of polyrythmic patterns, rhythmic divisions, etc... Swimming at clock speed @swim def fast ( d = 0.25 , i = 0 ): S ( 'bd' , speed = '0.5,2' , legato = 0.1 ) . out ( i , div = 4 , rate = 2 ) S ( 'hh, jvbass:0|8|4,' , pan = '[0:1,0.1]' , legato = 0.1 ) . out ( i , div = 8 if rarely () else 5 , rate = 2 ) S ( 'cp' , legato = 0.1 ) . out ( i , div = 8 ) a ( fast , d = 1 / 8 , i = i + 1 ) Sardine swimming functions are usually slow (compared to the clock internal speed). However, you can speed up your recursion, the only hard limit being the speed at which the clock itself operates. It means that the faster you go, the better the rhythmic precision. The faster, the merrier! You will be able to have a finely grained control over time and events, with the ability to write more groovy or swinging code. It will also make your LFOs and signal-like patterns sing more. The recipe for fast swimming is the following: Use a very fast recursion speed ( 1/8 , 1/16 , 1/32 ), usually constant (no patterning). Play a lot with silences and with the arguments of .out(iterator, div, rate) . Fast swimming template @swim def fast ( d = 0.5 , i = 0 ): # print(\"Damn, that's fast!\") a ( fast , d = 1 / 32 , i = i + 1 ) This is the template for a fast swimming function . You can skip the iterator if you don't need it or if you wish to use another iteration tool (such as amphibian variables ). This function is really fast. Uncomment the print statement to notice how fast it is. To learn how to control it efficiently, take a look at the following paragraphs about divisors and the rate factor. Fast swimming parameters @swim def fast ( d = 0.5 , i = 0 ): S ( 'bd' ) . out ( i , div = 8 ) a ( fast , d = 1 / 16 , i = i + 1 ) The .out() method as well as the independant P() object can take up to three arguments: i ( int ): the iterator for patterning. Mandatory for the two other arguments to work properly. This iterator is the index of the values extracted from your linear list-like patterns. How this index will be interpreted will depend on the next two arguments. div ( int ): a timing divisor . It is very much alike a modulo operation. If div=4 , the event will hit once every 4 iterations. The default is div=1 , where every event is a hit! Be careful not to set a div=1 on a very fast swimming function as it could result in catastrophic failure / horrible noises. There is no parachute out in the open sea. rate ( float ): a speed factor for iterating over pattern values. It will slow down or speed up the iteration speed, the speed at which the pattern values are indexed on. For the pattern 1, 2, 3 and a rate of 0.5 , the result will be perceptually similar to 1, 1, 2, 2, 3, 3 . Let's illustrate. In the example below, we are playing with various divisors to generate an interesting rythmic pattern. Combine that with more interesting drumming and boom, you now have the secret recipe for an interesting algorave . @swim def fast ( d = 0.5 , i = 0 ): S ( 'bd' ) . out ( i , div = 8 ) S ( 'hh' ) . out ( i , div = 7 ) S ( 'sd' ) . out ( i , div = 16 ) a ( fast , d = 1 / 16 , i = i + 1 ) Can we do more? Of course we can. So far, we only used one patterning speed because every sender is iterating over all its patterns at the same speed but you could use the P() object for including different iteration speeds inside your main fast swimming rhythm. This is a bit jargon heavy but I hope that you will understand what I mean. If you don't, see for yourself: c . bpm = 125 @swim def there_is_a_light ( d = 0.5 , i = 0 ): S ( 'drum' , legato = 1 , speed = '1' ) . out ( i , 8 ) S ( 'drum:[1,2,3,4]' , legato = 1 , speed = P ( '1,2,3,4,5,1!2,4!4' , i + 1 , 2 , 0.5 )) . out ( i , 4 ) a ( there_is_a_light , d = 1 / 8 , i = i + 1 ) Go slow, read line after line and you will eventually get it! Conclusion about swimming The concept of temporal recursion is deep. There are many clever things you can do with it, and it might take some time to see and master different patterning techniques. Swimming functions are only the beginning to your temporal voyage with Sardine because you will notice that there are multiple ways to speak / think about time even in the context of this very generic framework. Let's go through some examples really quick to whet your appetite. Imperative style Take a swimming function , make it long enough, use our very special sleep() function (which is not the regular Python sleep) and you can write code \u00e0 la Sonic Pi : @swim def sonorous_cake ( d = 0.5 , i = 0 ): S ( 'bd' ) . out () sleep ( 0.5 ) S ( 'hh' ) . out () sleep ( 0.5 ) S ( 'bd' ) . out () sleep ( 0.5 ) S ( 'sn' ) . out () a ( sonorous_cake , d = 2 , i = i + 1 ) Declarative style Make your swimming functions very dense, write using a mostly declarative style. Spice it up with the patterning system if you'd like: @swim def one_line ( d = 0.5 , i = 0 ): S ( 'bd, drum, sn, drum:2' ) . out ( i ) a ( one_line , d = 0.5 , i = i + 1 )","title":"Swimming"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#i-swimming-functions","text":"","title":"I - Swimming Functions"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#out-of-time","text":"S ( 'bd' ) . out () This command will play a single bassdrum with the SuperDirt sound engine. We are not currently using a swimming function , this event is atomic and non-repeating. It is a one-shot event, a single instruction sent to the Python interpreter. We haven't learned anything yet, you don't know anything about Senders , swimming functions , etc... Just note that these one-letter objects are constantly and repeatedly used to trigger different types of messages. We will need to pattern them and to arrange or compose them in time. You can use Sender objects outside of a recursive function. It will work, but you will be un-timed , or out-of-time , just like your regular Python script that doesn't really care about time or about when or how things happen. By using Python with Sardine , you will constantly run into things that either are timed or un-timed . It can help if you like manipulating only certain parts of your interactive programs with time constraints or if you like to store options and configuration in a part of your script, apart from your musical patterns.","title":"Out-of-time"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#swimming","text":"@swim # or @die def basic (): print ( 'I am swimming now!' ) again ( basic ) hush ( basic ) # or panic() This is the most basic and iconic swimming function you can write. We could make a sweatshirt out of it. It is just like your regular Python function to the exception of two little details : the @swim or @die decorators. the again , anew , a final recursive call. Behind the stage, the @swim decorator will provide all the necessary plumbing to properly handle time and repetition. The again(...) function is actually the same thing as @swim . It is how the recursion happens, where the function enters the infinite time loop defined by the clock. Updating the function with the @die decorator will stop the recursivity, ending the production of sound. Using hush(function_name) or just hush() will halt the function execution. There is also panic() which is a bit more extreme but needed in some cases where sound doesn't stop after running hush() . hush() will just stop the function / all functions while panic() will do the same but also violently stop every sound sample / synthesizer currently being used. This is useful if you feel that you are loosing control when playing with loud or very long samples.","title":"Swimming"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#swimming-with-style","text":"@swim def basic ( d = 0.5 , i = 0 ): print ( 'I am swimming now!' ) again ( basic , d = 0.5 , i = i + 1 ) hush ( basic ) This is a swimming function with some minor improvements. The function is passed a duration ( d ) and an iterator ( i ) as arguments. This is the function you will want/need to save as a snippet somewhere in your text editor. Sardine users write this skeleton constantly, mechanically, without even thinking about it. The d parameter is the function's duration , the 0.5 value representing half of a beat. The i parameter is an hand-crafted iterator , progressively incremented by recursion. Don't be scared by all this jargon. It just means that the value increases by one each time the function is repeated.","title":"Swimming with style"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#drowning-in-numbers","text":"@swim def basic ( d = 0.5 , i = 0 , j = 0 , k = 0 ): print ( f 'I am swimming with { i } , { j } , and { k } !' ) again ( basic , d = 0.5 , i = i + 1 , j = j + 2 , k = P ( 'r*10' , i )) hush ( basic ) A function with three different iterators. Why not? Notice how the iterator values are evolving independently. i is a basic increment, while j walks through even numbers. And k is randomized using the notation P('r*10', i) . To learn more about this, please refer to the section about Patterns and about the pattern Language. You will sometimes encounter features you don't know about yet while scrolling through these examples. Don't worry, they are covered somewhere!","title":"Drowning in numbers"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#swimming-with-friends","text":"def calling_you (): print ( 'I hear you' ) @swim def basic (): calling_you () again ( basic ) hush ( basic ) A swimming function can call a regular function ( i.e. a function with no Sardine decorator). This example is boring as hell but it demonstrates one thing: Sardine is just regular Python with a twist. Be creative, import your favorite packages and make your computer crash in rhythm!","title":"Swimming with friends"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#synchronized-swimming","text":"@swim def first (): print ( 'first!' ) again ( second ) def second (): print ( 'second!' ) again ( first ) A swimming function calling another one, which will call back the first one in return. This is a loop of looping functions. You can make use of this to organise longer pieces if you'd like to.","title":"Synchronized Swimming"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#sardines-playing-waterpolo","text":"@swim def first ( d = 0.5 , rng = 0 ): print ( f \"Received: { rng } \" ) rng = randint ( 1 , 10 ) print ( f \"Sending: { rng } \" ) again ( second , d = 0.5 , rng = rng ) # evaluate me first def second ( d = 0.5 , rng = 0 ): print ( f \"Received: { rng } \" ) rng = randint ( 1 , 10 ) print ( f \"Sending: { rng } \" ) again ( first , d = 0.5 , rng = rng ) Exchanging data between swimming functions just like sardines playing waterpolo. This is just an extension of some on the materials depicted above. There is no limit to the things you can do by recursion. It will only gradually cause more headaches as you go along.","title":"Sardines playing Waterpolo"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#ii-surfing-concise-syntax","text":"There is an alternative jam-oriented way of using swimming functions inspired by FoxDot , another very cool live-coding library for Python created by Ryan Kirkbride . This technique is an emulation or simulation of FoxDot mode of operation. It uses the same syntax and the same philosophy of patterning but it relies on Sardine 's foundations. This mode of swimming is basically assigning Senders to an invisible swimming function that runs automatically behind your back. Warning If you don't know yet what a Sender is, you better go consult the page about it first before reading this section.","title":"II - Surfing: concise syntax"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#surfboards-players","text":"By default, there are 48 Players ready for surfing. This is more than you will ever need! Nobody can play with that many patterns live. They are named in a consistent way from Pa , to PZ : [Pa, Pb, Pc, Pd, Pe, Pf, ..., PA, PB, PC, ... PZ] . These objects use a central method: >> . Just like anything else with Sardine , you can also fine-tune your patterns with some setters that will alter how the pattern is interpreted by the clock. We will use Pa for demonstration purposes: Pa.rate : time spent on a single event in a linear sequence of events (step speed). Pa.dur : duration of a single event in a linear sequence of events (step duration). While playing/patterning with surfboards , you will only ever need to deal with these three methods. All the rest is integrated with the rest of the Sardine ecosystem: # The sun is high, let's go surfing Pa >> play ( 'bd, ., hh' ) Pa . rate = 1 # Ok, I'm done surfing for today.. Time to eat marshmallows.. hush () In addition to that, take note of the play() method used for assigning a Sender to Players . There is one method per available default Sender . It behaves exactly like your typical senders : play(*args, **kwargs) : the default SuperDirt (or S ) Sender. play_midi(*args, **kwargs) : the default MIDI (or M ) Sender. play_osc(*args, **kwargs) : the default OSC (or O ) Sender. run(func: Callable) : run any function like if it was a surfboard! I repeat, these functions are basically senders with a different name! You will have to learn how to use Senders to be truly efficient with the surfing mode. You can spend your life using Sardine this way or combine it with swimming functions , this is entirely up to you! This mode was initially designed in order to demonstrate the syntax of FoxDot . I find it to be a fun and efficient way to jam along with friends as well :) You can just fire up a Sardine session and write pretty fast.","title":"Surfboards (Players)"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#the-efficiency-of-surfing","text":"PB >> play ( 'jvbass:r*8, ..., pluck, ...' ) PA >> play ( 'bd, ., hh, sn, hh' , amp = 0.4 , legato = '0.3~1' , speed = '1' ) By using the play() method and combining it with regular patterns, you can more quickly generate efficient drum patterns without having to type too much! Your drum patterns will only take a few lines, and more complex swimming functions can be reserved for more complex tasks.","title":"The efficiency of surfing"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#surfing-on-midi-cables","text":"PA >> play_midi ( '<C@maj7>' , dur = '1~8' ) PA . dur = 3 PB >> play_midi ( \"C.., C|C'|C''\" , dur = '1~8' ) PB . rate = 2 The play_midi() function is the good old M() Sender . The note= parameter has been promoted to an arg in this mode in order to save you from having to type 5 more letters :)","title":"Surfing on MIDI Cables"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#how-to-stop-surfing","text":"Surfing patterns are fully integrated with the rest of Sardine . You can shut them down by calling the hush() or panic() function just like for other swimming functions . You can also use direct the Player value to \"None\" (PB >> None). This will stop the output for that player - which is useful if you have multiple Players. To start again, just load the PB >> play() line again. PA >> play ( 'bd, ., hhh, .' ) PA . rate = 1 PB >> play ( 'cp' ) PB . dur = 0.5 PB >> None # stops only the PB Player hush () # stops all Players","title":"How to stop surfing"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#iii-fast-swimming-functions","text":"This section requires a good understanding of general Sardine concepts. You need to understand patterns , senders , and a few other concepts. You need to have at least a very vague idea about the temporal system Sardine is using and how patterns are written/interpreted, etc... It will open up a very cool world of polyrythmic patterns, rhythmic divisions, etc...","title":"III - Fast swimming functions"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#swimming-at-clock-speed","text":"@swim def fast ( d = 0.25 , i = 0 ): S ( 'bd' , speed = '0.5,2' , legato = 0.1 ) . out ( i , div = 4 , rate = 2 ) S ( 'hh, jvbass:0|8|4,' , pan = '[0:1,0.1]' , legato = 0.1 ) . out ( i , div = 8 if rarely () else 5 , rate = 2 ) S ( 'cp' , legato = 0.1 ) . out ( i , div = 8 ) a ( fast , d = 1 / 8 , i = i + 1 ) Sardine swimming functions are usually slow (compared to the clock internal speed). However, you can speed up your recursion, the only hard limit being the speed at which the clock itself operates. It means that the faster you go, the better the rhythmic precision. The faster, the merrier! You will be able to have a finely grained control over time and events, with the ability to write more groovy or swinging code. It will also make your LFOs and signal-like patterns sing more. The recipe for fast swimming is the following: Use a very fast recursion speed ( 1/8 , 1/16 , 1/32 ), usually constant (no patterning). Play a lot with silences and with the arguments of .out(iterator, div, rate) .","title":"Swimming at clock speed"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#fast-swimming-template","text":"@swim def fast ( d = 0.5 , i = 0 ): # print(\"Damn, that's fast!\") a ( fast , d = 1 / 32 , i = i + 1 ) This is the template for a fast swimming function . You can skip the iterator if you don't need it or if you wish to use another iteration tool (such as amphibian variables ). This function is really fast. Uncomment the print statement to notice how fast it is. To learn how to control it efficiently, take a look at the following paragraphs about divisors and the rate factor.","title":"Fast swimming template"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#fast-swimming-parameters","text":"@swim def fast ( d = 0.5 , i = 0 ): S ( 'bd' ) . out ( i , div = 8 ) a ( fast , d = 1 / 16 , i = i + 1 ) The .out() method as well as the independant P() object can take up to three arguments: i ( int ): the iterator for patterning. Mandatory for the two other arguments to work properly. This iterator is the index of the values extracted from your linear list-like patterns. How this index will be interpreted will depend on the next two arguments. div ( int ): a timing divisor . It is very much alike a modulo operation. If div=4 , the event will hit once every 4 iterations. The default is div=1 , where every event is a hit! Be careful not to set a div=1 on a very fast swimming function as it could result in catastrophic failure / horrible noises. There is no parachute out in the open sea. rate ( float ): a speed factor for iterating over pattern values. It will slow down or speed up the iteration speed, the speed at which the pattern values are indexed on. For the pattern 1, 2, 3 and a rate of 0.5 , the result will be perceptually similar to 1, 1, 2, 2, 3, 3 . Let's illustrate. In the example below, we are playing with various divisors to generate an interesting rythmic pattern. Combine that with more interesting drumming and boom, you now have the secret recipe for an interesting algorave . @swim def fast ( d = 0.5 , i = 0 ): S ( 'bd' ) . out ( i , div = 8 ) S ( 'hh' ) . out ( i , div = 7 ) S ( 'sd' ) . out ( i , div = 16 ) a ( fast , d = 1 / 16 , i = i + 1 )","title":"Fast swimming parameters"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#can-we-do-more","text":"Of course we can. So far, we only used one patterning speed because every sender is iterating over all its patterns at the same speed but you could use the P() object for including different iteration speeds inside your main fast swimming rhythm. This is a bit jargon heavy but I hope that you will understand what I mean. If you don't, see for yourself: c . bpm = 125 @swim def there_is_a_light ( d = 0.5 , i = 0 ): S ( 'drum' , legato = 1 , speed = '1' ) . out ( i , 8 ) S ( 'drum:[1,2,3,4]' , legato = 1 , speed = P ( '1,2,3,4,5,1!2,4!4' , i + 1 , 2 , 0.5 )) . out ( i , 4 ) a ( there_is_a_light , d = 1 / 8 , i = i + 1 ) Go slow, read line after line and you will eventually get it!","title":"Can we do more?"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#conclusion-about-swimming","text":"The concept of temporal recursion is deep. There are many clever things you can do with it, and it might take some time to see and master different patterning techniques. Swimming functions are only the beginning to your temporal voyage with Sardine because you will notice that there are multiple ways to speak / think about time even in the context of this very generic framework. Let's go through some examples really quick to whet your appetite.","title":"Conclusion about swimming"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#imperative-style","text":"Take a swimming function , make it long enough, use our very special sleep() function (which is not the regular Python sleep) and you can write code \u00e0 la Sonic Pi : @swim def sonorous_cake ( d = 0.5 , i = 0 ): S ( 'bd' ) . out () sleep ( 0.5 ) S ( 'hh' ) . out () sleep ( 0.5 ) S ( 'bd' ) . out () sleep ( 0.5 ) S ( 'sn' ) . out () a ( sonorous_cake , d = 2 , i = i + 1 )","title":"Imperative style"},{"location":"documentation/sardinopedia/basic_swimming_lessons/#declarative-style","text":"Make your swimming functions very dense, write using a mostly declarative style. Spice it up with the patterning system if you'd like: @swim def one_line ( d = 0.5 , i = 0 ): S ( 'bd, drum, sn, drum:2' ) . out ( i ) a ( one_line , d = 0.5 , i = i + 1 )","title":"Declarative style"},{"location":"documentation/sardinopedia/clock/","text":"I - Modes Nothing would be happening without the Sardine clock. The clock is the central piece of the library. It is always running in the background and it manages function execution, recursion and timing. This is a complex and fragile mechanism. Python is particularly bad when you are trying to enforce timing guarantees. The clock is still a work in progress. If you are good at programming clocks or similar mechanisms, please come have a chat with me :) The clock works pretty well until the moment it doesn't work anymore. If you are trying to be extra precise, follow these instructions: kill every other non-essential program or process. We are trying to minimise context switching between the Sardine clock mechanism and the outside world. start Sardine with sudo or administrator priviledges. This allows me to nice the process a fair bit. Sardine will have a higher priority among other processes. be gentle, don't try to go faster than time. There is a minimal time division that the clock can handle. You can find out about it by typing c._get_tick_duration() a few times to see what the minimal amount of time between recursions is at your given tempo. Internally, the Clock instance, aliased as c , is managing a lot of things. It is involved in proper message handling, ensuring time guarantees and much more. A) MIDI Mode a) Active By default, the clock is running in active mode . It means that Sardine will emit a MIDI Clock signal on the default MIDI port. A MIDI Clock works by ticking constantly and it usually relies on a pulses per quarter note division, that indicates how many pulses form a basic rhythmic division. Hardware equipment are usually working at 24 or 48 PPQN but you can go much higher. Sardine tries to work well at these values, but the rest is really grey area. You are on your own. b) Passive In passive mode, Sardine will await for a clock signal. If the signal never comes, nothing will happen and you will be stuck in time. Please make sure to have a steady clock signal before booting Sardine . This mode is experimental and has never been truly tested. B) Link Mode Sardine can synchronise with other audio software / equipment through the Ableton Link protocol. You can switch from the regular clock to the Link clock by running the c.link() or c.unlink() method. Note that it is better to do this at startup and to shut down every running pattern before doing so because Sardine will dramatically jump in time. Some of your patterns might lie somewhere in the future, or somewhere in the past. This synchronisation mode works reasonably well. Sardine has been tested live on stage multiple times with the Link synchronisation enabled and it was stable enough to run for several hours unmonitored :) Depending on your hardware, you might have to nudge some messages in time a fair bit but it has nothing to do with the synchronisation itself but more likely with how your system is handling messages (internal delay of some sort). Log information For your own curiosity, you can turn on clock monitoring by switching a boolean: c.debug = True . Be careful, the information is very invasive and it can be very fast. You will see how the clock advances in time by ticking at a steady rate. Please turn this mode off before playing anything because printing is not innocent, it can have a temporal cost that will cause the clock to slow down a little. II - Attributes and useful information c.beat : current beat. c.phase : current phase. c.ppqn : current pulses per quarter note. c.tick : current tick. III - Shifting / Latency c._superdirt_nudge : adding a delay the timestamp attached to each SuperDirt message. c._midi_nudge : nudging MIDI in time. c.accel : acceleration of the clock, between 0 and 100 %. Similar to a jog on a DJ controller. c.nudge : nudging clock temporarily (for one cycle).","title":"Clock"},{"location":"documentation/sardinopedia/clock/#i-modes","text":"Nothing would be happening without the Sardine clock. The clock is the central piece of the library. It is always running in the background and it manages function execution, recursion and timing. This is a complex and fragile mechanism. Python is particularly bad when you are trying to enforce timing guarantees. The clock is still a work in progress. If you are good at programming clocks or similar mechanisms, please come have a chat with me :) The clock works pretty well until the moment it doesn't work anymore. If you are trying to be extra precise, follow these instructions: kill every other non-essential program or process. We are trying to minimise context switching between the Sardine clock mechanism and the outside world. start Sardine with sudo or administrator priviledges. This allows me to nice the process a fair bit. Sardine will have a higher priority among other processes. be gentle, don't try to go faster than time. There is a minimal time division that the clock can handle. You can find out about it by typing c._get_tick_duration() a few times to see what the minimal amount of time between recursions is at your given tempo. Internally, the Clock instance, aliased as c , is managing a lot of things. It is involved in proper message handling, ensuring time guarantees and much more.","title":"I - Modes"},{"location":"documentation/sardinopedia/clock/#a-midi-mode","text":"","title":"A) MIDI Mode"},{"location":"documentation/sardinopedia/clock/#a-active","text":"By default, the clock is running in active mode . It means that Sardine will emit a MIDI Clock signal on the default MIDI port. A MIDI Clock works by ticking constantly and it usually relies on a pulses per quarter note division, that indicates how many pulses form a basic rhythmic division. Hardware equipment are usually working at 24 or 48 PPQN but you can go much higher. Sardine tries to work well at these values, but the rest is really grey area. You are on your own.","title":"a) Active"},{"location":"documentation/sardinopedia/clock/#b-passive","text":"In passive mode, Sardine will await for a clock signal. If the signal never comes, nothing will happen and you will be stuck in time. Please make sure to have a steady clock signal before booting Sardine . This mode is experimental and has never been truly tested.","title":"b) Passive"},{"location":"documentation/sardinopedia/clock/#b-link-mode","text":"Sardine can synchronise with other audio software / equipment through the Ableton Link protocol. You can switch from the regular clock to the Link clock by running the c.link() or c.unlink() method. Note that it is better to do this at startup and to shut down every running pattern before doing so because Sardine will dramatically jump in time. Some of your patterns might lie somewhere in the future, or somewhere in the past. This synchronisation mode works reasonably well. Sardine has been tested live on stage multiple times with the Link synchronisation enabled and it was stable enough to run for several hours unmonitored :) Depending on your hardware, you might have to nudge some messages in time a fair bit but it has nothing to do with the synchronisation itself but more likely with how your system is handling messages (internal delay of some sort).","title":"B) Link Mode"},{"location":"documentation/sardinopedia/clock/#log-information","text":"For your own curiosity, you can turn on clock monitoring by switching a boolean: c.debug = True . Be careful, the information is very invasive and it can be very fast. You will see how the clock advances in time by ticking at a steady rate. Please turn this mode off before playing anything because printing is not innocent, it can have a temporal cost that will cause the clock to slow down a little.","title":"Log information"},{"location":"documentation/sardinopedia/clock/#ii-attributes-and-useful-information","text":"c.beat : current beat. c.phase : current phase. c.ppqn : current pulses per quarter note. c.tick : current tick.","title":"II - Attributes and useful information"},{"location":"documentation/sardinopedia/clock/#iii-shifting-latency","text":"c._superdirt_nudge : adding a delay the timestamp attached to each SuperDirt message. c._midi_nudge : nudging MIDI in time. c.accel : acceleration of the clock, between 0 and 100 %. Similar to a jog on a DJ controller. c.nudge : nudging clock temporarily (for one cycle).","title":"III - Shifting / Latency"},{"location":"documentation/sardinopedia/introduction/","text":"The Sardinopedia is a growing and partially ordered collection of interesting Sardine patterns. Patterns worthy of inclusion in the Sardinopedia must at least have one of the following qualities: they are demonstrative : they highlight a particular feature. they are didactic : they teach you how to use Sardine . they are musical : they have an interesting musical result. they are odd : they show something odd, unexpected, funny, etc... Some sections are more verbose than others and will contain explanations for various parts of the system. As such, the Sardinopedia is your main source of documentation concerning Sardine . This documentation is entirely written by the community. Feel free to contribute by altering what is found in the docs/ folder and to add whatever you see fit! There are some areas where the Sardinopedia is a bit lacking! Consulting the Sardinopedia live You can consult the Sardinopedia locally by summoning the help() function or the verbose print_sardinopedia() function.","title":"Introduction"},{"location":"documentation/sardinopedia/melody/","text":"Pitch Playback speed (S) @swim def hh ( d = 0.5 , i = 0 ): S ( 'hh' , speed = '[1:8]' ) . out ( i ) again ( hh , d = 0.5 , i = i + 1 ) Changing the speed of audio playback for a given audio sample. Cheap version of tuning. Sample to pitch (S) @swim def hh ( d = 0.5 , i = 0 ): S ( 'hh' , midinote = 'C5!3, E5, G5' ) . out ( i ) again ( hh , d = 0.5 , i = i + 1 ) Pitching an audio sample relatively to a MIDI note. Sample to freq (S) @swim def hh ( d = 0.5 , i = 0 ): S ( 'hh' , freq = '100 + (r*2000)' ) . out ( i ) again ( hh , d = 0.5 , i = i + 1 ) Pitching an audio sample relatively to a given frequency (in hertz ).","title":"Melody"},{"location":"documentation/sardinopedia/melody/#pitch","text":"","title":"Pitch"},{"location":"documentation/sardinopedia/melody/#playback-speed-s","text":"@swim def hh ( d = 0.5 , i = 0 ): S ( 'hh' , speed = '[1:8]' ) . out ( i ) again ( hh , d = 0.5 , i = i + 1 ) Changing the speed of audio playback for a given audio sample. Cheap version of tuning.","title":"Playback speed (S)"},{"location":"documentation/sardinopedia/melody/#sample-to-pitch-s","text":"@swim def hh ( d = 0.5 , i = 0 ): S ( 'hh' , midinote = 'C5!3, E5, G5' ) . out ( i ) again ( hh , d = 0.5 , i = i + 1 ) Pitching an audio sample relatively to a MIDI note.","title":"Sample to pitch (S)"},{"location":"documentation/sardinopedia/melody/#sample-to-freq-s","text":"@swim def hh ( d = 0.5 , i = 0 ): S ( 'hh' , freq = '100 + (r*2000)' ) . out ( i ) again ( hh , d = 0.5 , i = i + 1 ) Pitching an audio sample relatively to a given frequency (in hertz ).","title":"Sample to freq (S)"},{"location":"documentation/sardinopedia/pattern_language/","text":"I - The Sardine Pattern Language I have talked a fair bit about the internal programming language used by Sardine . Let's deep dive and learn more about it. This language is dedicated to creating patterns of notes, numbers, samples and addresses. It is an ongoing project and might be subject to change in upcoming versions but there is a subset of stable features that you can use without risking your code to break too fast :) The syntax, much like the syntax of a regular general-purpose programming languages is organised in primitive types and unary / binary operators or functions you can apply on/to them. It is very reminescent of Python but with a twist! I am not very skilled at developing custom programming languages but the plan.. you get it.. is to get better at it by practising and getting help from others. If you already know how to build things like this, the architecture for the Sardine language is rather sane and self-contained. The language can be developed and tested against unit tests. Go for it! II - Primitive types A) Integers and floating-point numbers @swim def number ( d = 0.5 , i = 0 ): print ( P ( '1, 1+1, 1*2, 1/3, 1%4, 1+(2+(5/2))' , i )) again ( number , d = 0.5 , i = i + 1 ) You can write numbers (both integers and floating point numbers ) and use common operators such as addition , substraction , division , multiplication , modulo , etc... For precision in your calculations, you can of course resort to using parentheses. By default, Sardine is made so that most arithmetic operators can be used on almost anything, expect if intuitively it doesn't make sense at all like multiplying a string against a string. Let's stop for a moment and try to remember the following : you can apply arithmetics to numbers but also to lists! You can for instance write an addition between a number and a list, between two lists, between a number and a note, between a chord and a list, etc.. All of this is supported by the language. Incidentally, it means that functions that work on lists can also work on single tokens. It also means that functions that are supposed to work for single numbers will work for lists, because the function will be mapped to every element in the list. It turns the act of composing patterns into a rather organic process. a1) Time-dependant numbers @swim def number ( d = 0.5 , i = 0 ): print ( P ( '$, r, m, p' , i )) again ( number , d = 0.5 , i = i + 1 ) Some number tokens are clock-time dependant (based on Sardine clock time) and refer to a moment in time. Depending on the moment your recursion takes place, you might see some values recurring because you are not polling continuously but polling just a tiny and predictible moment in time. $ : tick , the tick number since the clock started. $.p : phase , a number between 0 and your c.ppqn . $.m : measure , the measure since the clock started. @swim def number ( d = 0.5 , i = 0 ): print ( P ( '$, $.m, $.p' )) . out ( i ) again ( number , d = 0.5 , i = i + 1 ) Some other number tokens are absolute-time dependant. They are mostly used for long-running sequences and/or for introducing a random factor in the result of the expression. You will notice that they are prefixed by $ . @swim def random ( d = 0.5 , i = 0 ): print ( P ( 'T.U, T.Y, T.M, T.D, T.h, T.m, T.s, T.\u00b5' , i )) again ( random , d = 0.5 , i = i + 1 ) T.U : Unix Time, the current Unix Time. T.Y : year, the current year. T.M : month, the current month. T.D : day, the current day. T.h : hour, the current hour. T.m : minute, the current minute. T.s : second, the current second. T.\u00b5 : microsecond, the current microsecond. a2) Random numbers You can write random numbers by using the letter r . By default, r will return a floating point number between 0.0 and 1.0 but it will be casted to integer if it makes more sense in that context ( e.g. sample:r*8 ). This is not the only way to generate a random number. For instance, r and 0.0~1.0 yield a similar result. Redundancy is good when working with a programming language! a3) Patterns out of time @swim def random ( d = 0.5 , i = 0 ): S ( 'cp' , speed = '$%20' ) . out ( i ) again ( random , d = 0.5 , i = i + 1 ) Timed tokens make good low frequency oscillators , ramps or oscillating patterns. Playing with time tokens using modulos or the sin() , cos() or tan() functions is a great way to get generative results out of a predictible sequence. It is very important to practice doing this, especially if you are planning to use fast swimming functions . The faster you recurse, the better your timing resolution. You can start to enter into the realm of signal-like patterns that can be particularly good for generating fluid patterns. B) Notes @swim def notes ( d = 0.5 , i = 0 ): S ( 'pluck' , midinote = 'C5,D5,E5,F5,G5' ) . out ( i ) again ( notes , d = 0.5 , i = i + 1 ) Notes are one of the primitives you can use in patterns. Notes will always be converted to some MIDI value (an integer value between 0 and 127 ). Notes will be converted to some MIDI value used by SuperDirt . If you need more precision, speak in hertzs ( freq=402.230239 ). Notes are numbers too (!!). You can do math on them if you wish to. The syntax to write notes is the following: 1) [MANDATORY] capital letter indicating the note name: C , D , E , F , G , A , B . Sardine also supports the french notation system, so you can write Do, R\u00e9, Mi, Fa, Sol, La, Si if it feels more natural to you :) 2) [FACULTATIVE] flat or sharp: # , b . 3) [FACULTATIVE] octave number: 0 .. 9 . Of course, if you are a robot, you might prefer to speak in numbers. Because notes are turned into numbers, you can do this and Sardine will not complain. It can be particularly useful to generate custom voicings or weirdly shaped chords that you want to transpose and invert around: <([0,4,7,9,10,11]+50)^1> . b1) Note qualifiers @swim def notes ( d = 0.5 , i = 0 ): S ( 'pluck' , midinote = 'C5@penta' ) . out ( i ) again ( notes , d = 0.5 , i = i + 1 ) You can use the @ operator to qualify a note (or a number?). This will turn a note into a collection of notes / structure based on the targetted note. C@penta will summon a major pentatonic scale based on the middle C note: [60, 62, 64, 67, 69] . Be careful while using them as they will instantly turn a single token into a list of x tokens. You might want to filter part of a qualifiers note collection. You will soon find out that it can be cumbersome to summon a long list of notes from the realm of oblivion. You will have to learn techniques to get better at summoning the exact materials you want and some processing by using functions might be needed to get a better result. Writing your patterns by hand is also an option if you are able to think and write down precise harmonic / melodic materials. Check out functions like filt() or quant() . Take note that the following list is not always perfectly up to date. Moreover, it can be particularly tricky for you to remember how I named some of the structures: qualifiers = { ########## # Chords # ########## \"dim\" : [ 0 , 3 , 6 , 12 ], \"dim9\" : [ 0 , 3 , 6 , 9 , 14 ], \"hdim7\" : [ 0 , 3 , 6 , 10 ], \"hdim9\" : [ 0 , 3 , 6 , 10 , 14 ], \"hdimb9\" : [ 0 , 3 , 6 , 10 , 13 ], \"dim7\" : [ 0 , 3 , 6 , 9 ], \"aug\" : [ 0 , 4 , 8 , 12 ], \"augMaj7\" : [ 0 , 4 , 8 , 11 ], \"aug7\" : [ 0 , 4 , 8 , 10 ], \"aug9\" : [ 0 , 4 , 10 , 14 ], \"maj\" : [ 0 , 4 , 7 , 12 ], \"maj7\" : [ 0 , 4 , 7 , 11 ], \"maj9\" : [ 0 , 4 , 11 , 14 ], \"minmaj7\" : [ 0 , 3 , 7 , 11 ], \"five\" : [ 0 , 7 , 12 ], \"six\" : [ 0 , 4 , 7 , 9 ], \"seven\" : [ 0 , 4 , 7 , 10 ], \"nine\" : [ 0 , 4 , 10 , 14 ], \"b9\" : [ 0 , 4 , 10 , 13 ], \"mM9\" : [ 0 , 3 , 11 , 14 ], \"min\" : [ 0 , 3 , 7 , 12 ], \"min7\" : [ 0 , 3 , 7 , 10 ], \"min9\" : [ 0 , 3 , 10 , 14 ], \"sus4\" : [ 0 , 5 , 7 , 12 ], \"sus2\" : [ 0 , 2 , 7 , 12 ], \"b5\" : [ 0 , 4 , 6 , 12 ], \"mb5\" : [ 0 , 3 , 6 , 12 ], ########## # Scales # ########## \"major\" : [ 0 , 2 , 4 , 5 , 7 , 9 , 11 ], \"minor\" : [ 0 , 2 , 3 , 5 , 7 , 8 , 10 ], \"hminor\" : [ 0 , 2 , 3 , 5 , 7 , 8 , 11 ], \"vminor\" : [ 0 , 2 , 3 , 5 , 7 , 8 , 10 ], \"penta\" : [ 0 , 2 , 4 , 7 , 9 ], \"acoustic\" : [ 0 , 2 , 4 , 6 , 7 , 9 , 10 ], \"aeolian\" : [ 0 , 2 , 3 , 5 , 7 , 8 , 10 ], \"algerian\" : [ 0 , 2 , 3 , 6 , 7 , 9 , 11 , 12 , 14 , 15 , 17 ], \"superlocrian\" : [ 0 , 1 , 3 , 4 , 6 , 8 , 10 ], \"augmented\" : [ 0 , 3 , 4 , 7 , 8 , 11 ], \"bebop\" : [ 0 , 2 , 4 , 5 , 7 , 9 , 10 , 11 ], \"blues\" : [ 0 , 3 , 5 , 6 , 7 , 10 ], \"chromatic\" : [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ], \"dorian\" : [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ], \"doubleharmonic\" : [ 0 , 1 , 4 , 5 , 8 , 11 ], \"enigmatic\" : [ 0 , 1 , 4 , 6 , 8 , 10 , 11 ], \"flamenco\" : [ 0 , 1 , 4 , 5 , 7 , 8 , 11 ], \"gypsy\" : [ 0 , 2 , 3 , 6 , 7 , 8 , 10 ], \"halfdim\" : [ 0 , 2 , 3 , 5 , 6 , 8 , 10 ], \"harmmajor\" : [ 0 , 2 , 4 , 5 , 7 , 8 , 11 ], \"harmminor\" : [ 0 , 2 , 3 , 5 , 7 , 8 , 11 ], \"hirajoshi\" : [ 0 , 4 , 6 , 7 , 11 ], \"hungarianminor\" : [ 0 , 2 , 3 , 6 , 7 , 8 , 11 ], \"hungarianmajor\" : [ 0 , 3 , 4 , 6 , 7 , 9 , 10 ], \"in\" : [ 0 , 1 , 5 , 7 , 8 ], \"insen\" : [ 0 , 1 , 5 , 7 , 10 ], \"ionian\" : [ 0 , 2 , 4 , 5 , 7 , 9 , 11 ], \"istrian\" : [ 0 , 1 , 3 , 4 , 6 , 7 ], \"iwato\" : [ 0 , 1 , 5 , 6 , 10 ], \"locrian\" : [ 0 , 1 , 3 , 5 , 6 , 8 , 10 ], \"lydianaug\" : [ 0 , 2 , 4 , 6 , 8 , 9 , 11 ], \"lydian\" : [ 0 , 2 , 4 , 5 , 7 , 8 , 9 , 11 ], \"majorlocrian\" : [ 0 , 2 , 4 , 5 , 6 , 8 , 10 ], \"majorpenta\" : [ 0 , 2 , 4 , 7 , 9 ], \"minorpenta\" : [ 0 , 3 , 5 , 7 , 10 ], \"melominup\" : [ 0 , 2 , 3 , 5 , 7 , 9 , 11 ], \"melomindown\" : [ 0 , 2 , 3 , 5 , 7 , 8 , 10 ], \"mixolydian\" : [ 0 , 2 , 4 , 5 , 7 , 9 , 10 ], \"neapolitan\" : [ 0 , 1 , 3 , 5 , 7 , 8 , 11 ], \"octatonic\" : [ 0 , 2 , 3 , 5 , 6 , 8 , 9 , 11 ], \"octatonic2\" : [ 0 , 1 , 3 , 4 , 6 , 7 , 9 , 10 ], \"persian\" : [ 0 , 1 , 4 , 5 , 6 , 8 , 11 ], \"phrygian\" : [ 0 , 1 , 4 , 5 , 7 , 8 , 10 ], \"prometheus\" : [ 0 , 2 , 4 , 6 , 9 , 10 ], \"harmonics\" : [ 0 , 3 , 4 , 5 , 7 , 9 ], \"tritone\" : [ 0 , 1 , 4 , 6 , 7 , 10 ], \"ukrainian\" : [ 0 , 2 , 3 , 6 , 7 , 9 , 10 ], \"whole\" : [ 0 , 2 , 4 , 6 , 8 , 10 ], \"yo\" : [ 0 , 3 , 5 , 7 , 10 ], \"symetrical\" : [ 0 , 1 , 2 , 6 , 7 , 10 ], \"symetrical2\" : [ 0 , 2 , 3 , 6 , 8 , 10 ], \"messiaen1\" : [ 0 , 2 , 4 , 6 , 8 , 10 ], \"messiaen2\" : [ 0 , 1 , 3 , 4 , 6 , 7 , 9 , 10 ], \"messiaen3\" : [ 0 , 2 , 3 , 4 , 6 , 7 , 8 , 10 , 11 ], \"messiaen4\" : [ 0 , 1 , 2 , 4 , 6 , 7 , 8 , 11 ], \"messiaen5\" : [ 0 , 1 , 5 , 6 , 7 , 11 ], \"messiaen6\" : [ 0 , 2 , 4 , 5 , 6 , 8 ], \"messiaen7\" : [ 0 , 1 , 2 , 3 , 5 , 6 , 7 , 8 , 9 , 11 ], ############## # Structures # ############## \"fourths\" : [ 0 , 4 , 10 , 15 , 20 ], \"fifths\" : [ 0 , 7 , 14 , 21 , 28 ], \"sixths\" : [ 0 , 9 , 17 , 26 , 35 ], \"thirds\" : [ 0 , 4 , 8 , 12 ], \"octaves\" : [ 0 , 12 , 24 , 36 , 48 ], } b2) Note modifiers @swim def notes ( d = 0.5 , i = 0 ): S ( 'pluck' , midinote = 'disco(C5@penta)' . out ( i ) again ( notes , d = 0.5 , i = i + 1 ) Functions can be used to further refine the effect of a modifier. There is a long list of functions that you can apply, such as disco() or adisco() as shown in the preceding example. If you ever wonder about the list of possible functions, refer to the Sardinopedia or enter any function name. If the function name is wrong, the list of possible functions will be printed out in the terminal. b3) Chord / Collection inversion @swim def notes ( d = 0.5 , i = 0 ): S ( 'pluck' , midinote = 'disco(C5@maj7^4)' . out ( i ) again ( notes , d = 0.5 , i = i + 1 ) You can write chord inversions using the ^ syntax. It will accept any valid expression like ^1~5 . You can also feed negative numbers for inverting a chord downwards. Chord inversions are not only for chords but they also work on lists, which means that you can write custom chords and transpose them up or down :) b4) Mathematics on notes @swim def notes ( d = 0.5 , i = 0 ): S ( 'pluck' , midinote = 'disco(braid(C5+0|4|8@penta' ))) . out ( i ) again ( notes , d = 0.5 , i = i + 1 ) You can use arithmetic operators on notes like if they were a regular number. That's because they are really just numbers! Random and time-dependant numbers are numbers too. Notes are numbers too so you can add a note to a note even if it doesn't really make sense. It will also not probably sound very good because notes are clamped in the range from 0 to 127 . b5) Polyphony Note polyphony @swim def poly ( d = 0.5 , i = 0 ): S ( '<[superpiano]>' , cutoff = 500 , midinote = '<D@maj9>, <G@maj7^0>, <D@maj9>, <G@dim7^1>' ) . out ( i , 2 , 0.25 ) a ( poly , d = P ( '0.5!4, 0.25!2' , i ), i = i + 1 ) You can use the < and > delimiters to make parts of your pattern polyphonic. You will soon notice that there are multiple types of polyphony available but the most notable of all, demonstrated in the example above, is the note polyphony . It allows you to superpose multiple note events in your patterns just like you expected. However, Sardine allows you to deal with polyphony in more unexpected ways. There a few rules to understand about polyphony and polyphonic messages. These rules can sound quite counter-intuitive if you think about it in a traditional way. The size of a polyphonic event -- meaning the number of messages sent for one occurence of an event -- is equal to the length of the largest polyphonic pattern you declared. In the first example, we have a 4-5 note polyphony. Every polyphonic element from our pattern is a major 9 or 7 chord ( e.g [62, 66, 69, 73, 76] ). It means that if you have a polyphony of 2 somewhere and a polyphony of 4 elsewhere, your first polyphony will be distributed over the second one: 1) [1,2,3,4] 2) [0,1] RESULT: 1) [1,2,3,4] 2) [0,1,0,1] | | | | POLYPHONY @swim def poly ( d = 0.5 , i = 0 ): S ( '<[bd, superpiano]>' , cutoff = 500 , midinote = '<D@maj9>, <G@maj7^0>, <D@maj9>, <G@dim7^1>' ) . out ( i , 2 , 0.25 ) a ( poly , d = P ( '0.5!4, 0.25!2' , i ), i = i + 1 ) To illustrate the preceding rule we just talked about, here is a truly bizarre example. Half of our chord is played by a tuned bassdrum, the other half by a piano. Even though this may look odd, this is fully compliant with how parameters are handled by Sardine . We have two clear alternations, one between the superpiano and bd sound sets, the other between the four or five values that form our chords. It is then natural that half of our polyphony will be composed from a tuned bassdrum and the remaining half from a tuned piano. Once you get use to this novel way of thinking about polyphonic patterns, you will see that it opens up some space for interesting polyphonic interactions between sounds :) It is currently not possible to limit the number of voices generated by an event. Be careful! It is quite easy to go from some easy and sparse chords to black MIDI! Parametric polyphony @swim def poly ( d = 0.5 , i = 0 ): S ( 'drum:[1,6]' , speed = '<[1,clamp(r, 0.1, 1)]>, <[2,1.9]>' ) . out ( i , 3 ) S ( 'drum:2' , cutoff = '<[500:2000,500]*sin($ %r *80/40)*10>' ) . out ( i , 2 ) S ( 'bd' , shape = 0.5 ) . out ( i , 4 ) a ( poly , d = 0.5 / 2 , i = i + 1 ) Everything can become polyphonic. Just wrap anything between < and > and you will return x events, one for each value. It allows you to be very creative with patterns. C) Names @swim def names ( d = 0.5 , i = 0 ): S ( 'bd, pluck, bd, pluck:2+4' ) . out ( i ) again ( names , d = 0.5 , i = i + 1 ) You are using name patterns since you first started to read the Sardinopedia ! A single letter (if it's not already a note name) can be considered as a name. Be careful! There are a few hidden rules for names. Names can be one letter long but some letters are already taken by some parts of the language (such as r ). Names cannot begin with a number. It is also forbidden to use any symbol inside your names. D) Addresses O ( osc_client , \"an/address, another/address\" , value = 1 , other_value = 2 ) . out () Addresses are just like names except that they can contain a / separator just like any other typical OSC address out there. They are not really distinct from a name. The difference is only conceptual and in the usage of your strings. II - Lists and Collections The Sardine pattern notation is built around the idea of having multiple ways to deal with linear lists and collections. The basic arithmetic syntax and most operators work on single tokens but will also work on lists . It means that you can write expressions such as : [ 0 , 1 , 2 , 3 ] % 8 [ 0 , 2 , 4 , 5 ] * [ 4 , 5 ] [ 1 : 8 , 0.1 ] & [ 2 , 9 ] [ 0 , 2 , 4 , 5 , 9 , 10 , 12 , 14 ] ! 2 [ 0 , 2 , 4 , 5 , 9 , 10 , 12 , 14 ] !! 4 There are a few special operators that are only available when you deal with lists. This is something you will get familiar with by trying. You will see that most things work while some will not yield the result you expect. A) Slicing and indexing @swim def test_slice ( d = 0.5 , i = 0 ): S ( 'pluck:19' , legato = 0.2 , midinote = '([60,63,67,69, 71]&[i.i, i.i + 8])^(1~8)' ) . out ( i ) a ( test_slice , d = 0.125 , i = i + 1 ) You can get a slice or just one value from a list by using the special & operator. It will work with any list on the right side of the operator but it will only take the first and second value of it no matter what to compose a slice. The index value can be infinite because the index is looping on the list. You can feed a random number generator and get something out. On the down side, it can become quite complex to write very fast, so be careful with it: @swim def test_slice ( d = 0.5 , i = 0 ): S ( 'pluck:19' , legato = 0.2 , midinote = '[60,62, 63,67, 69, 71]^(1~5)&[r, r*4]' ) . out ( i ) a ( test_slice , d = 0.125 , i = i + 1 ) B) Extend @swim def test_extend ( d = 0.5 , i = 0 ): S ( 'pluck:19' , legato = 0.2 , midinote = '[60,62]!2' ) . out ( i ) a ( test_extend , d = 0.125 , i = i + 1 ) Just like with numbers, names and addresses, you can extend a list by calling the ! operator on it. It will repeat the list x times. C) Extend-repeat @swim def test_extend_repeat ( d = 0.5 , i = 0 ): S ( 'pluck:19' , legato = 0.2 , midinote = '[60,62,63]!!3' ) . out ( i ) #note the repetition of values within the list a ( test_extend_repeat , d = 0.125 , i = i + 1 ) The variant !! now makes sense. It allows you to repeat each individual value in a list x times. III - Operators A) Choice @swim def choosing_stuff ( d = 0.5 , i = 0 ): S ( 'bd|pluck' , speed = '1|2' ) . out ( i ) again ( choosing_stuff , d = 0.5 , i = i + 1 ) The pipe operator | can be used on anything to make a 50/50% choice between two tokens. You can also chain them: 1|2|3|4 . The behavior of chaining multiple choice operators has not been clearly defined. The distribution might not be the one you expect. B) Ranges @swim def ranges ( d = 0.5 , i = 0 ): S ( 'pluck|jvbass' , speed = '1~5' ) . out ( i ) again ( ranges , d = 0.5 , i = i + 1 ) If you want to generate a number in the range x to y included, you can use the ~ operator. It spits an integer if you are using integers as boundaries but it will spit out a floating point number if you are using floating point numbers as boundaries. If you use an integer on one side and a floating point number on the other side, a floating point number will be returned. It can be used as an alternative to the r token for generating random numbers. C) Ramps @swim def ramps ( d = 0.5 , i = 0 ): S ( 'amencutup:[0:10]' , room = '[0:1,0.1]' , cutoff = '[1:10]*100' ) . out ( i ) again ( ramps , d = 0.5 , i = i + 1 ) You can generate ramps of integers using the [1:10] syntax. This works just like Python 's range function. Well, almost... it's way better! You can generate descending ramps easily: [10:1] . You can also generate ascending ramps of floating point numbers by precising a step other than 1 : [1:10,0.5] . Of course, this also works the other way around :) D) Repeat @swim def repeat_stuff ( d = 0.5 , i = 0 ): S ( 'pluck|jvbass' , speed = '1:2' , midinote = 'C4!4, E4!3, E5, G4!4' ) . out ( i ) again ( repeat_stuff , d = 0.5 , i = i + 1 ) The ! operator inspired by TidalCycles is used to denote the repetition of a value. You can also sometimes use the !! operator from the same family. This operator is a bit different, because it is supposed to be used on lists. You can do maths on lists as well with Sardine , but this will be detailed in a section later on. E) Silence @swim def silence_demo ( d = 0.5 , i = 0 ): S ( 'bd,...' ) . out ( i , div = 1 ) S ( 'hh,., hh,..' ) . out ( i , div = 1 ) a ( silence_demo , d = 1 / 8 , i = i + 1 ) You can use a dot ( . ) inside any pattern to indicate a silence. Silence is a very important and complex topic. Adding silences is a great way to generate interesting patterns. Silences are different for each sender because silence doesn't have the same meaning for a sampler, a MIDI output or an OSC output ( S() , M() , O() ): S() : a silence is the absence of a sample. The event will be skipped. M() : a silence is the absence of a note. The event will be skipped. O() : a silence is the absence of an address. The event will be skipped. There is also the interesting case of what I like to call 'parametric silences' . Take a look at the following example: @swim def silence_demo ( d = 0.5 , i = 0 ): S ( 'sitar' , legato = '0.5' , speed = '[1:4], .!8' ) . out ( i , div = 1 ) a ( silence_demo , d = 1 / 8 , i = i + 1 ) We always have a sample here. There is no real silence but we have still have some silences included in the speed subpattern. It also has an effect. In the absence of a value for that silence, Sardine will backtrack and search the last value that could have been generated by the pattern. The result of the speed parameter will then be [1,2,3,4,8,8,8,8,8,8,8,8] . For people familiar with modular synthesis, this is pretty much equivalent to a sample & hold mechanism. It is impossible to write a parametric silence composed only of silences. It doesn't mean anything to provide a value and actually not providing it. IV - Amphibian variables A) Amphibian variables v . s = 60 # this is an amphibian variable @swim def fun (): # Calling it and setting it to v.s + 5 M ( note = 'v.s = v.s + 5' ) . out () if random () > 0.8 : v . s = 60 # resetting so it doesn't go too high again ( fun ) There is a group of variables called amphibian variables that are both valid inside and outside the pattern notation. They are defined by v followed by a letter from the alphabet (uppercase or lowercase) : v.a , v.A , v.Z , v.j . These variables can be freely manipulated from the Python side or from the pattern side. They are totally transparent. @swim def fun ( d = 0.25 ): # Now having fun with it M ( note = 'v.s = v.s + 5|2' ) . out () # more fun if random () > 0.8 : v . s = 50 again ( fun , d = 0.25 ) You can use them to leverage Python or the pattern syntax for what they do best: patterning or dealing with complex algorithmic transformations. Having them both available makes the pattern syntax even more expressive. There is a finite list of actions you can perform on amphibian variables : using them (just by calling them) setting them ( v.i = 5 ) resetting them to 0 ( v.i.reset ) B) Amphibian iterators @swim def amphi_iter ( d = 0.25 ): S ( 'amencutup:[1:10]' ) . out ( i . i ) if random () > 0.8 : i . i = 0 a ( amphi_iter , d = 0.25 ) Similarly to amphibian variables , there is a thing called amphibian iterators that are valid on both sides. They are defined by i followed by a letter from the alphabet (uppercase or lowercase) : i.a , i.A , i.Z , i.j . They can be use as substitutes for your regular manual recursive iterators. In the example above, I am using an amphibian iterator to summon a breakbeat. @swim def amphi_iter ( d = 0.25 ): S ( 'amencutup:[1:10]' , speed = '1|2|i.i=0' ) . out ( i . i ) a ( amphi_iter , d = 0.25 ) These iterators can be reset or set on the pattern side! @swim def amphi_iter ( d = 0.25 ): if random () > 0.8 : i . i = [ 1 , 5 ] else : i . i = [ 1 , 2 ] S ( 'amencutup:[1:10]' , speed = 'i.v|i.v=[1,2]' ) . out ( i . i ) a ( amphi_iter , d = 0.25 ) Similarly, you can define the step value between each value by providing a list of two numbers. This is valid on both sides. V - The Function Library Sardine pattern notation now comes with a function library. These are functions that should be used directly in the pattern notation to alter a list or a pattern you are working on. They can take basically any input but you will soon figure that some are more specialised than others. This is the part of the language that is the more subject to changes in upcoming versions. That's why I am only talking about it now, at the bottom of a fairly long page. I want to explore how far you can go by introducing functional concepts to handle linear sequences. So far, only functions are available. The next step will be to introduce high-order functions and to build a small set of functional operations to pattern functions themselves. Only then will I be happy. I will base myself on that work to write a decent and complex function library. A) Sinus, Cosinus, Tangent sin(x) : sinus of input (single tokens or lists). Classic mathematical sinus function. cos(x) : cosinus of input (single tokens or lists). Classic mathematical cosinus function. tan(x) : tangent of input (single tokens or lists). Classic mathematical tangent function. B) Scaling, measuring abs(x) : Absolute value. max(x) : Maximum value of list or token itself. min(x) : Minimum value of list or token itself. mean(x) : Mean of list or token itself. scale(z, x, y, x', y') : Bring a value z from range x-y to range x'-y' . clamp(x, y, z) : Clamp function, limit a value x to the minimum y to the maximum z . C) Reversal, shuffling rev(x) : Reverse a list. shuf(x) : Shuffle a list. pal(x) : palindrome of list. apal(x) : palindrome of list without repetition of last value. D) Musical functions disco(x) : Disco function. Every pair note down an octave. adisco(x) : Anti-disco function. Every pair note up an octave. bass(x) : The first note of list is down an octave (not very useful). sopr(x) : The last note of list is up an octave (not very useful). quant(x, y) : The last note of list is up an octave (not very useful). E) Voice Leading These are two voice leading algorithms. These are only temporary until I figure out a better solution. They usually take a list of four note chords and arrange the voice to minimise movement. They work great but they are not the funniest thing you've ever seen. I'll work on them to make it better! voice(x) : four-note voice leading algorithm. Naive implementation. dmitri(x) : four-note voice leading algorithm. Algorithm inspired by Dmitri Tymoczko's work. F) Probabilities vanish(x, y) : Takes a list x , output only y % of values from it. G) Booleans euclid(a, b, c, d) : Euclidian rhythm function applied to patterns. Takes a pattern a , a number of pulses b , a number of steps c and a rotation amount d . Outputs a pattern where the absence of a pulse is a silence and where pulses are values from the pattern. mask(x, y) : Generalisation of the euclidian rhythm algorithm. Works for any pattern and list of booleans. H) Insertion and rotation To be documented: in(x, y) : inp(x, y) : inrot(x, y) : inprot(x, y) : I) Filtering filt(x, y) :","title":"Language"},{"location":"documentation/sardinopedia/pattern_language/#i-the-sardine-pattern-language","text":"I have talked a fair bit about the internal programming language used by Sardine . Let's deep dive and learn more about it. This language is dedicated to creating patterns of notes, numbers, samples and addresses. It is an ongoing project and might be subject to change in upcoming versions but there is a subset of stable features that you can use without risking your code to break too fast :) The syntax, much like the syntax of a regular general-purpose programming languages is organised in primitive types and unary / binary operators or functions you can apply on/to them. It is very reminescent of Python but with a twist! I am not very skilled at developing custom programming languages but the plan.. you get it.. is to get better at it by practising and getting help from others. If you already know how to build things like this, the architecture for the Sardine language is rather sane and self-contained. The language can be developed and tested against unit tests. Go for it!","title":"I - The Sardine Pattern Language"},{"location":"documentation/sardinopedia/pattern_language/#ii-primitive-types","text":"","title":"II - Primitive types"},{"location":"documentation/sardinopedia/pattern_language/#a-integers-and-floating-point-numbers","text":"@swim def number ( d = 0.5 , i = 0 ): print ( P ( '1, 1+1, 1*2, 1/3, 1%4, 1+(2+(5/2))' , i )) again ( number , d = 0.5 , i = i + 1 ) You can write numbers (both integers and floating point numbers ) and use common operators such as addition , substraction , division , multiplication , modulo , etc... For precision in your calculations, you can of course resort to using parentheses. By default, Sardine is made so that most arithmetic operators can be used on almost anything, expect if intuitively it doesn't make sense at all like multiplying a string against a string. Let's stop for a moment and try to remember the following : you can apply arithmetics to numbers but also to lists! You can for instance write an addition between a number and a list, between two lists, between a number and a note, between a chord and a list, etc.. All of this is supported by the language. Incidentally, it means that functions that work on lists can also work on single tokens. It also means that functions that are supposed to work for single numbers will work for lists, because the function will be mapped to every element in the list. It turns the act of composing patterns into a rather organic process.","title":"A) Integers and floating-point numbers"},{"location":"documentation/sardinopedia/pattern_language/#a1-time-dependant-numbers","text":"@swim def number ( d = 0.5 , i = 0 ): print ( P ( '$, r, m, p' , i )) again ( number , d = 0.5 , i = i + 1 ) Some number tokens are clock-time dependant (based on Sardine clock time) and refer to a moment in time. Depending on the moment your recursion takes place, you might see some values recurring because you are not polling continuously but polling just a tiny and predictible moment in time. $ : tick , the tick number since the clock started. $.p : phase , a number between 0 and your c.ppqn . $.m : measure , the measure since the clock started. @swim def number ( d = 0.5 , i = 0 ): print ( P ( '$, $.m, $.p' )) . out ( i ) again ( number , d = 0.5 , i = i + 1 ) Some other number tokens are absolute-time dependant. They are mostly used for long-running sequences and/or for introducing a random factor in the result of the expression. You will notice that they are prefixed by $ . @swim def random ( d = 0.5 , i = 0 ): print ( P ( 'T.U, T.Y, T.M, T.D, T.h, T.m, T.s, T.\u00b5' , i )) again ( random , d = 0.5 , i = i + 1 ) T.U : Unix Time, the current Unix Time. T.Y : year, the current year. T.M : month, the current month. T.D : day, the current day. T.h : hour, the current hour. T.m : minute, the current minute. T.s : second, the current second. T.\u00b5 : microsecond, the current microsecond.","title":"a1) Time-dependant numbers"},{"location":"documentation/sardinopedia/pattern_language/#a2-random-numbers","text":"You can write random numbers by using the letter r . By default, r will return a floating point number between 0.0 and 1.0 but it will be casted to integer if it makes more sense in that context ( e.g. sample:r*8 ). This is not the only way to generate a random number. For instance, r and 0.0~1.0 yield a similar result. Redundancy is good when working with a programming language!","title":"a2) Random numbers"},{"location":"documentation/sardinopedia/pattern_language/#a3-patterns-out-of-time","text":"@swim def random ( d = 0.5 , i = 0 ): S ( 'cp' , speed = '$%20' ) . out ( i ) again ( random , d = 0.5 , i = i + 1 ) Timed tokens make good low frequency oscillators , ramps or oscillating patterns. Playing with time tokens using modulos or the sin() , cos() or tan() functions is a great way to get generative results out of a predictible sequence. It is very important to practice doing this, especially if you are planning to use fast swimming functions . The faster you recurse, the better your timing resolution. You can start to enter into the realm of signal-like patterns that can be particularly good for generating fluid patterns.","title":"a3) Patterns out of time"},{"location":"documentation/sardinopedia/pattern_language/#b-notes","text":"@swim def notes ( d = 0.5 , i = 0 ): S ( 'pluck' , midinote = 'C5,D5,E5,F5,G5' ) . out ( i ) again ( notes , d = 0.5 , i = i + 1 ) Notes are one of the primitives you can use in patterns. Notes will always be converted to some MIDI value (an integer value between 0 and 127 ). Notes will be converted to some MIDI value used by SuperDirt . If you need more precision, speak in hertzs ( freq=402.230239 ). Notes are numbers too (!!). You can do math on them if you wish to. The syntax to write notes is the following: 1) [MANDATORY] capital letter indicating the note name: C , D , E , F , G , A , B . Sardine also supports the french notation system, so you can write Do, R\u00e9, Mi, Fa, Sol, La, Si if it feels more natural to you :) 2) [FACULTATIVE] flat or sharp: # , b . 3) [FACULTATIVE] octave number: 0 .. 9 . Of course, if you are a robot, you might prefer to speak in numbers. Because notes are turned into numbers, you can do this and Sardine will not complain. It can be particularly useful to generate custom voicings or weirdly shaped chords that you want to transpose and invert around: <([0,4,7,9,10,11]+50)^1> .","title":"B) Notes"},{"location":"documentation/sardinopedia/pattern_language/#b1-note-qualifiers","text":"@swim def notes ( d = 0.5 , i = 0 ): S ( 'pluck' , midinote = 'C5@penta' ) . out ( i ) again ( notes , d = 0.5 , i = i + 1 ) You can use the @ operator to qualify a note (or a number?). This will turn a note into a collection of notes / structure based on the targetted note. C@penta will summon a major pentatonic scale based on the middle C note: [60, 62, 64, 67, 69] . Be careful while using them as they will instantly turn a single token into a list of x tokens. You might want to filter part of a qualifiers note collection. You will soon find out that it can be cumbersome to summon a long list of notes from the realm of oblivion. You will have to learn techniques to get better at summoning the exact materials you want and some processing by using functions might be needed to get a better result. Writing your patterns by hand is also an option if you are able to think and write down precise harmonic / melodic materials. Check out functions like filt() or quant() . Take note that the following list is not always perfectly up to date. Moreover, it can be particularly tricky for you to remember how I named some of the structures: qualifiers = { ########## # Chords # ########## \"dim\" : [ 0 , 3 , 6 , 12 ], \"dim9\" : [ 0 , 3 , 6 , 9 , 14 ], \"hdim7\" : [ 0 , 3 , 6 , 10 ], \"hdim9\" : [ 0 , 3 , 6 , 10 , 14 ], \"hdimb9\" : [ 0 , 3 , 6 , 10 , 13 ], \"dim7\" : [ 0 , 3 , 6 , 9 ], \"aug\" : [ 0 , 4 , 8 , 12 ], \"augMaj7\" : [ 0 , 4 , 8 , 11 ], \"aug7\" : [ 0 , 4 , 8 , 10 ], \"aug9\" : [ 0 , 4 , 10 , 14 ], \"maj\" : [ 0 , 4 , 7 , 12 ], \"maj7\" : [ 0 , 4 , 7 , 11 ], \"maj9\" : [ 0 , 4 , 11 , 14 ], \"minmaj7\" : [ 0 , 3 , 7 , 11 ], \"five\" : [ 0 , 7 , 12 ], \"six\" : [ 0 , 4 , 7 , 9 ], \"seven\" : [ 0 , 4 , 7 , 10 ], \"nine\" : [ 0 , 4 , 10 , 14 ], \"b9\" : [ 0 , 4 , 10 , 13 ], \"mM9\" : [ 0 , 3 , 11 , 14 ], \"min\" : [ 0 , 3 , 7 , 12 ], \"min7\" : [ 0 , 3 , 7 , 10 ], \"min9\" : [ 0 , 3 , 10 , 14 ], \"sus4\" : [ 0 , 5 , 7 , 12 ], \"sus2\" : [ 0 , 2 , 7 , 12 ], \"b5\" : [ 0 , 4 , 6 , 12 ], \"mb5\" : [ 0 , 3 , 6 , 12 ], ########## # Scales # ########## \"major\" : [ 0 , 2 , 4 , 5 , 7 , 9 , 11 ], \"minor\" : [ 0 , 2 , 3 , 5 , 7 , 8 , 10 ], \"hminor\" : [ 0 , 2 , 3 , 5 , 7 , 8 , 11 ], \"vminor\" : [ 0 , 2 , 3 , 5 , 7 , 8 , 10 ], \"penta\" : [ 0 , 2 , 4 , 7 , 9 ], \"acoustic\" : [ 0 , 2 , 4 , 6 , 7 , 9 , 10 ], \"aeolian\" : [ 0 , 2 , 3 , 5 , 7 , 8 , 10 ], \"algerian\" : [ 0 , 2 , 3 , 6 , 7 , 9 , 11 , 12 , 14 , 15 , 17 ], \"superlocrian\" : [ 0 , 1 , 3 , 4 , 6 , 8 , 10 ], \"augmented\" : [ 0 , 3 , 4 , 7 , 8 , 11 ], \"bebop\" : [ 0 , 2 , 4 , 5 , 7 , 9 , 10 , 11 ], \"blues\" : [ 0 , 3 , 5 , 6 , 7 , 10 ], \"chromatic\" : [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ], \"dorian\" : [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ], \"doubleharmonic\" : [ 0 , 1 , 4 , 5 , 8 , 11 ], \"enigmatic\" : [ 0 , 1 , 4 , 6 , 8 , 10 , 11 ], \"flamenco\" : [ 0 , 1 , 4 , 5 , 7 , 8 , 11 ], \"gypsy\" : [ 0 , 2 , 3 , 6 , 7 , 8 , 10 ], \"halfdim\" : [ 0 , 2 , 3 , 5 , 6 , 8 , 10 ], \"harmmajor\" : [ 0 , 2 , 4 , 5 , 7 , 8 , 11 ], \"harmminor\" : [ 0 , 2 , 3 , 5 , 7 , 8 , 11 ], \"hirajoshi\" : [ 0 , 4 , 6 , 7 , 11 ], \"hungarianminor\" : [ 0 , 2 , 3 , 6 , 7 , 8 , 11 ], \"hungarianmajor\" : [ 0 , 3 , 4 , 6 , 7 , 9 , 10 ], \"in\" : [ 0 , 1 , 5 , 7 , 8 ], \"insen\" : [ 0 , 1 , 5 , 7 , 10 ], \"ionian\" : [ 0 , 2 , 4 , 5 , 7 , 9 , 11 ], \"istrian\" : [ 0 , 1 , 3 , 4 , 6 , 7 ], \"iwato\" : [ 0 , 1 , 5 , 6 , 10 ], \"locrian\" : [ 0 , 1 , 3 , 5 , 6 , 8 , 10 ], \"lydianaug\" : [ 0 , 2 , 4 , 6 , 8 , 9 , 11 ], \"lydian\" : [ 0 , 2 , 4 , 5 , 7 , 8 , 9 , 11 ], \"majorlocrian\" : [ 0 , 2 , 4 , 5 , 6 , 8 , 10 ], \"majorpenta\" : [ 0 , 2 , 4 , 7 , 9 ], \"minorpenta\" : [ 0 , 3 , 5 , 7 , 10 ], \"melominup\" : [ 0 , 2 , 3 , 5 , 7 , 9 , 11 ], \"melomindown\" : [ 0 , 2 , 3 , 5 , 7 , 8 , 10 ], \"mixolydian\" : [ 0 , 2 , 4 , 5 , 7 , 9 , 10 ], \"neapolitan\" : [ 0 , 1 , 3 , 5 , 7 , 8 , 11 ], \"octatonic\" : [ 0 , 2 , 3 , 5 , 6 , 8 , 9 , 11 ], \"octatonic2\" : [ 0 , 1 , 3 , 4 , 6 , 7 , 9 , 10 ], \"persian\" : [ 0 , 1 , 4 , 5 , 6 , 8 , 11 ], \"phrygian\" : [ 0 , 1 , 4 , 5 , 7 , 8 , 10 ], \"prometheus\" : [ 0 , 2 , 4 , 6 , 9 , 10 ], \"harmonics\" : [ 0 , 3 , 4 , 5 , 7 , 9 ], \"tritone\" : [ 0 , 1 , 4 , 6 , 7 , 10 ], \"ukrainian\" : [ 0 , 2 , 3 , 6 , 7 , 9 , 10 ], \"whole\" : [ 0 , 2 , 4 , 6 , 8 , 10 ], \"yo\" : [ 0 , 3 , 5 , 7 , 10 ], \"symetrical\" : [ 0 , 1 , 2 , 6 , 7 , 10 ], \"symetrical2\" : [ 0 , 2 , 3 , 6 , 8 , 10 ], \"messiaen1\" : [ 0 , 2 , 4 , 6 , 8 , 10 ], \"messiaen2\" : [ 0 , 1 , 3 , 4 , 6 , 7 , 9 , 10 ], \"messiaen3\" : [ 0 , 2 , 3 , 4 , 6 , 7 , 8 , 10 , 11 ], \"messiaen4\" : [ 0 , 1 , 2 , 4 , 6 , 7 , 8 , 11 ], \"messiaen5\" : [ 0 , 1 , 5 , 6 , 7 , 11 ], \"messiaen6\" : [ 0 , 2 , 4 , 5 , 6 , 8 ], \"messiaen7\" : [ 0 , 1 , 2 , 3 , 5 , 6 , 7 , 8 , 9 , 11 ], ############## # Structures # ############## \"fourths\" : [ 0 , 4 , 10 , 15 , 20 ], \"fifths\" : [ 0 , 7 , 14 , 21 , 28 ], \"sixths\" : [ 0 , 9 , 17 , 26 , 35 ], \"thirds\" : [ 0 , 4 , 8 , 12 ], \"octaves\" : [ 0 , 12 , 24 , 36 , 48 ], }","title":"b1) Note qualifiers"},{"location":"documentation/sardinopedia/pattern_language/#b2-note-modifiers","text":"@swim def notes ( d = 0.5 , i = 0 ): S ( 'pluck' , midinote = 'disco(C5@penta)' . out ( i ) again ( notes , d = 0.5 , i = i + 1 ) Functions can be used to further refine the effect of a modifier. There is a long list of functions that you can apply, such as disco() or adisco() as shown in the preceding example. If you ever wonder about the list of possible functions, refer to the Sardinopedia or enter any function name. If the function name is wrong, the list of possible functions will be printed out in the terminal.","title":"b2) Note modifiers"},{"location":"documentation/sardinopedia/pattern_language/#b3-chord-collection-inversion","text":"@swim def notes ( d = 0.5 , i = 0 ): S ( 'pluck' , midinote = 'disco(C5@maj7^4)' . out ( i ) again ( notes , d = 0.5 , i = i + 1 ) You can write chord inversions using the ^ syntax. It will accept any valid expression like ^1~5 . You can also feed negative numbers for inverting a chord downwards. Chord inversions are not only for chords but they also work on lists, which means that you can write custom chords and transpose them up or down :)","title":"b3) Chord / Collection inversion"},{"location":"documentation/sardinopedia/pattern_language/#b4-mathematics-on-notes","text":"@swim def notes ( d = 0.5 , i = 0 ): S ( 'pluck' , midinote = 'disco(braid(C5+0|4|8@penta' ))) . out ( i ) again ( notes , d = 0.5 , i = i + 1 ) You can use arithmetic operators on notes like if they were a regular number. That's because they are really just numbers! Random and time-dependant numbers are numbers too. Notes are numbers too so you can add a note to a note even if it doesn't really make sense. It will also not probably sound very good because notes are clamped in the range from 0 to 127 .","title":"b4) Mathematics on notes"},{"location":"documentation/sardinopedia/pattern_language/#b5-polyphony","text":"","title":"b5) Polyphony"},{"location":"documentation/sardinopedia/pattern_language/#note-polyphony","text":"@swim def poly ( d = 0.5 , i = 0 ): S ( '<[superpiano]>' , cutoff = 500 , midinote = '<D@maj9>, <G@maj7^0>, <D@maj9>, <G@dim7^1>' ) . out ( i , 2 , 0.25 ) a ( poly , d = P ( '0.5!4, 0.25!2' , i ), i = i + 1 ) You can use the < and > delimiters to make parts of your pattern polyphonic. You will soon notice that there are multiple types of polyphony available but the most notable of all, demonstrated in the example above, is the note polyphony . It allows you to superpose multiple note events in your patterns just like you expected. However, Sardine allows you to deal with polyphony in more unexpected ways. There a few rules to understand about polyphony and polyphonic messages. These rules can sound quite counter-intuitive if you think about it in a traditional way. The size of a polyphonic event -- meaning the number of messages sent for one occurence of an event -- is equal to the length of the largest polyphonic pattern you declared. In the first example, we have a 4-5 note polyphony. Every polyphonic element from our pattern is a major 9 or 7 chord ( e.g [62, 66, 69, 73, 76] ). It means that if you have a polyphony of 2 somewhere and a polyphony of 4 elsewhere, your first polyphony will be distributed over the second one: 1) [1,2,3,4] 2) [0,1] RESULT: 1) [1,2,3,4] 2) [0,1,0,1] | | | | POLYPHONY @swim def poly ( d = 0.5 , i = 0 ): S ( '<[bd, superpiano]>' , cutoff = 500 , midinote = '<D@maj9>, <G@maj7^0>, <D@maj9>, <G@dim7^1>' ) . out ( i , 2 , 0.25 ) a ( poly , d = P ( '0.5!4, 0.25!2' , i ), i = i + 1 ) To illustrate the preceding rule we just talked about, here is a truly bizarre example. Half of our chord is played by a tuned bassdrum, the other half by a piano. Even though this may look odd, this is fully compliant with how parameters are handled by Sardine . We have two clear alternations, one between the superpiano and bd sound sets, the other between the four or five values that form our chords. It is then natural that half of our polyphony will be composed from a tuned bassdrum and the remaining half from a tuned piano. Once you get use to this novel way of thinking about polyphonic patterns, you will see that it opens up some space for interesting polyphonic interactions between sounds :) It is currently not possible to limit the number of voices generated by an event. Be careful! It is quite easy to go from some easy and sparse chords to black MIDI!","title":"Note polyphony"},{"location":"documentation/sardinopedia/pattern_language/#parametric-polyphony","text":"@swim def poly ( d = 0.5 , i = 0 ): S ( 'drum:[1,6]' , speed = '<[1,clamp(r, 0.1, 1)]>, <[2,1.9]>' ) . out ( i , 3 ) S ( 'drum:2' , cutoff = '<[500:2000,500]*sin($ %r *80/40)*10>' ) . out ( i , 2 ) S ( 'bd' , shape = 0.5 ) . out ( i , 4 ) a ( poly , d = 0.5 / 2 , i = i + 1 ) Everything can become polyphonic. Just wrap anything between < and > and you will return x events, one for each value. It allows you to be very creative with patterns.","title":"Parametric polyphony"},{"location":"documentation/sardinopedia/pattern_language/#c-names","text":"@swim def names ( d = 0.5 , i = 0 ): S ( 'bd, pluck, bd, pluck:2+4' ) . out ( i ) again ( names , d = 0.5 , i = i + 1 ) You are using name patterns since you first started to read the Sardinopedia ! A single letter (if it's not already a note name) can be considered as a name. Be careful! There are a few hidden rules for names. Names can be one letter long but some letters are already taken by some parts of the language (such as r ). Names cannot begin with a number. It is also forbidden to use any symbol inside your names.","title":"C)\u00a0Names"},{"location":"documentation/sardinopedia/pattern_language/#d-addresses","text":"O ( osc_client , \"an/address, another/address\" , value = 1 , other_value = 2 ) . out () Addresses are just like names except that they can contain a / separator just like any other typical OSC address out there. They are not really distinct from a name. The difference is only conceptual and in the usage of your strings.","title":"D)\u00a0Addresses"},{"location":"documentation/sardinopedia/pattern_language/#ii-lists-and-collections","text":"The Sardine pattern notation is built around the idea of having multiple ways to deal with linear lists and collections. The basic arithmetic syntax and most operators work on single tokens but will also work on lists . It means that you can write expressions such as : [ 0 , 1 , 2 , 3 ] % 8 [ 0 , 2 , 4 , 5 ] * [ 4 , 5 ] [ 1 : 8 , 0.1 ] & [ 2 , 9 ] [ 0 , 2 , 4 , 5 , 9 , 10 , 12 , 14 ] ! 2 [ 0 , 2 , 4 , 5 , 9 , 10 , 12 , 14 ] !! 4 There are a few special operators that are only available when you deal with lists. This is something you will get familiar with by trying. You will see that most things work while some will not yield the result you expect.","title":"II - Lists and Collections"},{"location":"documentation/sardinopedia/pattern_language/#a-slicing-and-indexing","text":"@swim def test_slice ( d = 0.5 , i = 0 ): S ( 'pluck:19' , legato = 0.2 , midinote = '([60,63,67,69, 71]&[i.i, i.i + 8])^(1~8)' ) . out ( i ) a ( test_slice , d = 0.125 , i = i + 1 ) You can get a slice or just one value from a list by using the special & operator. It will work with any list on the right side of the operator but it will only take the first and second value of it no matter what to compose a slice. The index value can be infinite because the index is looping on the list. You can feed a random number generator and get something out. On the down side, it can become quite complex to write very fast, so be careful with it: @swim def test_slice ( d = 0.5 , i = 0 ): S ( 'pluck:19' , legato = 0.2 , midinote = '[60,62, 63,67, 69, 71]^(1~5)&[r, r*4]' ) . out ( i ) a ( test_slice , d = 0.125 , i = i + 1 )","title":"A) Slicing and indexing"},{"location":"documentation/sardinopedia/pattern_language/#b-extend","text":"@swim def test_extend ( d = 0.5 , i = 0 ): S ( 'pluck:19' , legato = 0.2 , midinote = '[60,62]!2' ) . out ( i ) a ( test_extend , d = 0.125 , i = i + 1 ) Just like with numbers, names and addresses, you can extend a list by calling the ! operator on it. It will repeat the list x times.","title":"B) Extend"},{"location":"documentation/sardinopedia/pattern_language/#c-extend-repeat","text":"@swim def test_extend_repeat ( d = 0.5 , i = 0 ): S ( 'pluck:19' , legato = 0.2 , midinote = '[60,62,63]!!3' ) . out ( i ) #note the repetition of values within the list a ( test_extend_repeat , d = 0.125 , i = i + 1 ) The variant !! now makes sense. It allows you to repeat each individual value in a list x times.","title":"C) Extend-repeat"},{"location":"documentation/sardinopedia/pattern_language/#iii-operators","text":"","title":"III - Operators"},{"location":"documentation/sardinopedia/pattern_language/#a-choice","text":"@swim def choosing_stuff ( d = 0.5 , i = 0 ): S ( 'bd|pluck' , speed = '1|2' ) . out ( i ) again ( choosing_stuff , d = 0.5 , i = i + 1 ) The pipe operator | can be used on anything to make a 50/50% choice between two tokens. You can also chain them: 1|2|3|4 . The behavior of chaining multiple choice operators has not been clearly defined. The distribution might not be the one you expect.","title":"A) Choice"},{"location":"documentation/sardinopedia/pattern_language/#b-ranges","text":"@swim def ranges ( d = 0.5 , i = 0 ): S ( 'pluck|jvbass' , speed = '1~5' ) . out ( i ) again ( ranges , d = 0.5 , i = i + 1 ) If you want to generate a number in the range x to y included, you can use the ~ operator. It spits an integer if you are using integers as boundaries but it will spit out a floating point number if you are using floating point numbers as boundaries. If you use an integer on one side and a floating point number on the other side, a floating point number will be returned. It can be used as an alternative to the r token for generating random numbers.","title":"B) Ranges"},{"location":"documentation/sardinopedia/pattern_language/#c-ramps","text":"@swim def ramps ( d = 0.5 , i = 0 ): S ( 'amencutup:[0:10]' , room = '[0:1,0.1]' , cutoff = '[1:10]*100' ) . out ( i ) again ( ramps , d = 0.5 , i = i + 1 ) You can generate ramps of integers using the [1:10] syntax. This works just like Python 's range function. Well, almost... it's way better! You can generate descending ramps easily: [10:1] . You can also generate ascending ramps of floating point numbers by precising a step other than 1 : [1:10,0.5] . Of course, this also works the other way around :)","title":"C) Ramps"},{"location":"documentation/sardinopedia/pattern_language/#d-repeat","text":"@swim def repeat_stuff ( d = 0.5 , i = 0 ): S ( 'pluck|jvbass' , speed = '1:2' , midinote = 'C4!4, E4!3, E5, G4!4' ) . out ( i ) again ( repeat_stuff , d = 0.5 , i = i + 1 ) The ! operator inspired by TidalCycles is used to denote the repetition of a value. You can also sometimes use the !! operator from the same family. This operator is a bit different, because it is supposed to be used on lists. You can do maths on lists as well with Sardine , but this will be detailed in a section later on.","title":"D) Repeat"},{"location":"documentation/sardinopedia/pattern_language/#e-silence","text":"@swim def silence_demo ( d = 0.5 , i = 0 ): S ( 'bd,...' ) . out ( i , div = 1 ) S ( 'hh,., hh,..' ) . out ( i , div = 1 ) a ( silence_demo , d = 1 / 8 , i = i + 1 ) You can use a dot ( . ) inside any pattern to indicate a silence. Silence is a very important and complex topic. Adding silences is a great way to generate interesting patterns. Silences are different for each sender because silence doesn't have the same meaning for a sampler, a MIDI output or an OSC output ( S() , M() , O() ): S() : a silence is the absence of a sample. The event will be skipped. M() : a silence is the absence of a note. The event will be skipped. O() : a silence is the absence of an address. The event will be skipped. There is also the interesting case of what I like to call 'parametric silences' . Take a look at the following example: @swim def silence_demo ( d = 0.5 , i = 0 ): S ( 'sitar' , legato = '0.5' , speed = '[1:4], .!8' ) . out ( i , div = 1 ) a ( silence_demo , d = 1 / 8 , i = i + 1 ) We always have a sample here. There is no real silence but we have still have some silences included in the speed subpattern. It also has an effect. In the absence of a value for that silence, Sardine will backtrack and search the last value that could have been generated by the pattern. The result of the speed parameter will then be [1,2,3,4,8,8,8,8,8,8,8,8] . For people familiar with modular synthesis, this is pretty much equivalent to a sample & hold mechanism. It is impossible to write a parametric silence composed only of silences. It doesn't mean anything to provide a value and actually not providing it.","title":"E) Silence"},{"location":"documentation/sardinopedia/pattern_language/#iv-amphibian-variables","text":"","title":"IV - Amphibian variables"},{"location":"documentation/sardinopedia/pattern_language/#a-amphibian-variables","text":"v . s = 60 # this is an amphibian variable @swim def fun (): # Calling it and setting it to v.s + 5 M ( note = 'v.s = v.s + 5' ) . out () if random () > 0.8 : v . s = 60 # resetting so it doesn't go too high again ( fun ) There is a group of variables called amphibian variables that are both valid inside and outside the pattern notation. They are defined by v followed by a letter from the alphabet (uppercase or lowercase) : v.a , v.A , v.Z , v.j . These variables can be freely manipulated from the Python side or from the pattern side. They are totally transparent. @swim def fun ( d = 0.25 ): # Now having fun with it M ( note = 'v.s = v.s + 5|2' ) . out () # more fun if random () > 0.8 : v . s = 50 again ( fun , d = 0.25 ) You can use them to leverage Python or the pattern syntax for what they do best: patterning or dealing with complex algorithmic transformations. Having them both available makes the pattern syntax even more expressive. There is a finite list of actions you can perform on amphibian variables : using them (just by calling them) setting them ( v.i = 5 ) resetting them to 0 ( v.i.reset )","title":"A) Amphibian variables"},{"location":"documentation/sardinopedia/pattern_language/#b-amphibian-iterators","text":"@swim def amphi_iter ( d = 0.25 ): S ( 'amencutup:[1:10]' ) . out ( i . i ) if random () > 0.8 : i . i = 0 a ( amphi_iter , d = 0.25 ) Similarly to amphibian variables , there is a thing called amphibian iterators that are valid on both sides. They are defined by i followed by a letter from the alphabet (uppercase or lowercase) : i.a , i.A , i.Z , i.j . They can be use as substitutes for your regular manual recursive iterators. In the example above, I am using an amphibian iterator to summon a breakbeat. @swim def amphi_iter ( d = 0.25 ): S ( 'amencutup:[1:10]' , speed = '1|2|i.i=0' ) . out ( i . i ) a ( amphi_iter , d = 0.25 ) These iterators can be reset or set on the pattern side! @swim def amphi_iter ( d = 0.25 ): if random () > 0.8 : i . i = [ 1 , 5 ] else : i . i = [ 1 , 2 ] S ( 'amencutup:[1:10]' , speed = 'i.v|i.v=[1,2]' ) . out ( i . i ) a ( amphi_iter , d = 0.25 ) Similarly, you can define the step value between each value by providing a list of two numbers. This is valid on both sides.","title":"B) Amphibian iterators"},{"location":"documentation/sardinopedia/pattern_language/#v-the-function-library","text":"Sardine pattern notation now comes with a function library. These are functions that should be used directly in the pattern notation to alter a list or a pattern you are working on. They can take basically any input but you will soon figure that some are more specialised than others. This is the part of the language that is the more subject to changes in upcoming versions. That's why I am only talking about it now, at the bottom of a fairly long page. I want to explore how far you can go by introducing functional concepts to handle linear sequences. So far, only functions are available. The next step will be to introduce high-order functions and to build a small set of functional operations to pattern functions themselves. Only then will I be happy. I will base myself on that work to write a decent and complex function library.","title":"V - The Function Library"},{"location":"documentation/sardinopedia/pattern_language/#a-sinus-cosinus-tangent","text":"sin(x) : sinus of input (single tokens or lists). Classic mathematical sinus function. cos(x) : cosinus of input (single tokens or lists). Classic mathematical cosinus function. tan(x) : tangent of input (single tokens or lists). Classic mathematical tangent function.","title":"A) Sinus, Cosinus, Tangent"},{"location":"documentation/sardinopedia/pattern_language/#b-scaling-measuring","text":"abs(x) : Absolute value. max(x) : Maximum value of list or token itself. min(x) : Minimum value of list or token itself. mean(x) : Mean of list or token itself. scale(z, x, y, x', y') : Bring a value z from range x-y to range x'-y' . clamp(x, y, z) : Clamp function, limit a value x to the minimum y to the maximum z .","title":"B) Scaling, measuring"},{"location":"documentation/sardinopedia/pattern_language/#c-reversal-shuffling","text":"rev(x) : Reverse a list. shuf(x) : Shuffle a list. pal(x) : palindrome of list. apal(x) : palindrome of list without repetition of last value.","title":"C) Reversal, shuffling"},{"location":"documentation/sardinopedia/pattern_language/#d-musical-functions","text":"disco(x) : Disco function. Every pair note down an octave. adisco(x) : Anti-disco function. Every pair note up an octave. bass(x) : The first note of list is down an octave (not very useful). sopr(x) : The last note of list is up an octave (not very useful). quant(x, y) : The last note of list is up an octave (not very useful).","title":"D) Musical functions"},{"location":"documentation/sardinopedia/pattern_language/#e-voice-leading","text":"These are two voice leading algorithms. These are only temporary until I figure out a better solution. They usually take a list of four note chords and arrange the voice to minimise movement. They work great but they are not the funniest thing you've ever seen. I'll work on them to make it better! voice(x) : four-note voice leading algorithm. Naive implementation. dmitri(x) : four-note voice leading algorithm. Algorithm inspired by Dmitri Tymoczko's work.","title":"E) Voice Leading"},{"location":"documentation/sardinopedia/pattern_language/#f-probabilities","text":"vanish(x, y) : Takes a list x , output only y % of values from it.","title":"F) Probabilities"},{"location":"documentation/sardinopedia/pattern_language/#g-booleans","text":"euclid(a, b, c, d) : Euclidian rhythm function applied to patterns. Takes a pattern a , a number of pulses b , a number of steps c and a rotation amount d . Outputs a pattern where the absence of a pulse is a silence and where pulses are values from the pattern. mask(x, y) : Generalisation of the euclidian rhythm algorithm. Works for any pattern and list of booleans.","title":"G) Booleans"},{"location":"documentation/sardinopedia/pattern_language/#h-insertion-and-rotation","text":"To be documented: in(x, y) : inp(x, y) : inrot(x, y) : inprot(x, y) :","title":"H) Insertion and rotation"},{"location":"documentation/sardinopedia/pattern_language/#i-filtering","text":"filt(x, y) :","title":"I) Filtering"},{"location":"documentation/sardinopedia/patterning/","text":"The importance of patterning By nature, swimming functions are repetitive. Almost everything you play with is falling into a time loop. Strict repetition can be come pretty boring after a while, and you need to find a way to define events that will gradually change in time, whether it is because they are sequence of events, random events, mutating events, etc... Sequencing and patterning is the big deal for live-coders . That's how they think about composition / improvisation, that's how they write interesting music by patterning synthesizers, audio samples, custom events and much more. If you go down the rabbit hole, you can also pattern your patterns. You can also pattern the functions altering your patterns. There is no limit to it, only what you are trying to define and play with. Thinking about music being composed with patterns, recursion and time loops is a deparature from the timeline / score model we are used to when thinking about music being written on scores or being recorded on tape. By patterning and thinking about loops, we enter into a different relationship with sound materials and the management of musical information. It would have been weird to design Sardine without taking into account the fact that patterning is as much needed as control over the temporal execution of code. Sardine is taking some inspiration from ORCA (Devine Lu Linvega), FoxDot (Ryan Kirkbride) and TidalCycles (Alex McLean and colaborators). These systems, among others, have been designed just like Sardine around the idea of patterning values in musical time. They all choose a different route to do so, and come up in exchange with interesting concepts about what an event or even what time is in a musical improvisation system. Sardine is proposing its own flavor of patterning that you will soon discover :) I - What are patterns? Sardine was designed with its own internal pattern language. This pattern language is not Python but a very specialised subset of it written from scratch. It basically came into existence because of my frustration with the inability to define custom operators and to really override the behavior of primitive data types. This language is interpreted on-the-fly when you play music with Sardine . Some objects such as senders are really good at interpreting patterns naturally. Some can be forced to take patterns as arguments. You don't really have to care about it and the syntax is so close to Python that it never feels like speaking multiple languages. Patterns are lists . Everything you write in a pattern form will eventually output a list. Just like lists, you can extract values by using an iterator . With Sardine , patterns are usually written as strings ( \"1,2,3,4\" , \"$.p%20+10\" , \"C@min7^1\" , etc...). Remember these few facts, all the rest is just the consequence of other mechanisms built around this behavior. There are multiple ways to extract values from a list: in order, by reading every element of the list one after the other. in reverse order, the same thing the other way around. randomly, by taking arbitrary values out of the list. sometimes in one direction, sometimes randomly, sometimes in reverse order? There are other things to take into consideration when time enters the game. How often should we extract values? Should we skip some elements if a time condition is met? What if the index is manipulated? What if you pattern all of this? As you can see, there is no end to this game and patterns can be sometimes boring, sometimes wonderful, sometimes totally chaotic to the point where it would be better not to have one, etc... It is a never-ending game of exploring them and finding the best techniques to create interesting variations. II - Observing patterns You can use the P() object to get a generic interface to Sardine patterns. This object can be used just anywhere you would like to see a pattern. It means that you can contaminate your Python functions or anything in your text buffer with them and see what comes out of it. As you will soon learn, the inverse is true. Python data can enter in the pattern realm as well. @swim def free ( d = 0.5 , i = 0 ): print ( P ( '1,2,3,4' , i )) again ( free , d = 0.5 , i = i + 1 ) In the example above, we are just using a swimming function to print the result of a pattern. It just goes through each element in sequence. That is because we are feeding an iterator to the P(pattern, iterator) function. Try to change that iterator . It'll already produce a variation on the pattern without even touching the pattern itself: @swim def free ( d = 0.5 , i = 0 ): print ( P ( '1,2,3,4' , i if random () > 0.5 else i + 2 )) again ( free , d = 0.5 , i = i + 1 ) The good thing with writing your own language is that you can write it to make some things more easy to accomplish. Why counting to 4 by writing down each number? We already have something to do it for us: @swim def free ( d = 0.5 , i = 0 ): print ( P ( '[1:4]' , i if random () > 0.5 else i + 2 )) again ( free , d = 0.5 , i = i + 1 ) Ok but now what if we would like to combine this pattern with the same one in the opposite direction? We can use functions from the FuncLibrary to do so: @swim def free ( d = 0.5 , i = 0 ): print ( P ( 'pal([1:4])' , i if random () > 0.5 else i + 2 )) again ( free , d = 0.5 , i = i + 1 ) You might sometimes feel a bit lost when writing complex patterns. As you'll soon discover, there are many features to the language. Always remember that you can print out patterns! You can observe them without making sound and you can even use them to do other tasks if you prefer. Sardine is cool for music playing but you can do much more with it. There are a few other things you can do to observe pattern in detail: turn the debug mode on with sardine-config . use the lang_debug() function if you want to see how patterns are composed (low-level). III - Patterns and senders It now all falls into place! We saw swimming functions , senders , and now patterns . These three features form the core of Sardine and you are now ready to understand all of it. String keyword arguments feeded to senders are patterns! These strings will be interpreted and replaced by lists internally to form the final message. Ok, but where is the iterator ? You can see it in the tail of your sender, the i letter in the example below. @swim def boom ( d = 0.5 , i = 0 ): S ( 'bd' , cutoff = 'r*2000' , speed = '1,2,3,4' ) . out ( i ) again ( boom , d = 0.5 , i = i + 1 ) Conceptually, senders are pattern sandwiches. It is a collection of lists sharing a common iterator . They all form a common event by merging together in a final message. The easiest way to deal with this is to have one and only one iterator but of course, if you don't like it that way, you can have multiple iterators in a single sender . @swim def boom ( d = 0.5 , i = 0 ): S ( 'bd' , cutoff = P ( '2000!4, 4000!2, 8000!3, 200~5000' , i + 2 ), speed = '1,2,3,4' ) . out ( i ) again ( boom , d = 0.5 , i = i + 1 ) It can even be more extreme than this but it all depends on what you are trying to achieve! You already saw that the tail method of your sender also have additional parameters that you can use to further refine the message composition. IV - Iterators are cool @swim def boom ( d = 0.5 , i = 0 ): S ( 'bd' , cutoff = P ( 'r*2000, 500, 1000' , i % 2 ), speed = '1, 2, 3, 4' ) . out ( randint ( 1 , 4 )) again ( boom , d = 0.5 , i = i + 1 ) You can be creative with iterators and easily generate semi-random sequences, drunk walks, reversed sequences, etc... Be sure to always have a few different iterators close by to morph your sequences really fast. I know that writing complex patterns is nice but they are nothing without good iterators.","title":"Patterns"},{"location":"documentation/sardinopedia/patterning/#the-importance-of-patterning","text":"By nature, swimming functions are repetitive. Almost everything you play with is falling into a time loop. Strict repetition can be come pretty boring after a while, and you need to find a way to define events that will gradually change in time, whether it is because they are sequence of events, random events, mutating events, etc... Sequencing and patterning is the big deal for live-coders . That's how they think about composition / improvisation, that's how they write interesting music by patterning synthesizers, audio samples, custom events and much more. If you go down the rabbit hole, you can also pattern your patterns. You can also pattern the functions altering your patterns. There is no limit to it, only what you are trying to define and play with. Thinking about music being composed with patterns, recursion and time loops is a deparature from the timeline / score model we are used to when thinking about music being written on scores or being recorded on tape. By patterning and thinking about loops, we enter into a different relationship with sound materials and the management of musical information. It would have been weird to design Sardine without taking into account the fact that patterning is as much needed as control over the temporal execution of code. Sardine is taking some inspiration from ORCA (Devine Lu Linvega), FoxDot (Ryan Kirkbride) and TidalCycles (Alex McLean and colaborators). These systems, among others, have been designed just like Sardine around the idea of patterning values in musical time. They all choose a different route to do so, and come up in exchange with interesting concepts about what an event or even what time is in a musical improvisation system. Sardine is proposing its own flavor of patterning that you will soon discover :)","title":"The importance of patterning"},{"location":"documentation/sardinopedia/patterning/#i-what-are-patterns","text":"Sardine was designed with its own internal pattern language. This pattern language is not Python but a very specialised subset of it written from scratch. It basically came into existence because of my frustration with the inability to define custom operators and to really override the behavior of primitive data types. This language is interpreted on-the-fly when you play music with Sardine . Some objects such as senders are really good at interpreting patterns naturally. Some can be forced to take patterns as arguments. You don't really have to care about it and the syntax is so close to Python that it never feels like speaking multiple languages. Patterns are lists . Everything you write in a pattern form will eventually output a list. Just like lists, you can extract values by using an iterator . With Sardine , patterns are usually written as strings ( \"1,2,3,4\" , \"$.p%20+10\" , \"C@min7^1\" , etc...). Remember these few facts, all the rest is just the consequence of other mechanisms built around this behavior. There are multiple ways to extract values from a list: in order, by reading every element of the list one after the other. in reverse order, the same thing the other way around. randomly, by taking arbitrary values out of the list. sometimes in one direction, sometimes randomly, sometimes in reverse order? There are other things to take into consideration when time enters the game. How often should we extract values? Should we skip some elements if a time condition is met? What if the index is manipulated? What if you pattern all of this? As you can see, there is no end to this game and patterns can be sometimes boring, sometimes wonderful, sometimes totally chaotic to the point where it would be better not to have one, etc... It is a never-ending game of exploring them and finding the best techniques to create interesting variations.","title":"I - What are patterns?"},{"location":"documentation/sardinopedia/patterning/#ii-observing-patterns","text":"You can use the P() object to get a generic interface to Sardine patterns. This object can be used just anywhere you would like to see a pattern. It means that you can contaminate your Python functions or anything in your text buffer with them and see what comes out of it. As you will soon learn, the inverse is true. Python data can enter in the pattern realm as well. @swim def free ( d = 0.5 , i = 0 ): print ( P ( '1,2,3,4' , i )) again ( free , d = 0.5 , i = i + 1 ) In the example above, we are just using a swimming function to print the result of a pattern. It just goes through each element in sequence. That is because we are feeding an iterator to the P(pattern, iterator) function. Try to change that iterator . It'll already produce a variation on the pattern without even touching the pattern itself: @swim def free ( d = 0.5 , i = 0 ): print ( P ( '1,2,3,4' , i if random () > 0.5 else i + 2 )) again ( free , d = 0.5 , i = i + 1 ) The good thing with writing your own language is that you can write it to make some things more easy to accomplish. Why counting to 4 by writing down each number? We already have something to do it for us: @swim def free ( d = 0.5 , i = 0 ): print ( P ( '[1:4]' , i if random () > 0.5 else i + 2 )) again ( free , d = 0.5 , i = i + 1 ) Ok but now what if we would like to combine this pattern with the same one in the opposite direction? We can use functions from the FuncLibrary to do so: @swim def free ( d = 0.5 , i = 0 ): print ( P ( 'pal([1:4])' , i if random () > 0.5 else i + 2 )) again ( free , d = 0.5 , i = i + 1 ) You might sometimes feel a bit lost when writing complex patterns. As you'll soon discover, there are many features to the language. Always remember that you can print out patterns! You can observe them without making sound and you can even use them to do other tasks if you prefer. Sardine is cool for music playing but you can do much more with it. There are a few other things you can do to observe pattern in detail: turn the debug mode on with sardine-config . use the lang_debug() function if you want to see how patterns are composed (low-level).","title":"II - Observing patterns"},{"location":"documentation/sardinopedia/patterning/#iii-patterns-and-senders","text":"It now all falls into place! We saw swimming functions , senders , and now patterns . These three features form the core of Sardine and you are now ready to understand all of it. String keyword arguments feeded to senders are patterns! These strings will be interpreted and replaced by lists internally to form the final message. Ok, but where is the iterator ? You can see it in the tail of your sender, the i letter in the example below. @swim def boom ( d = 0.5 , i = 0 ): S ( 'bd' , cutoff = 'r*2000' , speed = '1,2,3,4' ) . out ( i ) again ( boom , d = 0.5 , i = i + 1 ) Conceptually, senders are pattern sandwiches. It is a collection of lists sharing a common iterator . They all form a common event by merging together in a final message. The easiest way to deal with this is to have one and only one iterator but of course, if you don't like it that way, you can have multiple iterators in a single sender . @swim def boom ( d = 0.5 , i = 0 ): S ( 'bd' , cutoff = P ( '2000!4, 4000!2, 8000!3, 200~5000' , i + 2 ), speed = '1,2,3,4' ) . out ( i ) again ( boom , d = 0.5 , i = i + 1 ) It can even be more extreme than this but it all depends on what you are trying to achieve! You already saw that the tail method of your sender also have additional parameters that you can use to further refine the message composition.","title":"III - Patterns and senders"},{"location":"documentation/sardinopedia/patterning/#iv-iterators-are-cool","text":"@swim def boom ( d = 0.5 , i = 0 ): S ( 'bd' , cutoff = P ( 'r*2000, 500, 1000' , i % 2 ), speed = '1, 2, 3, 4' ) . out ( randint ( 1 , 4 )) again ( boom , d = 0.5 , i = i + 1 ) You can be creative with iterators and easily generate semi-random sequences, drunk walks, reversed sequences, etc... Be sure to always have a few different iterators close by to morph your sequences really fast. I know that writing complex patterns is nice but they are nothing without good iterators.","title":"IV - Iterators are cool"},{"location":"documentation/sardinopedia/rhythm/","text":"Rhythm Probability rhythm @swim def bd ( d = 0.5 ): if often (): S ( 'bd' ) . out () if sometimes (): S ( 'hh' ) . out () else : S ( 'pluck' ) . out () # condensed S ( 'sd' , trig = 1 if sometimes () else 0 ) . out () again ( bd , d = 0.5 ) Building rhythms based on chance that an event will happen. Rolling a dice. These small functions are borrowed from TidalCycles that is using them intensively in its very thorough patterning system. Binary rhythm @swim def bd ( d = 0.5 , i = 0 ): S ( 'bd' , trig = bin ( 20103 )) . out ( i ) again ( bd , d = 0.5 , i = i + 1 ) Using the binary representation of a number to build a rhythm. You don't need to know what the representation is to get an interesting rhythm out of it. Feed anything to the bin function and get something out! Euclidian rhythm @swim def bd ( d = 0.5 , i = 0 ): S ( 'bd:r*20' , trig = euclid ( 1 , 4 )) . out ( i ) S ( 'hh:r*20' , trig = euclid ( 6 , 8 )) . out ( i ) S ( 'sd:r*20' , trig = euclid ( 2 , 4 )) . out ( i ) again ( bd , d = 0.5 , i = i + 1 ) Building euclidian rhythms by using the trig argument. Note that this is not really an euclidian rhythm but it sure does look and feel like it. Trig allows you to skip an event. Shifting rhythm @swim def bd ( d = 0.5 , i = 0 ): S ( 'bd:r*20' , trig = euclid ( 1 , 4 )) . out ( i ) S ( 'hh:0~5' , trig = euclid ( 6 , 8 )) . out ( i ) S ( 'sd:$%20' , trig = euclid ( 2 , 4 )) . out ( i ) again ( bd , d = P ( '0.5!8, 0.25!4' , i ), i = i + 1 ) Pattern the recursion delay to get free rhythms! You can even skip playing with trig and just play with the recursion delay if you feel like it! Imperative rhythm @swim def zoom ( d = 0.5 , i = 0 ): S ( 'bd:r*20' ) . out ( i ) sleep ( 0.25 ) S ( 'hh:r*20' , trig = euclid ( 6 , 8 )) . out ( i ) sleep ( 0.125 ) S ( 'sd:r*20' , trig = euclid ( 2 , 4 )) . out ( i ) again ( zoom , d = 0.5 , i = i + 1 ) Create rhythm using the sleep() function. Fully compatible with everything else! It is usually a good idea to use sleep() after having composed something complex to slice time even more. Silence rhythms @swim def silence_rhythm ( d = 0.5 , i = 0 ): S ( 'bd' ) . out ( i , div = 4 ) S ( 'hh:2' ) . out ( i , div = 2 ) S ( 'drum:2+r*5' ) . out ( i , div = 3 ) a ( silence_rhythm , d = 1 / 8 , i = i + 1 ) Play with the div amount to generate interesting rhythms.","title":"Rhythm"},{"location":"documentation/sardinopedia/rhythm/#rhythm","text":"","title":"Rhythm"},{"location":"documentation/sardinopedia/rhythm/#probability-rhythm","text":"@swim def bd ( d = 0.5 ): if often (): S ( 'bd' ) . out () if sometimes (): S ( 'hh' ) . out () else : S ( 'pluck' ) . out () # condensed S ( 'sd' , trig = 1 if sometimes () else 0 ) . out () again ( bd , d = 0.5 ) Building rhythms based on chance that an event will happen. Rolling a dice. These small functions are borrowed from TidalCycles that is using them intensively in its very thorough patterning system.","title":"Probability rhythm"},{"location":"documentation/sardinopedia/rhythm/#binary-rhythm","text":"@swim def bd ( d = 0.5 , i = 0 ): S ( 'bd' , trig = bin ( 20103 )) . out ( i ) again ( bd , d = 0.5 , i = i + 1 ) Using the binary representation of a number to build a rhythm. You don't need to know what the representation is to get an interesting rhythm out of it. Feed anything to the bin function and get something out!","title":"Binary rhythm"},{"location":"documentation/sardinopedia/rhythm/#euclidian-rhythm","text":"@swim def bd ( d = 0.5 , i = 0 ): S ( 'bd:r*20' , trig = euclid ( 1 , 4 )) . out ( i ) S ( 'hh:r*20' , trig = euclid ( 6 , 8 )) . out ( i ) S ( 'sd:r*20' , trig = euclid ( 2 , 4 )) . out ( i ) again ( bd , d = 0.5 , i = i + 1 ) Building euclidian rhythms by using the trig argument. Note that this is not really an euclidian rhythm but it sure does look and feel like it. Trig allows you to skip an event.","title":"Euclidian rhythm"},{"location":"documentation/sardinopedia/rhythm/#shifting-rhythm","text":"@swim def bd ( d = 0.5 , i = 0 ): S ( 'bd:r*20' , trig = euclid ( 1 , 4 )) . out ( i ) S ( 'hh:0~5' , trig = euclid ( 6 , 8 )) . out ( i ) S ( 'sd:$%20' , trig = euclid ( 2 , 4 )) . out ( i ) again ( bd , d = P ( '0.5!8, 0.25!4' , i ), i = i + 1 ) Pattern the recursion delay to get free rhythms! You can even skip playing with trig and just play with the recursion delay if you feel like it!","title":"Shifting rhythm"},{"location":"documentation/sardinopedia/rhythm/#imperative-rhythm","text":"@swim def zoom ( d = 0.5 , i = 0 ): S ( 'bd:r*20' ) . out ( i ) sleep ( 0.25 ) S ( 'hh:r*20' , trig = euclid ( 6 , 8 )) . out ( i ) sleep ( 0.125 ) S ( 'sd:r*20' , trig = euclid ( 2 , 4 )) . out ( i ) again ( zoom , d = 0.5 , i = i + 1 ) Create rhythm using the sleep() function. Fully compatible with everything else! It is usually a good idea to use sleep() after having composed something complex to slice time even more.","title":"Imperative rhythm"},{"location":"documentation/sardinopedia/rhythm/#silence-rhythms","text":"@swim def silence_rhythm ( d = 0.5 , i = 0 ): S ( 'bd' ) . out ( i , div = 4 ) S ( 'hh:2' ) . out ( i , div = 2 ) S ( 'drum:2+r*5' ) . out ( i , div = 3 ) a ( silence_rhythm , d = 1 / 8 , i = i + 1 ) Play with the div amount to generate interesting rhythms.","title":"Silence rhythms"},{"location":"documentation/sardinopedia/sampling/","text":"Sampling is taken care of by SuperDirt but I don't think that an official documentation of the API exists outside of the documentation provided by libraries using it. So be it, here are some basics for you to get started :) Sampler basics @swim def hh ( d = 0.5 ): S ( 'hh' ) . out ( i ) again ( hh , d = 0.5 ) This will play the first file in the hh folder, loaded via SuperDirt . @swim def hh ( d = 0.5 ): S ( 'hh:1' ) . out ( i ) again ( hh , d = 0.5 ) This will play the second file, etc... Numbers wrap around, so you can't overflow and play a file that doesn't exist. It means that you can iterate freely on the sample number without fear. Sample playback speed @swim def hh ( d = 0.5 ): S ( 'jvbass:0' , speed = '1,2,3,4' ) . out ( i . i ) again ( hh , d = 0.5 ) = You can pitch samples up or down by changing the playback speed. 1 is the normal playback speed, 2 twice as fast and 0 will not play anything at all. You can play a file in reverse speed by inputting negative values such as -1 for backwards normal speed, etc... Beware of very low numbers close to 0 as they will be sometimes harder to hear but will still take memory to be played, especially if there is nothing to stop them. Sample playback volume @swim def loud ( d = 0.5 ): S ( 'bd' , speed = '1' , amp = 1 ) . out ( i . i ) again ( hh , d = 0.5 ) This bassdrum will be played very loud. The amp parameter will determine the volume of audio playback for a given sample. 0 equals to silence. 1 corresponds to full volume, with distortion of the audio signal being allowed for larger values. @swim def loud ( d = 0.5 ): S ( 'bd' , speed = '1' , gain = 1 ) . out ( i . i ) again ( hh , d = 0.5 ) Gain is slightly similar to amp . The difference lies in the scaling. While amp is defined as a value on a linear scale, gain is defined on an exponential scale. The higher you go, the more subtle the change. Folks from the TidalCycles documentation recommend a value between 0 and 1.5 for better use. Cutting/Stopping samples @swim def cutting ( d = 0.5 ): S ( 'jvbass:0' , legato = 0.1 ) . out ( i . i ) again ( cutting , d = 0.5 ) The legato parameter can be used to cut a sample hard after a given amount of time. It is a very useful parameter not to overlap sounds too much if you ever needed it. It can also be used a safety parameter for playing back long samples without loosing control over the stop time. @swim def cutting ( d = 0.5 ): S ( 'jvbass:0' , cut = 1 ) . out ( i . i ) again ( cutting , d = 0.5 ) The cut parameter will cut the previously playing sample if trigerred on the same orbit. This is just like legato except that the duration of the legato will depend on the time spent between two sounds. @swim def cutting ( d = 0.5 ): S ( 'jvbass:0' , sustain = 0.01 ) . out ( i . i ) again ( cutting , d = 0.5 ) The sustain value will determine the length of audio playback (in seconds). Sample position @swim def position ( d = 0.5 ): S ( 'fire' , speed = '1' , begin = 0.1 , end = 0.5 , amp = 0.5 ) . out ( i . i ) again ( position , d = 2 ) When playing long audio samples, you might want to scroll through the file, moving the playhead accross the file. You can use the begin and end parameters (from 0 to 1 ) to set the begin playback point and the end playback point. You can pattern the begin parameter with great expressive effect. Sample stretching @swim def streeeetch ( d = 0.5 ): S ( 'fire' , begin = 'r/2' , legato = 1 , amp = 0.5 , timescale = 2.7 ) . out () a ( streeeetch ) You can get some interesting effects by using the timescale parameter (between 0 and 3 recommended) for stretching a sample over a given amount of time. This will result in a more grainy sound. This is some sort of timestretching for audio samples. Higher values ( >3 ) for timescale work with more distortion to the sound. This can yield interesting results for more experimental sound.","title":"Sampling"},{"location":"documentation/sardinopedia/sampling/#sampler-basics","text":"@swim def hh ( d = 0.5 ): S ( 'hh' ) . out ( i ) again ( hh , d = 0.5 ) This will play the first file in the hh folder, loaded via SuperDirt . @swim def hh ( d = 0.5 ): S ( 'hh:1' ) . out ( i ) again ( hh , d = 0.5 ) This will play the second file, etc... Numbers wrap around, so you can't overflow and play a file that doesn't exist. It means that you can iterate freely on the sample number without fear.","title":"Sampler basics"},{"location":"documentation/sardinopedia/sampling/#sample-playback-speed","text":"@swim def hh ( d = 0.5 ): S ( 'jvbass:0' , speed = '1,2,3,4' ) . out ( i . i ) again ( hh , d = 0.5 ) = You can pitch samples up or down by changing the playback speed. 1 is the normal playback speed, 2 twice as fast and 0 will not play anything at all. You can play a file in reverse speed by inputting negative values such as -1 for backwards normal speed, etc... Beware of very low numbers close to 0 as they will be sometimes harder to hear but will still take memory to be played, especially if there is nothing to stop them.","title":"Sample playback speed"},{"location":"documentation/sardinopedia/sampling/#sample-playback-volume","text":"@swim def loud ( d = 0.5 ): S ( 'bd' , speed = '1' , amp = 1 ) . out ( i . i ) again ( hh , d = 0.5 ) This bassdrum will be played very loud. The amp parameter will determine the volume of audio playback for a given sample. 0 equals to silence. 1 corresponds to full volume, with distortion of the audio signal being allowed for larger values. @swim def loud ( d = 0.5 ): S ( 'bd' , speed = '1' , gain = 1 ) . out ( i . i ) again ( hh , d = 0.5 ) Gain is slightly similar to amp . The difference lies in the scaling. While amp is defined as a value on a linear scale, gain is defined on an exponential scale. The higher you go, the more subtle the change. Folks from the TidalCycles documentation recommend a value between 0 and 1.5 for better use.","title":"Sample playback volume"},{"location":"documentation/sardinopedia/sampling/#cuttingstopping-samples","text":"@swim def cutting ( d = 0.5 ): S ( 'jvbass:0' , legato = 0.1 ) . out ( i . i ) again ( cutting , d = 0.5 ) The legato parameter can be used to cut a sample hard after a given amount of time. It is a very useful parameter not to overlap sounds too much if you ever needed it. It can also be used a safety parameter for playing back long samples without loosing control over the stop time. @swim def cutting ( d = 0.5 ): S ( 'jvbass:0' , cut = 1 ) . out ( i . i ) again ( cutting , d = 0.5 ) The cut parameter will cut the previously playing sample if trigerred on the same orbit. This is just like legato except that the duration of the legato will depend on the time spent between two sounds. @swim def cutting ( d = 0.5 ): S ( 'jvbass:0' , sustain = 0.01 ) . out ( i . i ) again ( cutting , d = 0.5 ) The sustain value will determine the length of audio playback (in seconds).","title":"Cutting/Stopping samples"},{"location":"documentation/sardinopedia/sampling/#sample-position","text":"@swim def position ( d = 0.5 ): S ( 'fire' , speed = '1' , begin = 0.1 , end = 0.5 , amp = 0.5 ) . out ( i . i ) again ( position , d = 2 ) When playing long audio samples, you might want to scroll through the file, moving the playhead accross the file. You can use the begin and end parameters (from 0 to 1 ) to set the begin playback point and the end playback point. You can pattern the begin parameter with great expressive effect.","title":"Sample position"},{"location":"documentation/sardinopedia/sampling/#sample-stretching","text":"@swim def streeeetch ( d = 0.5 ): S ( 'fire' , begin = 'r/2' , legato = 1 , amp = 0.5 , timescale = 2.7 ) . out () a ( streeeetch ) You can get some interesting effects by using the timescale parameter (between 0 and 3 recommended) for stretching a sample over a given amount of time. This will result in a more grainy sound. This is some sort of timestretching for audio samples. Higher values ( >3 ) for timescale work with more distortion to the sound. This can yield interesting results for more experimental sound.","title":"Sample stretching"},{"location":"documentation/sardinopedia/senders/","text":"The second most important aspect of Sardine is the concept of Senders . Senders are the main objects used to communicate with the outside world. There are three basic senders : Sound Sender : play sounds/synths using SuperCollider and the SuperDirt engine. MIDI Sender : trigger/control MIDI capable software / hardware. OSC Sender : send or receive Open Sound Control messages. Naturally, people are thinking about adding more and more senders. Hopefully, Sardine will make integrating new senders easier as time goes by. For now, these three I/O tools cover most of the messages used by live-coders and algoravers . Python packages can be imported to deal with other things that Sardine is not yet covering. You can turn the software into an ASCII art patterner or hack your way around to deal with DMX-controlled lights. You will see that learning how to swim was kind of the big deal. Things will now be easier to learn. Senders and swimming functions are enough to already make pretty interesting music. The rest is just me sprinkling goodies all around :) I - Anatomy of Senders A Sender is an event generator . It describes one event. This event can mutate depending on multiple factors such as patterns, randomness, chance operations, clever Python string formatting, etc... A single sender can be arbitrarily long depending on the precision you want to give to each event. This object will only take one method : .out() . Wait? A long object, and a tail method? Does it ring a bell? It looks... just like a sardine. /`-._ /`-._ _/,.._/ _/,.._/ ,-' , `-:,.-') _ ,-' , `-:,.-') _ : S(...):'; _ { .out(_) : M(...):'; _ { .out(_) ... and more `-. `' _,.-\\`-.) + `-. `' _,.-\\`-.) + `\\\\``\\,.-' `\\\\``\\,.-' Writing the body Every sender ( M() , O() , S() ) is an object taking arguments and keyword arguments . Arguments are mandatory , and keyword arguments optional. These arguments will define your event: S ( 'bd' , speed = '[1:2,0.5]' , legato = 1 , shape = 0.5 ) # Heavy drumbass M ( note = 'C@min7^1' , dur = 2 , channel = 0 ) # Short MIDI chord You will have to learn what arguments each sender can receive. They all have a speciality. Despite the fact that they look and behave similarly, the event they describe is very different in nature depending on the type. Warning Note that Sardine is still missing some pieces. There is currently no way to easily pattern some very common MIDI messages such as control changes , program changes , etc... Don't worry! You can still pattern all of this very easily by doing cc(control=P('0,1,2',i), value=P('1~127')) . It's a just a bit more verbose compared to what it could be if ever I was feeling like adding this to the codebase! It will eventually happen, I promise! Precising the tail The tail of a sender is always the .out() method. Without it, no message is sent. We have already seen the tail in the swimming functions section. If you are here because of it, you've found the right place to look at! The .out() method takes three arguments: i ( int ): the iterator for patterning. Mandatory for the two other arguments to work properly. This iterator is the index of the values extracted from your linear list-like patterns (your arguments and keyword arguments ). How this index will be interpreted will depend on the next two arguments. div ( int ): a timing divisor . It is very much alike a modulo operation. If div=4 , the event will be emitted once every 4 iterations. The default is div=1 , where every event is a hit! Be careful not to set a div=1 on a very fast swimming function as it could result in catastrophic failure / horrible noises. There is no parachute out in the open sea. rate ( float ): a speed factor for iterating over pattern values. It will slow down or speed up the iteration speed, the speed at which the pattern values are indexed on. For the pattern 1, 2, 3 and a rate of 0.5 , the result will be perceptually similar to 1, 1, 2, 2, 3, 3 . I know, it doesn't make any sense written like so.. That's something you have to see represented differently. Take a look at tail arguments values. Notice how different values will produce different iteration speeds: Now, try exploring this idea using this dummy pattern: @swim def ocean_periodicity ( d = 0.5 , i = 0 ): S ( 'bd, hhh, sn, hhh' , speed = '1,2' , freq = 'r*800' ) . out ( i , 2 , 0.5 ) a ( ocean_periodicity , d = 0.5 , i = i + 1 ) Don't touch to the pattern itself, just change values in the .out() method. Try to be more familiar with it. You can change the recursion speed to notice more clearly how the pattern will evolve with time. Tips for writing Senders Python is extremely flexible and expressive. The language makes it a breeze to compose arguments and keyword arguments in very fun and creative ways. I don't even have to code anything to support this and I'm very grateful that the language takes care of everything for me! Let's take an example. You can for instance store parameters common to multiple messages in a list/dictionary before sticking them to your patterns using the * and ** idiom: params = { 'loud' : { 'amp' : 2 , 'shape' : 0.9 }, 'soft' : { 'amp' : 0.1 , 'legato' : 0.1 }} S ( 'bd' , ** params [ 'loud' ]) There is also a hidden benefit to separating the .out() method from the object initialisation. You can store events somewhere without having to send them immediately. : drumkit = { 'bass' : S ( 'bd' ), 'hat' : S ( 'hhh' ), 'snare' : S ( 'sn' )} drumkit [ 'bass' ] . out () These examples look very verbose, but try to imagine cases where they will save you from an even more verbose situation . It can happen very quickly when you try to play with many events at the same time, or when you will start imagining grouping sounds together or modifying multiple parameters in different events at the same time. II - The Sound Sender The Sound or SuperDirt sender is a sender specialised in talking with SuperCollider and more specifically with the sound engine used by TidalCycles . I'm using the synthesis / sampling backend written and supported by Julian Rohrhuber that many live-coders worldwide are also using. It is very stable, very flexible and highly-configurable. This sender is the most complex you will have to interact with and it is entirely optional if you wish to use Sardine only to sequence MIDI and OSC messages. If we dive into its architecture, we will soon find out that this sender is a specialised OSC sender that talks exclusively with SuperDirt using special timestamped messages. The body of the sender is always: S ( 'sound' , keyword = value_or_pattern , keyword2 = value_or_pattern ) The first argument defining the sound or synthesizer you are willing to trigger is not optional. Without it, you can be sure that the sender will crash because it cannot apply parameters to something that is not defined. The keyword parameters are the names of your SuperDirt parameters. It can be standard parameters, orbit parameters (audio bus) or parameters related to the synthesizer you are using. You will find more about this in the Reference section that is listing pretty much all of them! You will feel a bit lost at first but this is a case where you learn a lot by doing and from experience. Take a look at the following examples. Simple Bassdrum @swim def bd ( d = 0.5 ): S ( 'bd' ) . out () again ( bd , d = 0.5 ) A simple bassdrum playing on every half-beat. This is the most basic sound-making function you can write. Complex Bassdrum @swim def bd ( d = 0.5 ): S ( 'bd' , speed = 'r*4' , legato = 'r' , cutoff = '100+0~4000' ) . out () again ( bd , d = 0.25 ) A simple bassdrum but some parameters have been tweaked to add some randomness to the result. See how patterns can be used to make your keyword arguments more dynamic. The additional parameters are : speed will reverse (<0), slow (0-1), or accelerate the sample (>1) by altering the playback speed. The r token provides randomization between 0.0 and 1.0 ( float ). legato defines the maximum duration of the sample before cutting it, here randomized in the 0 to 1 range. cutoff will attenuate some frequencies. This is the cutoff frequency of a lowpass filter that shuts down frequencies higher to the frequency cutoff. The cutoff frequency is guaranteed to be at least 100 plus a certain amount between 0 and 4000 . Simple Breakbeat @swim def bd ( d = 0.5 , i = 0 ): S ( 'amencutup:0~20' ) . out ( i ) again ( bd , d = 0.25 , i = i + 1 ) Picking a random sample in a folder containing slices of the classic amen break . You could have a successful career doing this in front of audiences. Once again, the magic happens with the sample:r*X notation, which randomizes which sample is read on each execution, making it unpredictable. Sample sequencing @swim def bd ( d = 0.5 , i = 0 ): S ( 'bd,hh,sn,hh' ) . out ( i ) again ( bd , d = 0.5 , i = i + 1 ) Your classic four-on-the-floor written on one line. One sound is played after the other. All arguments and keyword arguments can be patterned. Piling up / Polyphony @swim def pluck ( d = 0.5 , i = 0 ): S ( 'pluck' ) . out ( i ) S ( 'pluck:1' ) . out ( i ) S ( 'pluck:2' ) . out ( i ) S ( 'pluck:3' ) . out ( i ) again ( pluck , d = 0.5 , i = i + 1 ) You can stack events easily by just calling S() multiple times. In the above example, it happens that pluck samples are nicely order and are generating a chord if you struck them in parallel. How cool! But wait, there is more to it: @swim def pluck ( d = 0.5 , i = 0 ): S ( '<pluck:[0:4]>' , octave = 6 ) . out ( i ) again ( pluck , d = 0.5 , i = i + 1 ) You can also stack sounds by using polyphony. With Sardine , polyphony is not a concept reserved to notes. Every pattern can be polyphonic (sample names, speeds, adresses, etc...). More examples... Check out the Demos section to find out how people are using the S sender. II - MIDI Sender The MIDI or M sender is a sender specialised for emitting MIDI note-on and note-off messages just like on a music tracker or DAW. It does not have a lot of arguments, and if you have some degree of familiarity with the MIDI protocol, you will feel at home pretty quickly: note : your note number, between 0 and 127 . You can of course use patterns, and patterns can be patterns of notes (special syntax for writing chords, scales, notes, etc...). Values are clamped. If you enter an incredibly big number, it will be clamped to 127 . The same thing goes for small or negative numbers that will be brought back to 0 . channel : your MIDI channel from 0 to 15 ( 1 to 16 in human parlance). velocity : amplitude of your note, between 0 and 127 . dur : duration of your note. Time between the note-on and note-off messages. This time, unlike almost everything else, is calculated in clock ticks . dur=40 means that the note-off will only come after 40 clock ticks, which can be a long time or a very short time depending on your current timing context. You will notice that the Link clock is ticking really fast compared to the MIDI one. That's it! You might wonder: where are my other MIDI messages? We got them covered too and you can pattern them of course. For now, the syntax is a bit old school and each MIDI message will have its own function but it won't last long :) cc(channel: int, control: int, value: int) : control change message. pgch(channel: int, program: int) : program change message. pwheel(channel: int, pitch: int) : pitch wheel message. sysex(data: list) : custom SYSEX message. My plan is to cover all of the messages. The page will be updated later with a new MM() Sender specialised in custom MIDI messages. Sending a note @swim def midi ( d = 0.5 , i = 0 ): M () . out () again ( midi , d = 0.5 , i = i + 1 ) No argument required to send a MIDI Note ( 60 ) at full velocity ( 127 ) on the first default MIDI channel. Arguments are only used to specify further or to override default values. Playing a tune @swim def midi ( d = 0.5 , i = 0 ): M ( note = 'C5,D5,E5,G5,E5,D5,G5,C5' ) . out ( i ) again ( midi , d = 0.5 , i = i + 1 ) Playing a little melody by tweaking the note argument. A bit better @swim def midi ( d = 0.5 , i = 0 ): M ( channel = '0,1,2,3' , velocity = '20 + (r*80)' , dur = 0.4 , note = 'C5,D5,E5,G5,E5,D5,G5,C5' ) . out ( i ) again ( midi , d = 0.5 , i = i + 1 ) The same melody spreaded out on three MIDI channels (one per note) with random velocity. Other messages @swim def midi ( d = 0.5 , i = 0 ): M ( channel = '0,1,2,3' , velocity = '20 + (r*80)' , dur = 0.4 , note = 'C5,D5,E5,G5,E5,D5,G5,C5' ) . out ( i ) pgch ( P ( '1,2,3,4' , i )) # switching cc ( channel = 0 , control = 20 , value = 50 ) # control again ( midi , d = 0.5 , i = i + 1 ) Switching between program 1 , 2 , 3 and 4 on your MIDI Synth. Sending a control change on channel 0 , number 20 for a value of 50 . More examples... Check out the Demos section to find out how people are using the M sender. III - OSC Sender The OSC Sender is the most complex and generic of all. It is a sender specialised for the Open Sound Control protocol. This is not because there are a lot of arguments and keyword arguments to learn but because using it relies on linking the sender to some other objects that will handle incoming or outgoing messages. It has the same body-tail architecture as the others but the arguments are a bit different: O ( osc_connexion , address , keyword = value_or_pattern , ... ) We always need to feed an OSC output port and an address. It perfeclty makes perfect sense if you are already familiar with OSC. You can pattern everything except the osc connexion. If you are clever enough, this won't stop you for long though. You will notice that you can do this if you really need to: gigantic_gundam = { '0' : left_arm_connexion , '1' : right_arm_connexion , '2' : left_leg_connexion , '3' : right_leg_connexion , '4' : head_connexion , } O ( osc_connexion [ P ( '0~4' , i )], 'x_pos' , value = 50 ) Sending OSC my_osc = OSC ( ip = \"127.0.0.1\" , port = 23000 , name = \"Bibu\" , ahead_amount = 0.25 ) This is the command you must use if you would like to create a new OSC client. The ahead_amount parameter is used to form the timetamp attached to your OSC message. If you are wondering, this is exactly the same value as the one you can tweak using c._superdirt_nudge when configuring your S sender. It can be useful for synchronisation purposes. Once this is done, you can use O() for sending OSC messages to that address: # Simple address O ( my_osc , 'loulou' , value = '1,2,3,4' ) . out () # Composed address (_ equals /) O ( my_osc , 'loulou/yves' , value = '1,2,3,4' ) . out () Note how O() takes an additional argument compared to other senders. You must provide a valid OSC client for it to work because you can have multiple senders sending at different addresses. Everything else is patternable like usual. Receiving OSC You can also receive and track incoming OSC values. In fact, you can even attach callbacks to incoming OSC messages and turn Sardine into a soundbox so let's do it! info = Receiver ( 25000 ) def funny_sound (): S ( 'bip' , shape = 0.9 , room = 0.9 ) . out () info . attach ( '/bip/' , funny_sound ) Yeah, that's everything you need! In the above example, we are declaring a new Receiver object that maps to a given port on the given IP address (with localhost being the default). All we have to do next is to map a function to every message being received at that address and poof. We now have a working soundbox. Let's break this down and take a look at all the features you can do when receiving OSC. Let's take a look at the Receiver : info = Receiver ( port , ip , name ) You will find your usual suspects: port , ip and name (that is not used for anything useful really). There are three methods you can call on your Receiver object: .attach(address: str, function: Callable, watch: bool) : attach a callback to a given address. It must be a function. Additionally, you can set watch to True ( False by default) to also run the .watch method automatically afterhands. .watch(address: str) : give an address. The object will track the last received value on that address. If nothing has been received yet, it will return None instead of crashing \\o/. .get(address) : retrieve the last received value to that address. You must have used .watch() before to register this address to be watched. Otherwise, you will get nothing. Blending OSC If you are receiving something, you can now use it in your patterns to map a captor, a sensor or a controller to a Sardine pattern. If you combo this with amphibian-variables , you can now contaminate your patterns with values coming from your incoming data: info = Receiver ( 25000 ) info . watch ( '/sitar/speed/' ) @swim def contamination ( d = 0.5 , i = 0 ): v . a = info . get ( '/sitar/speed/' )[ 'args' ][ 0 ] S ( 'sitar' , speed = 'v.a' ) . out () a ( contamination , d = 0.5 , i = i + 1 ) This opens up the way for environmental reactive patterns that can be modified on-the-fly and that will blend code and human interaction. Handling data received from OSC can be a bit tricky at first: if you wish to carefully take care of the data you receive, please use the .attach() method to attach a callback to every message received and properly handle the data yourself. Use the form callback(*args, **kwargs) and examine what data you receive in the args and kwargs . Map this to global variables, etc... if you don't care and just want to watch values as they go, please use the .watch() value but you will have to resort to using dictionnary key access just like I do in the example above. You will have to handle cases where no data is received or cases where the received value is not of the right type. There is no memory of old messages, only the most recent one is kept in memory! This is not ideal for some of you who do a lot of things with OSC . Please provide suggestions, open issues, etc... We will sort this out together!","title":"Senders"},{"location":"documentation/sardinopedia/senders/#i-anatomy-of-senders","text":"A Sender is an event generator . It describes one event. This event can mutate depending on multiple factors such as patterns, randomness, chance operations, clever Python string formatting, etc... A single sender can be arbitrarily long depending on the precision you want to give to each event. This object will only take one method : .out() . Wait? A long object, and a tail method? Does it ring a bell? It looks... just like a sardine. /`-._ /`-._ _/,.._/ _/,.._/ ,-' , `-:,.-') _ ,-' , `-:,.-') _ : S(...):'; _ { .out(_) : M(...):'; _ { .out(_) ... and more `-. `' _,.-\\`-.) + `-. `' _,.-\\`-.) + `\\\\``\\,.-' `\\\\``\\,.-'","title":"I - Anatomy of Senders"},{"location":"documentation/sardinopedia/senders/#writing-the-body","text":"Every sender ( M() , O() , S() ) is an object taking arguments and keyword arguments . Arguments are mandatory , and keyword arguments optional. These arguments will define your event: S ( 'bd' , speed = '[1:2,0.5]' , legato = 1 , shape = 0.5 ) # Heavy drumbass M ( note = 'C@min7^1' , dur = 2 , channel = 0 ) # Short MIDI chord You will have to learn what arguments each sender can receive. They all have a speciality. Despite the fact that they look and behave similarly, the event they describe is very different in nature depending on the type. Warning Note that Sardine is still missing some pieces. There is currently no way to easily pattern some very common MIDI messages such as control changes , program changes , etc... Don't worry! You can still pattern all of this very easily by doing cc(control=P('0,1,2',i), value=P('1~127')) . It's a just a bit more verbose compared to what it could be if ever I was feeling like adding this to the codebase! It will eventually happen, I promise!","title":"Writing the body"},{"location":"documentation/sardinopedia/senders/#precising-the-tail","text":"The tail of a sender is always the .out() method. Without it, no message is sent. We have already seen the tail in the swimming functions section. If you are here because of it, you've found the right place to look at! The .out() method takes three arguments: i ( int ): the iterator for patterning. Mandatory for the two other arguments to work properly. This iterator is the index of the values extracted from your linear list-like patterns (your arguments and keyword arguments ). How this index will be interpreted will depend on the next two arguments. div ( int ): a timing divisor . It is very much alike a modulo operation. If div=4 , the event will be emitted once every 4 iterations. The default is div=1 , where every event is a hit! Be careful not to set a div=1 on a very fast swimming function as it could result in catastrophic failure / horrible noises. There is no parachute out in the open sea. rate ( float ): a speed factor for iterating over pattern values. It will slow down or speed up the iteration speed, the speed at which the pattern values are indexed on. For the pattern 1, 2, 3 and a rate of 0.5 , the result will be perceptually similar to 1, 1, 2, 2, 3, 3 . I know, it doesn't make any sense written like so.. That's something you have to see represented differently. Take a look at tail arguments values. Notice how different values will produce different iteration speeds: Now, try exploring this idea using this dummy pattern: @swim def ocean_periodicity ( d = 0.5 , i = 0 ): S ( 'bd, hhh, sn, hhh' , speed = '1,2' , freq = 'r*800' ) . out ( i , 2 , 0.5 ) a ( ocean_periodicity , d = 0.5 , i = i + 1 ) Don't touch to the pattern itself, just change values in the .out() method. Try to be more familiar with it. You can change the recursion speed to notice more clearly how the pattern will evolve with time.","title":"Precising the tail"},{"location":"documentation/sardinopedia/senders/#tips-for-writing-senders","text":"Python is extremely flexible and expressive. The language makes it a breeze to compose arguments and keyword arguments in very fun and creative ways. I don't even have to code anything to support this and I'm very grateful that the language takes care of everything for me! Let's take an example. You can for instance store parameters common to multiple messages in a list/dictionary before sticking them to your patterns using the * and ** idiom: params = { 'loud' : { 'amp' : 2 , 'shape' : 0.9 }, 'soft' : { 'amp' : 0.1 , 'legato' : 0.1 }} S ( 'bd' , ** params [ 'loud' ]) There is also a hidden benefit to separating the .out() method from the object initialisation. You can store events somewhere without having to send them immediately. : drumkit = { 'bass' : S ( 'bd' ), 'hat' : S ( 'hhh' ), 'snare' : S ( 'sn' )} drumkit [ 'bass' ] . out () These examples look very verbose, but try to imagine cases where they will save you from an even more verbose situation . It can happen very quickly when you try to play with many events at the same time, or when you will start imagining grouping sounds together or modifying multiple parameters in different events at the same time.","title":"Tips for writing Senders"},{"location":"documentation/sardinopedia/senders/#ii-the-sound-sender","text":"The Sound or SuperDirt sender is a sender specialised in talking with SuperCollider and more specifically with the sound engine used by TidalCycles . I'm using the synthesis / sampling backend written and supported by Julian Rohrhuber that many live-coders worldwide are also using. It is very stable, very flexible and highly-configurable. This sender is the most complex you will have to interact with and it is entirely optional if you wish to use Sardine only to sequence MIDI and OSC messages. If we dive into its architecture, we will soon find out that this sender is a specialised OSC sender that talks exclusively with SuperDirt using special timestamped messages. The body of the sender is always: S ( 'sound' , keyword = value_or_pattern , keyword2 = value_or_pattern ) The first argument defining the sound or synthesizer you are willing to trigger is not optional. Without it, you can be sure that the sender will crash because it cannot apply parameters to something that is not defined. The keyword parameters are the names of your SuperDirt parameters. It can be standard parameters, orbit parameters (audio bus) or parameters related to the synthesizer you are using. You will find more about this in the Reference section that is listing pretty much all of them! You will feel a bit lost at first but this is a case where you learn a lot by doing and from experience. Take a look at the following examples.","title":"II - The Sound Sender"},{"location":"documentation/sardinopedia/senders/#simple-bassdrum","text":"@swim def bd ( d = 0.5 ): S ( 'bd' ) . out () again ( bd , d = 0.5 ) A simple bassdrum playing on every half-beat. This is the most basic sound-making function you can write.","title":"Simple Bassdrum"},{"location":"documentation/sardinopedia/senders/#complex-bassdrum","text":"@swim def bd ( d = 0.5 ): S ( 'bd' , speed = 'r*4' , legato = 'r' , cutoff = '100+0~4000' ) . out () again ( bd , d = 0.25 ) A simple bassdrum but some parameters have been tweaked to add some randomness to the result. See how patterns can be used to make your keyword arguments more dynamic. The additional parameters are : speed will reverse (<0), slow (0-1), or accelerate the sample (>1) by altering the playback speed. The r token provides randomization between 0.0 and 1.0 ( float ). legato defines the maximum duration of the sample before cutting it, here randomized in the 0 to 1 range. cutoff will attenuate some frequencies. This is the cutoff frequency of a lowpass filter that shuts down frequencies higher to the frequency cutoff. The cutoff frequency is guaranteed to be at least 100 plus a certain amount between 0 and 4000 .","title":"Complex Bassdrum"},{"location":"documentation/sardinopedia/senders/#simple-breakbeat","text":"@swim def bd ( d = 0.5 , i = 0 ): S ( 'amencutup:0~20' ) . out ( i ) again ( bd , d = 0.25 , i = i + 1 ) Picking a random sample in a folder containing slices of the classic amen break . You could have a successful career doing this in front of audiences. Once again, the magic happens with the sample:r*X notation, which randomizes which sample is read on each execution, making it unpredictable.","title":"Simple Breakbeat"},{"location":"documentation/sardinopedia/senders/#sample-sequencing","text":"@swim def bd ( d = 0.5 , i = 0 ): S ( 'bd,hh,sn,hh' ) . out ( i ) again ( bd , d = 0.5 , i = i + 1 ) Your classic four-on-the-floor written on one line. One sound is played after the other. All arguments and keyword arguments can be patterned.","title":"Sample sequencing"},{"location":"documentation/sardinopedia/senders/#piling-up-polyphony","text":"@swim def pluck ( d = 0.5 , i = 0 ): S ( 'pluck' ) . out ( i ) S ( 'pluck:1' ) . out ( i ) S ( 'pluck:2' ) . out ( i ) S ( 'pluck:3' ) . out ( i ) again ( pluck , d = 0.5 , i = i + 1 ) You can stack events easily by just calling S() multiple times. In the above example, it happens that pluck samples are nicely order and are generating a chord if you struck them in parallel. How cool! But wait, there is more to it: @swim def pluck ( d = 0.5 , i = 0 ): S ( '<pluck:[0:4]>' , octave = 6 ) . out ( i ) again ( pluck , d = 0.5 , i = i + 1 ) You can also stack sounds by using polyphony. With Sardine , polyphony is not a concept reserved to notes. Every pattern can be polyphonic (sample names, speeds, adresses, etc...).","title":"Piling up / Polyphony"},{"location":"documentation/sardinopedia/senders/#more-examples","text":"Check out the Demos section to find out how people are using the S sender.","title":"More examples..."},{"location":"documentation/sardinopedia/senders/#ii-midi-sender","text":"The MIDI or M sender is a sender specialised for emitting MIDI note-on and note-off messages just like on a music tracker or DAW. It does not have a lot of arguments, and if you have some degree of familiarity with the MIDI protocol, you will feel at home pretty quickly: note : your note number, between 0 and 127 . You can of course use patterns, and patterns can be patterns of notes (special syntax for writing chords, scales, notes, etc...). Values are clamped. If you enter an incredibly big number, it will be clamped to 127 . The same thing goes for small or negative numbers that will be brought back to 0 . channel : your MIDI channel from 0 to 15 ( 1 to 16 in human parlance). velocity : amplitude of your note, between 0 and 127 . dur : duration of your note. Time between the note-on and note-off messages. This time, unlike almost everything else, is calculated in clock ticks . dur=40 means that the note-off will only come after 40 clock ticks, which can be a long time or a very short time depending on your current timing context. You will notice that the Link clock is ticking really fast compared to the MIDI one. That's it! You might wonder: where are my other MIDI messages? We got them covered too and you can pattern them of course. For now, the syntax is a bit old school and each MIDI message will have its own function but it won't last long :) cc(channel: int, control: int, value: int) : control change message. pgch(channel: int, program: int) : program change message. pwheel(channel: int, pitch: int) : pitch wheel message. sysex(data: list) : custom SYSEX message. My plan is to cover all of the messages. The page will be updated later with a new MM() Sender specialised in custom MIDI messages.","title":"II - MIDI Sender"},{"location":"documentation/sardinopedia/senders/#sending-a-note","text":"@swim def midi ( d = 0.5 , i = 0 ): M () . out () again ( midi , d = 0.5 , i = i + 1 ) No argument required to send a MIDI Note ( 60 ) at full velocity ( 127 ) on the first default MIDI channel. Arguments are only used to specify further or to override default values.","title":"Sending a note"},{"location":"documentation/sardinopedia/senders/#playing-a-tune","text":"@swim def midi ( d = 0.5 , i = 0 ): M ( note = 'C5,D5,E5,G5,E5,D5,G5,C5' ) . out ( i ) again ( midi , d = 0.5 , i = i + 1 ) Playing a little melody by tweaking the note argument.","title":"Playing a tune"},{"location":"documentation/sardinopedia/senders/#a-bit-better","text":"@swim def midi ( d = 0.5 , i = 0 ): M ( channel = '0,1,2,3' , velocity = '20 + (r*80)' , dur = 0.4 , note = 'C5,D5,E5,G5,E5,D5,G5,C5' ) . out ( i ) again ( midi , d = 0.5 , i = i + 1 ) The same melody spreaded out on three MIDI channels (one per note) with random velocity.","title":"A bit better"},{"location":"documentation/sardinopedia/senders/#other-messages","text":"@swim def midi ( d = 0.5 , i = 0 ): M ( channel = '0,1,2,3' , velocity = '20 + (r*80)' , dur = 0.4 , note = 'C5,D5,E5,G5,E5,D5,G5,C5' ) . out ( i ) pgch ( P ( '1,2,3,4' , i )) # switching cc ( channel = 0 , control = 20 , value = 50 ) # control again ( midi , d = 0.5 , i = i + 1 ) Switching between program 1 , 2 , 3 and 4 on your MIDI Synth. Sending a control change on channel 0 , number 20 for a value of 50 .","title":"Other messages"},{"location":"documentation/sardinopedia/senders/#more-examples_1","text":"Check out the Demos section to find out how people are using the M sender.","title":"More examples..."},{"location":"documentation/sardinopedia/senders/#iii-osc-sender","text":"The OSC Sender is the most complex and generic of all. It is a sender specialised for the Open Sound Control protocol. This is not because there are a lot of arguments and keyword arguments to learn but because using it relies on linking the sender to some other objects that will handle incoming or outgoing messages. It has the same body-tail architecture as the others but the arguments are a bit different: O ( osc_connexion , address , keyword = value_or_pattern , ... ) We always need to feed an OSC output port and an address. It perfeclty makes perfect sense if you are already familiar with OSC. You can pattern everything except the osc connexion. If you are clever enough, this won't stop you for long though. You will notice that you can do this if you really need to: gigantic_gundam = { '0' : left_arm_connexion , '1' : right_arm_connexion , '2' : left_leg_connexion , '3' : right_leg_connexion , '4' : head_connexion , } O ( osc_connexion [ P ( '0~4' , i )], 'x_pos' , value = 50 )","title":"III - OSC Sender"},{"location":"documentation/sardinopedia/senders/#sending-osc","text":"my_osc = OSC ( ip = \"127.0.0.1\" , port = 23000 , name = \"Bibu\" , ahead_amount = 0.25 ) This is the command you must use if you would like to create a new OSC client. The ahead_amount parameter is used to form the timetamp attached to your OSC message. If you are wondering, this is exactly the same value as the one you can tweak using c._superdirt_nudge when configuring your S sender. It can be useful for synchronisation purposes. Once this is done, you can use O() for sending OSC messages to that address: # Simple address O ( my_osc , 'loulou' , value = '1,2,3,4' ) . out () # Composed address (_ equals /) O ( my_osc , 'loulou/yves' , value = '1,2,3,4' ) . out () Note how O() takes an additional argument compared to other senders. You must provide a valid OSC client for it to work because you can have multiple senders sending at different addresses. Everything else is patternable like usual.","title":"Sending OSC"},{"location":"documentation/sardinopedia/senders/#receiving-osc","text":"You can also receive and track incoming OSC values. In fact, you can even attach callbacks to incoming OSC messages and turn Sardine into a soundbox so let's do it! info = Receiver ( 25000 ) def funny_sound (): S ( 'bip' , shape = 0.9 , room = 0.9 ) . out () info . attach ( '/bip/' , funny_sound ) Yeah, that's everything you need! In the above example, we are declaring a new Receiver object that maps to a given port on the given IP address (with localhost being the default). All we have to do next is to map a function to every message being received at that address and poof. We now have a working soundbox. Let's break this down and take a look at all the features you can do when receiving OSC. Let's take a look at the Receiver : info = Receiver ( port , ip , name ) You will find your usual suspects: port , ip and name (that is not used for anything useful really). There are three methods you can call on your Receiver object: .attach(address: str, function: Callable, watch: bool) : attach a callback to a given address. It must be a function. Additionally, you can set watch to True ( False by default) to also run the .watch method automatically afterhands. .watch(address: str) : give an address. The object will track the last received value on that address. If nothing has been received yet, it will return None instead of crashing \\o/. .get(address) : retrieve the last received value to that address. You must have used .watch() before to register this address to be watched. Otherwise, you will get nothing.","title":"Receiving OSC"},{"location":"documentation/sardinopedia/senders/#blending-osc","text":"If you are receiving something, you can now use it in your patterns to map a captor, a sensor or a controller to a Sardine pattern. If you combo this with amphibian-variables , you can now contaminate your patterns with values coming from your incoming data: info = Receiver ( 25000 ) info . watch ( '/sitar/speed/' ) @swim def contamination ( d = 0.5 , i = 0 ): v . a = info . get ( '/sitar/speed/' )[ 'args' ][ 0 ] S ( 'sitar' , speed = 'v.a' ) . out () a ( contamination , d = 0.5 , i = i + 1 ) This opens up the way for environmental reactive patterns that can be modified on-the-fly and that will blend code and human interaction. Handling data received from OSC can be a bit tricky at first: if you wish to carefully take care of the data you receive, please use the .attach() method to attach a callback to every message received and properly handle the data yourself. Use the form callback(*args, **kwargs) and examine what data you receive in the args and kwargs . Map this to global variables, etc... if you don't care and just want to watch values as they go, please use the .watch() value but you will have to resort to using dictionnary key access just like I do in the example above. You will have to handle cases where no data is received or cases where the received value is not of the right type. There is no memory of old messages, only the most recent one is kept in memory! This is not ideal for some of you who do a lot of things with OSC . Please provide suggestions, open issues, etc... We will sort this out together!","title":"Blending OSC"},{"location":"documentation/sardinopedia/supercollider/","text":"I - Sardine architecture A) General concept If you have installed Sardine alongside SuperCollider and SuperDirt , you know that Sardine can boot its own SuperDirt session, etc.. If you haven't been live coding for several years, all of this might seem a little bit shady. We assume that things are working properly but we never detail the underlying infrastructure. Let's break it down: Sardine is doing the patterning, it is your control library. SuperCollider is the general audio engine. It is almighty. SuperDirt makes it easy to talk with SuperCollider in a live-coding context. It was originally designed to work hands-in-hands with TidalCycles but of course you can hijack it which is what Sardine is doing. Sardine is an independant piece of software. By design, it doesn't need SuperCollider to work. You can live an happy life by just sending OSC and MIDI using Sardine and never bridging with SC. However, if you do so, you will have to manage the connexion, to know how to deal with SuperCollider , etc... Sardine is not capable of emitting sound, it is more akin to a general sequencing brain that simplifies input and output communication for you during the improvisation process. B) Limitations Sardine is not designed to handle the digital signal processing or the reality of scheduling / generating / controlling audio signals. Python is not an efficient or particularly optimised language (although things are changing a little bit nowadays..). Sardine is already performing a lot of weird tricks to stay afloat in an almost real-time context. It is not perfect but hopefully it will evolve and reach perfect stability. Sardine was initially conceived in a music studio on a small laptop surrounded by audio equipment waiting for instructions. The idea was to delegate the audio processing to external hardware / softwares and to fully focus on live control / live sequencing. I would love to keep it that way because there is a lof of exciting solutions to explore for sound / audio design such as Faust , SuperCollider , CSound , and the list goes on and on . You can emulate part of the signal logic with patterns but it will never be as good compared to what a DSP language can offer. II - Talking to SuperDirt / SuperCollider If you choose to boot SuperCollider and SuperDirt alongside Sardine in your sardine-config , everything should fall in place. You have one main Python process handling everything for you so you don't have to start things manually. If you don't, you can always start SuperCollider yourself and manage two separate applications that will happily collaborate through the network. A) Interesting goodies Let's assume that SuperDirt has started, and that you received the message saying that the audio engine is ready. You can now interact with the SC() object that represents your SC subprocess. Let's open up a VUMeter of our session: SC . meter () All good, let's open some other windows as well. SC . meter () SC . scope () SC . freqscope () You can open sound visualisation tools from the active SuperCollider session by running any of the commands above. Here is a short explanation of what each function do: SC.meter() : open a window showing VUMeters for each and every physical sound output. SC.scope() : open an oscilloscope to visualise every audio bus currently declared. SC.freqscope() : open a frequency spectrum visualizer of the global audio output. B) Sending code to SuperCollider You can pipe code from your Sardine session to SuperCollider . Of course, this is not the best interface ever, but it can surely help to run short commands or to open an article from the SuperCollider documentation. To see SuperDirt documentation, you can type the following: SC . send ( 'SuperDirt.help' ) You will have to work without syntax highlighting. Copying and pasting short and useful commands is probably better if you are not an experienced SuperCollider user. There are no bindings for the SuperCollider server implemented into Sardine . Be sure that I am monitoring packages that are proposing solutions for this but I am not ready to write my own bindings for now. There is too much work to handle with Sardine itself before thinking about branching out. If that's your thing, you can integrate small SC snippets in your patterns and sequence them with a decent enough time precision: # Generating a sinewave oscillating at 200hz. SC . send ( 'a={SinOsc.ar(200) * 0.1}; b = a.play;' ) # Freing the synth SC . send ( 'b.free' )","title":"SuperDirt"},{"location":"documentation/sardinopedia/supercollider/#i-sardine-architecture","text":"","title":"I - Sardine architecture"},{"location":"documentation/sardinopedia/supercollider/#a-general-concept","text":"If you have installed Sardine alongside SuperCollider and SuperDirt , you know that Sardine can boot its own SuperDirt session, etc.. If you haven't been live coding for several years, all of this might seem a little bit shady. We assume that things are working properly but we never detail the underlying infrastructure. Let's break it down: Sardine is doing the patterning, it is your control library. SuperCollider is the general audio engine. It is almighty. SuperDirt makes it easy to talk with SuperCollider in a live-coding context. It was originally designed to work hands-in-hands with TidalCycles but of course you can hijack it which is what Sardine is doing. Sardine is an independant piece of software. By design, it doesn't need SuperCollider to work. You can live an happy life by just sending OSC and MIDI using Sardine and never bridging with SC. However, if you do so, you will have to manage the connexion, to know how to deal with SuperCollider , etc... Sardine is not capable of emitting sound, it is more akin to a general sequencing brain that simplifies input and output communication for you during the improvisation process.","title":"A) General concept"},{"location":"documentation/sardinopedia/supercollider/#b-limitations","text":"Sardine is not designed to handle the digital signal processing or the reality of scheduling / generating / controlling audio signals. Python is not an efficient or particularly optimised language (although things are changing a little bit nowadays..). Sardine is already performing a lot of weird tricks to stay afloat in an almost real-time context. It is not perfect but hopefully it will evolve and reach perfect stability. Sardine was initially conceived in a music studio on a small laptop surrounded by audio equipment waiting for instructions. The idea was to delegate the audio processing to external hardware / softwares and to fully focus on live control / live sequencing. I would love to keep it that way because there is a lof of exciting solutions to explore for sound / audio design such as Faust , SuperCollider , CSound , and the list goes on and on . You can emulate part of the signal logic with patterns but it will never be as good compared to what a DSP language can offer.","title":"B) Limitations"},{"location":"documentation/sardinopedia/supercollider/#ii-talking-to-superdirt-supercollider","text":"If you choose to boot SuperCollider and SuperDirt alongside Sardine in your sardine-config , everything should fall in place. You have one main Python process handling everything for you so you don't have to start things manually. If you don't, you can always start SuperCollider yourself and manage two separate applications that will happily collaborate through the network.","title":"II - Talking to SuperDirt / SuperCollider"},{"location":"documentation/sardinopedia/supercollider/#a-interesting-goodies","text":"Let's assume that SuperDirt has started, and that you received the message saying that the audio engine is ready. You can now interact with the SC() object that represents your SC subprocess. Let's open up a VUMeter of our session: SC . meter () All good, let's open some other windows as well. SC . meter () SC . scope () SC . freqscope () You can open sound visualisation tools from the active SuperCollider session by running any of the commands above. Here is a short explanation of what each function do: SC.meter() : open a window showing VUMeters for each and every physical sound output. SC.scope() : open an oscilloscope to visualise every audio bus currently declared. SC.freqscope() : open a frequency spectrum visualizer of the global audio output.","title":"A) Interesting goodies"},{"location":"documentation/sardinopedia/supercollider/#b-sending-code-to-supercollider","text":"You can pipe code from your Sardine session to SuperCollider . Of course, this is not the best interface ever, but it can surely help to run short commands or to open an article from the SuperCollider documentation. To see SuperDirt documentation, you can type the following: SC . send ( 'SuperDirt.help' ) You will have to work without syntax highlighting. Copying and pasting short and useful commands is probably better if you are not an experienced SuperCollider user. There are no bindings for the SuperCollider server implemented into Sardine . Be sure that I am monitoring packages that are proposing solutions for this but I am not ready to write my own bindings for now. There is too much work to handle with Sardine itself before thinking about branching out. If that's your thing, you can integrate small SC snippets in your patterns and sequence them with a decent enough time precision: # Generating a sinewave oscillating at 200hz. SC . send ( 'a={SinOsc.ar(200) * 0.1}; b = a.play;' ) # Freing the synth SC . send ( 'b.free' )","title":"B) Sending code to SuperCollider"},{"location":"technical/configuration/","text":"This page will help you to learn how to configure Sardine . You will soon figure out that Sardine is really modular in nature and it has been designed to be altered. You can toggle on and off certain features, you can pre-configure many things and fine-tune to be up and ready for your next sessions, etc... I - Code Editors You can use Sardine directly from the Python interpreter. There is nothing wrong about it, but you will be pretty limited in what you can do. You might also dislike the fact that popups will be printed pretty frequently if you make mistakes. It is sometimes enough to run quick sound/MIDI tests but not much more. After a while, you will figure out that working this way is fairly cumbersome and you will likely be searching for a better text editor. Sardine code can become quite verbose when dealing with complex swimming functions. As you might have guessed already, there is no Sardine plugin for VSCode , Atom or any popular code editor yet . However, Sardine is just Python and there are great plugins to deal with interactive Python code already. Here are a few things you can try. Vim / Neovim Neovim (and by extension Vim ) is the editor I currently use on stage but the target audience for this software is mostly developers, old Unix gurus and command-line users. Vim is a modal text editor with multiple modes for editing, jumping around and composing text. It can be extended using plugins and can be augmented and tweaked to your liking. Quite powerful, but quite hard and required some learning to be proficient. The process for working with Sardine from Neovim is pretty straightforward: 1) install the slime plugin. 2) split your workspace in two vertical ( :vs ) or horizontal ( :sp ) panes. 3) open up a :terminal in one of them and run python3 -m fishery . 4) work in the other one and use C-cC-c to send code from one side to the other. VSCode VSCode is a powerful and all-devouring code editor developed by Microsoft. It is the most widely spread code editor out there, with millions of users, thousands of plugins and corporate support. VSCode is more than capable of handling Sardine sessions and there are multiple ways to configure everything for it. The best technique 1) install the Python support for VSCode (usually proposed whenever you open a Python file). 2) open the configuration menu and search for Python launch args . Click on Modify in settings.json 3) write the following: \"python.terminal.launchArgs\" : [ \"-m\" , \"asyncio\" ], 4) You are done! To start a new Sardine session, open any .py file and type: from sardine import * Press Shift+Enter and wait for the new Python terminal to show up. You can now start typing Sardine code, you are good to go! You will need to select the code you want to run before sending it to the console. The Jupyter route and there might be more than one way to do it. I will present you one way of doing it, using the Jupyter extension. install VSCode and the Jupyter Notebook plugin. To do so, open the Extensions pane on the left (it looks like crates) and search for the extension name. Click install and wait a moment. Create a new .ipynb notebook either by yourself or by using the plugin-backed command. Make sure that you are using the right Python version as your kernel (3.10). run: import sys ; ! { sys . executable } - m pip install \"/path/to/sardine\" restart the kernel and run: import sys sys . path . insert ( 0 , '/path/to/sardine' ) from sardine import * From now on, Sardine is installed in the notebook you just created. You can write cells containing your Sardine code, which makes it easy to work with. Some plugins allow you to write and manage cells directly using source code, using symbols akin to comment strings. More on this later! Emacs The venerable Emacs is of course able to do what the other ones are doing and it is particularly well suited for the task of running interpreted code. Please use the python.el plugin. This mode will allow you to pipe easily your code from a text buffer to a running interpeter. The plugin is adding quality-of-life features for working with Python in general but also makes working with a REPL much easier and much more convenient. If you are new to the vast world of Emacs, it is probably worthwhile to take a look at Doom Emacs or Spacemacs , both being really great distributions of plugins. I will not dive into more details, as Emacs users are generally able to figure out their prefered way of working by themselves :) II - Configuration options Sardine is relying on a configuration folder that will be silently created the first time you open it. The path leading to the configuration folder can be printed out by typing print_config() . This command will also print out the content of your main configuration file. How practical! There are three files you can tweak to configure Sardine : config.json : main Sardine configuration file. default_superdirt.scd : SuperDirt configuration file. user_configuration.py : Python code runned everytime you boot Sardine (facultative). There is also a synths folder made to store synthesis definitions (synthesizers, effects). synths folder: store new synthesizers written with SuperCollider , usually one synth per .scd file . A - Sardine The config.json file will allow you to finetune Sardine by choosing a default MIDI port, a default PPQN ( pulses per quarter note , used for the MIDI Clock), and BPM ( beats per minute ), etc... You can edit it manually but you don't have too. There is a tool made for that, installed by default on your $PATH . Access it by typing sardine-config . Sardine can generate its own MIDI port which is very convenient if you don't have any virtual MIDI port ready to be hijacked. This feature however is limited to MacOS/Linux. Here is a rundown of what each option is doing in the config file: Syntax Description active_clock Whether the MIDI Clock must be active (ticking and sending clock messages) or passive (waiting for a clock) beats number of beats per bar boot_superdirt whether Sardine should boot its own instance of SuperDirt when it starts bpm default tempo (you can change it later by running c.bpm = x ) debug print the raw result of every pattern (used by devs) deferred_scheduling low-level option used by devs to troubleshot scheduling (not exposed in the config tool) midi your default MIDI port. If the port is Sardine or internal , Sardine will create its own MIDI port ppqn Pulses per quarter note, the lowest rhythmical division Sardine can handle. 24 or 48 are safe values config_paths various paths for the files used by configuration B - SuperDirt The default_superdirt.scd is... your default SuperDirt configuration. You must edit it manually if you are willing to load more audio samples, change your audio outputs or add anything that you need on the SuperCollider side. The synths folder is a repository for your SynthDefs file. Each synthesizer should be saved in its own file and will be loaded automatically at boot time. How to tweak the SuperDirt file The SuperDirt repository is a good place to start, especially the hacks/ folder that will teach you how to edit and configure SuperDirt to your liking. SuperDirt was initially conceived for TidalCycles, and there is more documentation about Tidal and its usage than documentation about anything Sardine . Editing the SuperDirt file directly from the terminal If you know how to work with text files from the terminal using vim or nano , there is a command available to open the default SuperDirt configuration file: sardine-config-superdirt . It will open up the file using $EDITOR . Be sure to configure it beforehand! Here is an example showing of how to load more audio samples to play with: ( s . reboot { s . options . numBuffers = 1024 * 256 ; s . options . memSize = 8192 * 32 ; s . options . numWireBufs = 128 ; s . options . maxNodes = 1024 * 32 ; s . options . numOutputBusChannels = 2 ; s . options . numInputBusChannels = 2 ; s . waitForBoot { ~ dirt = SuperDirt ( 2 , s ); ~ dirt . loadSoundFiles ; ~ dirt . loadSoundFiles ( \"/Users/bubo/Dropbox/MUSIQUE/LIVE_SMC/DRUMS/*\" ); s . sync ; ~ dirt . start ( 57120 , 0 ! 12 ); ( ~ d1 = ~ dirt . orbits [ 0 ]; ~ d2 = ~ dirt . orbits [ 1 ]; ~ d3 = ~ dirt . orbits [ 2 ]; ~ d4 = ~ dirt . orbits [ 3 ]; ~ d5 = ~ dirt . orbits [ 4 ]; ~ d6 = ~ dirt . orbits [ 5 ]; ~ d7 = ~ dirt . orbits [ 6 ]; ~ d8 = ~ dirt . orbits [ 7 ]; ~ d9 = ~ dirt . orbits [ 8 ]; ~ d10 = ~ dirt . orbits [ 9 ]; ~ d11 = ~ dirt . orbits [ 10 ]; ~ d12 = ~ dirt . orbits [ 11 ]; ); }; s . latency = 0.3 ; }; ) How to include a new sample folder SuperDirt treats a wildcard ( * ) at the end of the path to mean that there are named subdirectories. If you want to load just one sample directory, omit the wildcard. Many people already use the SuperDirt audio backend for live-coding, more specifically people working with TidalCycles . You will find a lot of configuration tips, tools and extensions by searching in the TOPLAP / Tidal communities forums and chats. C - Python The last configuration file is named user_configuration.py . It is not created by default. It must be added manually if you wish to use this feature. All the code placed in this file will be imported by default everytime you boot Sardine . It is an incredibely useful feature to automate some things: functions, aliases, classes, OSC and MIDI connexions. Starting some musical code, aka 'art installation' mode for museums, openings, etc... You will be able to manually take over after init if you ever wished to change parameters. Do not break Sardine Make sure not to override any of the defaults. This file will run after init, and can override basic Sardine functionalities if you are not careful enough.","title":"Configuration tools"},{"location":"technical/configuration/#i-code-editors","text":"You can use Sardine directly from the Python interpreter. There is nothing wrong about it, but you will be pretty limited in what you can do. You might also dislike the fact that popups will be printed pretty frequently if you make mistakes. It is sometimes enough to run quick sound/MIDI tests but not much more. After a while, you will figure out that working this way is fairly cumbersome and you will likely be searching for a better text editor. Sardine code can become quite verbose when dealing with complex swimming functions. As you might have guessed already, there is no Sardine plugin for VSCode , Atom or any popular code editor yet . However, Sardine is just Python and there are great plugins to deal with interactive Python code already. Here are a few things you can try.","title":"I - Code Editors"},{"location":"technical/configuration/#vim-neovim","text":"Neovim (and by extension Vim ) is the editor I currently use on stage but the target audience for this software is mostly developers, old Unix gurus and command-line users. Vim is a modal text editor with multiple modes for editing, jumping around and composing text. It can be extended using plugins and can be augmented and tweaked to your liking. Quite powerful, but quite hard and required some learning to be proficient. The process for working with Sardine from Neovim is pretty straightforward: 1) install the slime plugin. 2) split your workspace in two vertical ( :vs ) or horizontal ( :sp ) panes. 3) open up a :terminal in one of them and run python3 -m fishery . 4) work in the other one and use C-cC-c to send code from one side to the other.","title":"Vim / Neovim"},{"location":"technical/configuration/#vscode","text":"VSCode is a powerful and all-devouring code editor developed by Microsoft. It is the most widely spread code editor out there, with millions of users, thousands of plugins and corporate support. VSCode is more than capable of handling Sardine sessions and there are multiple ways to configure everything for it.","title":"VSCode"},{"location":"technical/configuration/#the-best-technique","text":"1) install the Python support for VSCode (usually proposed whenever you open a Python file). 2) open the configuration menu and search for Python launch args . Click on Modify in settings.json 3) write the following: \"python.terminal.launchArgs\" : [ \"-m\" , \"asyncio\" ], 4) You are done! To start a new Sardine session, open any .py file and type: from sardine import * Press Shift+Enter and wait for the new Python terminal to show up. You can now start typing Sardine code, you are good to go! You will need to select the code you want to run before sending it to the console.","title":"The best technique"},{"location":"technical/configuration/#the-jupyter-route","text":"and there might be more than one way to do it. I will present you one way of doing it, using the Jupyter extension. install VSCode and the Jupyter Notebook plugin. To do so, open the Extensions pane on the left (it looks like crates) and search for the extension name. Click install and wait a moment. Create a new .ipynb notebook either by yourself or by using the plugin-backed command. Make sure that you are using the right Python version as your kernel (3.10). run: import sys ; ! { sys . executable } - m pip install \"/path/to/sardine\" restart the kernel and run: import sys sys . path . insert ( 0 , '/path/to/sardine' ) from sardine import * From now on, Sardine is installed in the notebook you just created. You can write cells containing your Sardine code, which makes it easy to work with. Some plugins allow you to write and manage cells directly using source code, using symbols akin to comment strings. More on this later!","title":"The Jupyter route"},{"location":"technical/configuration/#emacs","text":"The venerable Emacs is of course able to do what the other ones are doing and it is particularly well suited for the task of running interpreted code. Please use the python.el plugin. This mode will allow you to pipe easily your code from a text buffer to a running interpeter. The plugin is adding quality-of-life features for working with Python in general but also makes working with a REPL much easier and much more convenient. If you are new to the vast world of Emacs, it is probably worthwhile to take a look at Doom Emacs or Spacemacs , both being really great distributions of plugins. I will not dive into more details, as Emacs users are generally able to figure out their prefered way of working by themselves :)","title":"Emacs"},{"location":"technical/configuration/#ii-configuration-options","text":"Sardine is relying on a configuration folder that will be silently created the first time you open it. The path leading to the configuration folder can be printed out by typing print_config() . This command will also print out the content of your main configuration file. How practical! There are three files you can tweak to configure Sardine : config.json : main Sardine configuration file. default_superdirt.scd : SuperDirt configuration file. user_configuration.py : Python code runned everytime you boot Sardine (facultative). There is also a synths folder made to store synthesis definitions (synthesizers, effects). synths folder: store new synthesizers written with SuperCollider , usually one synth per .scd file .","title":"II - Configuration options"},{"location":"technical/configuration/#a-sardine","text":"The config.json file will allow you to finetune Sardine by choosing a default MIDI port, a default PPQN ( pulses per quarter note , used for the MIDI Clock), and BPM ( beats per minute ), etc... You can edit it manually but you don't have too. There is a tool made for that, installed by default on your $PATH . Access it by typing sardine-config . Sardine can generate its own MIDI port which is very convenient if you don't have any virtual MIDI port ready to be hijacked. This feature however is limited to MacOS/Linux. Here is a rundown of what each option is doing in the config file: Syntax Description active_clock Whether the MIDI Clock must be active (ticking and sending clock messages) or passive (waiting for a clock) beats number of beats per bar boot_superdirt whether Sardine should boot its own instance of SuperDirt when it starts bpm default tempo (you can change it later by running c.bpm = x ) debug print the raw result of every pattern (used by devs) deferred_scheduling low-level option used by devs to troubleshot scheduling (not exposed in the config tool) midi your default MIDI port. If the port is Sardine or internal , Sardine will create its own MIDI port ppqn Pulses per quarter note, the lowest rhythmical division Sardine can handle. 24 or 48 are safe values config_paths various paths for the files used by configuration","title":"A - Sardine"},{"location":"technical/configuration/#b-superdirt","text":"The default_superdirt.scd is... your default SuperDirt configuration. You must edit it manually if you are willing to load more audio samples, change your audio outputs or add anything that you need on the SuperCollider side. The synths folder is a repository for your SynthDefs file. Each synthesizer should be saved in its own file and will be loaded automatically at boot time. How to tweak the SuperDirt file The SuperDirt repository is a good place to start, especially the hacks/ folder that will teach you how to edit and configure SuperDirt to your liking. SuperDirt was initially conceived for TidalCycles, and there is more documentation about Tidal and its usage than documentation about anything Sardine . Editing the SuperDirt file directly from the terminal If you know how to work with text files from the terminal using vim or nano , there is a command available to open the default SuperDirt configuration file: sardine-config-superdirt . It will open up the file using $EDITOR . Be sure to configure it beforehand! Here is an example showing of how to load more audio samples to play with: ( s . reboot { s . options . numBuffers = 1024 * 256 ; s . options . memSize = 8192 * 32 ; s . options . numWireBufs = 128 ; s . options . maxNodes = 1024 * 32 ; s . options . numOutputBusChannels = 2 ; s . options . numInputBusChannels = 2 ; s . waitForBoot { ~ dirt = SuperDirt ( 2 , s ); ~ dirt . loadSoundFiles ; ~ dirt . loadSoundFiles ( \"/Users/bubo/Dropbox/MUSIQUE/LIVE_SMC/DRUMS/*\" ); s . sync ; ~ dirt . start ( 57120 , 0 ! 12 ); ( ~ d1 = ~ dirt . orbits [ 0 ]; ~ d2 = ~ dirt . orbits [ 1 ]; ~ d3 = ~ dirt . orbits [ 2 ]; ~ d4 = ~ dirt . orbits [ 3 ]; ~ d5 = ~ dirt . orbits [ 4 ]; ~ d6 = ~ dirt . orbits [ 5 ]; ~ d7 = ~ dirt . orbits [ 6 ]; ~ d8 = ~ dirt . orbits [ 7 ]; ~ d9 = ~ dirt . orbits [ 8 ]; ~ d10 = ~ dirt . orbits [ 9 ]; ~ d11 = ~ dirt . orbits [ 10 ]; ~ d12 = ~ dirt . orbits [ 11 ]; ); }; s . latency = 0.3 ; }; ) How to include a new sample folder SuperDirt treats a wildcard ( * ) at the end of the path to mean that there are named subdirectories. If you want to load just one sample directory, omit the wildcard. Many people already use the SuperDirt audio backend for live-coding, more specifically people working with TidalCycles . You will find a lot of configuration tips, tools and extensions by searching in the TOPLAP / Tidal communities forums and chats.","title":"B - SuperDirt"},{"location":"technical/configuration/#c-python","text":"The last configuration file is named user_configuration.py . It is not created by default. It must be added manually if you wish to use this feature. All the code placed in this file will be imported by default everytime you boot Sardine . It is an incredibely useful feature to automate some things: functions, aliases, classes, OSC and MIDI connexions. Starting some musical code, aka 'art installation' mode for museums, openings, etc... You will be able to manually take over after init if you ever wished to change parameters. Do not break Sardine Make sure not to override any of the defaults. This file will run after init, and can override basic Sardine functionalities if you are not careful enough.","title":"C - Python"},{"location":"technical/installation/","text":"Installation The installation of Sardine is done in two separate steps that you can go through in any order: [MANDATORY] Installing / configuring of the Sardine library and your text editor. [RECOMMENDED] Installing / configuration the audio backend ( SuperDirt ). Installing Sardine Sardine is still an experimental software and it has not yet been fully packaged. You can be up and running in minutes if everything is going fine. Depending on your proficiency level with programming tools, you might find it to be a challenge to setup Sardine for the first time. For regular Unix users, programmers, and old-school users of the command line, the process will be a breeze. Most of the setup process is straightforward but some parts of it might need some caution and monitoring on your behalf. We are doing our best to make the installation process as fast and as painless as possible. This will take some time and efforts on our side! Installing from Pypi or from a package manager Installation of Sardine using Pypi is not yet available. Of course, Sardine will be added when it will be ready for everyone to use! The first planned milestone is the 0.1 version that should be released later this year (2022). Until then, you should install it manually! The first released version will greatly simplify the installation process. Sardine by itself is just a program that does I/O ( Input / Output ) of various musical information. It is up to you to configure the rest so that it can make sound! The better part is that you can configure it however you like for whatever musical purpose you have in mind :) By installing everything correctly, you will be able to integrate Sardine with almost any musical application. Sardine is a multi-layered 'lasagna-style' software The hard part is not to install Sardine per se , which is just a regular Python program. The hard part is to setup the whole stack: sound engine, synchronization libraries, etc... I - Library For Windows Users only Sardine is particularly tricky to install for users running Windows. This is due to the fact that Sardine depends on rtmidi (no wheels for Python 3.10) and link (relies on pybind11 ). These packages are bindings for existing C++ code used extensively for important chunks of the application. Without the proper development related tools, you might not be able to install Sardine . Please make sure that you install the following before proceeding with the installation: MSVC Build Tools ( Microsoft Visual Studio Code Build Tools ). CMake : a tool used to build, test and configure softwares. Sardine can be installed like any other Python package using pip , the official package manager. Installing and updating Python 1) Install Python for your operating system (>=3.10). Update if needed ! 2) Open a terminal and type python or python3 for extra safety. A prompt will open telling you what version you currently default to. Please make sure that you are running at least Python 3.10. Python 3.11 is not officially supported! Being aware of your installed Python versions is of tremendous importance. You can have multiple versions of Python running on your system, some being required by your operating system, some being installed by other applications. They sometimes end up piling up. Find the command that will summon your Python 3.10 installation (can be python , python3 , python3.10 depending on the system you are currently using).. You can now safely proceed to download and install Sardine : Fishing a Sardine 1) Install Git or download the project from GitHub and place it wherever you like! If you take the Git route, clone Sardine (' git clone https://github.com/Bubobubobubobubo/Sardine '). 2) Using a shell or cmd (in admin-mode), run python3 -m pip install -e . in the sardine folder. Be careful, there is a dot at the end of the command! If you are using Linux or MacOS, use sudo to install with the highest priviledges. This is usually not recommended but it can help with the installation of other Sardine components. This command can take quite some time depending on your internet connexion, your computer specifications, etc... It will install Sardine as well as all the packages and libraries needed to get it running. This is likely the step where you will start noticing crashes, errors and sometimes some truly cryptic messages. Please watch carefully, and do not let an error pass without notice. This might result in a broken / uncomplete installation of Sardine . Wait until the end of the process. To test if Sardine is installed properly, execute the following commands in your terminal: python3 - m asyncio from sardine import * You should now see a big bright SARDINE written on your screen. Congratulations! This is the indication that Sardine was able to start! II - Audio engine Installation Installing SuperCollider and SuperDirt Refer to the SuperDirt installation guide for your platform. It will guide you through the installation of SuperCollider and SuperDirt . It is usually a three step process: install SuperCollider . run Quarks.install(\"SuperDirt\") in the SCIDE window. run SuperDirt.start to start the engine. SC3-plugins You might want to check out SC3-plugins . These plugins will dramatically increase the possibilities if you have planned to use sampling or the internal synthesis engine quite a lot! SuperDirt is the optional but very much recommended synthesis engine for Sardine . As a matter of fact, Sardine was initially built as an alternative client for SuperDirt . It is a well-known freen and open source piece of software used by live coders. SuperDirt is mostly developed by Julian Rohrhuber, and intended to be used initially for TidalCycles , a truly great live coding library. It is meant to be used via a simple message-based syntax converted into SuperDirt instructions that can trigger samples, synthesizers and do many other things, taking care of the finicky details. Note that it also means that your Sardine configuration will be valid and portable to TidalCycles alternatively. III - Configuration Sardine is perfectly capable of booting both SuperCollider and SuperDirt by itself. However, this mechanism is disabled by default because I can't assume that you will have it installed and configured properly! You can turn on the SuperDirt autoboot feature by tweaking the configuration. Open up the configuration tool by typing: sardine-config Follow the menus to configure Sardine to your liking but remember to turn on the autoboot feature if you need it. Explore the menus a bit to understand all the things you can configure, we will come back to it later on. Sardine is very modular, you can enable or disable features very easily. If the sardine-config utility tool is missing, try reinstalling Sardine in admnistrator mode ( sudo on Unix systems). If Python returns a message such as: \"WARNING: The scripts sardine-config, sardine-config-python and sardine-config-superdirt are installed in '/opt/local/Library/Frameworks/Python.framework/Versions/3.10/bin' which is not on PATH.\" Please add the given location on your PATH . Words of caution About the autoboot feature Sardine will assume that SuperCollider (and more specifically sclang ) is accessible on your $PATH . Everything should run just fine if you install it in the default folder for your platform. On some specific systems, you might need to locate the sclang executable and to add it to $PATH . The autoboot feature can cause trouble among newcomers and unexperienced live-coders. There is a bazillion ways SuperCollider and SuperDirt can refuse to boot, crash or cease to function all of the sudden. Consult the troubleshot page for more information about frequent issues. I recommend to boot SuperCollider and Sardine separately for new users so that they can keep an eye on both sides. To do so, turn off the autoboot feature and start Sardine and SuperCollider separately, each in their own window. Type SuperDirt.start to start the latter manually from the SuperCollider side. To start anew if any error arise, type Server.killAll to restart SuperCollider to a blank slate. IV - Code Editor Pick the editor you prefer from the following list. All of them have been tested with Sardine! It's only a matter of preference. List of Sardine compatible text editors VSCode : great for everyone, from newcomers to exprienced users. Vim : fast, powerful, ubiquitous. Modal editor that requires some learning. Neovim : the modernized version of Vim, configurable using Lua. Emacs : Emacs is everything and can do anything. Jupyter Notebook : A data-science oriented tool that can support Sardine . Working and making music with Sardine is usually done following the same method for all editors: 1) Opening a new blank .py file (no need to save). 2) Launching a terminal in the same coding environment 3) Sending lines of code from the code buffer to the terminal buffer. If you already know how to do that for you, great! If you don't, please head to the configuration section where additional help concerning your editor of choice will be written. Conclusion You should now have Sardine (and possibly SuperDirt ) installed. You can fine-tune your Sardine installation by running the configuration client: sardine-config This is the main configuration tool for Sardine . We will come back to it later. If the command is not found or if nothing happens, Sardine might not be installed correctly. Please, worry and review the preceding steps! You might get a message saying that you have no configuration file. Take for a guarantee that Sardine is installed! This is perfectly normal. By default, there is no configuration file until it is created the first time you start Sardine . Open a new interactive Sardine session by running python3 -m fishery . If everything is alright, some popup messages will be printed and you will be left on a prompt ( >>> ) waiting for your input: If you have opted to use the SuperDirt audio backend, you can start checking if everything is fine by playing a clap or a kickdrum : S ( 'cp' ) . out () If you want to play a note on your MIDI Synth, use this command instead: M () . out () If you hear the clap or the note you were expecting, you are good to go! Have fun! Trivia Alternative boot methods So far, we've used the fast boot method for Sardine : python3 - m fishery Note that you can boot Sardine manually in a two-step process: 1) python3 -m asyncio : start the asyncio REPL 2) from sardine import ** : import Sardine library","title":"Installing Sardine"},{"location":"technical/installation/#installation","text":"The installation of Sardine is done in two separate steps that you can go through in any order: [MANDATORY] Installing / configuring of the Sardine library and your text editor. [RECOMMENDED] Installing / configuration the audio backend ( SuperDirt ). Installing Sardine Sardine is still an experimental software and it has not yet been fully packaged. You can be up and running in minutes if everything is going fine. Depending on your proficiency level with programming tools, you might find it to be a challenge to setup Sardine for the first time. For regular Unix users, programmers, and old-school users of the command line, the process will be a breeze. Most of the setup process is straightforward but some parts of it might need some caution and monitoring on your behalf. We are doing our best to make the installation process as fast and as painless as possible. This will take some time and efforts on our side! Installing from Pypi or from a package manager Installation of Sardine using Pypi is not yet available. Of course, Sardine will be added when it will be ready for everyone to use! The first planned milestone is the 0.1 version that should be released later this year (2022). Until then, you should install it manually! The first released version will greatly simplify the installation process. Sardine by itself is just a program that does I/O ( Input / Output ) of various musical information. It is up to you to configure the rest so that it can make sound! The better part is that you can configure it however you like for whatever musical purpose you have in mind :) By installing everything correctly, you will be able to integrate Sardine with almost any musical application. Sardine is a multi-layered 'lasagna-style' software The hard part is not to install Sardine per se , which is just a regular Python program. The hard part is to setup the whole stack: sound engine, synchronization libraries, etc...","title":"Installation"},{"location":"technical/installation/#i-library","text":"For Windows Users only Sardine is particularly tricky to install for users running Windows. This is due to the fact that Sardine depends on rtmidi (no wheels for Python 3.10) and link (relies on pybind11 ). These packages are bindings for existing C++ code used extensively for important chunks of the application. Without the proper development related tools, you might not be able to install Sardine . Please make sure that you install the following before proceeding with the installation: MSVC Build Tools ( Microsoft Visual Studio Code Build Tools ). CMake : a tool used to build, test and configure softwares. Sardine can be installed like any other Python package using pip , the official package manager. Installing and updating Python 1) Install Python for your operating system (>=3.10). Update if needed ! 2) Open a terminal and type python or python3 for extra safety. A prompt will open telling you what version you currently default to. Please make sure that you are running at least Python 3.10. Python 3.11 is not officially supported! Being aware of your installed Python versions is of tremendous importance. You can have multiple versions of Python running on your system, some being required by your operating system, some being installed by other applications. They sometimes end up piling up. Find the command that will summon your Python 3.10 installation (can be python , python3 , python3.10 depending on the system you are currently using).. You can now safely proceed to download and install Sardine : Fishing a Sardine 1) Install Git or download the project from GitHub and place it wherever you like! If you take the Git route, clone Sardine (' git clone https://github.com/Bubobubobubobubo/Sardine '). 2) Using a shell or cmd (in admin-mode), run python3 -m pip install -e . in the sardine folder. Be careful, there is a dot at the end of the command! If you are using Linux or MacOS, use sudo to install with the highest priviledges. This is usually not recommended but it can help with the installation of other Sardine components. This command can take quite some time depending on your internet connexion, your computer specifications, etc... It will install Sardine as well as all the packages and libraries needed to get it running. This is likely the step where you will start noticing crashes, errors and sometimes some truly cryptic messages. Please watch carefully, and do not let an error pass without notice. This might result in a broken / uncomplete installation of Sardine . Wait until the end of the process. To test if Sardine is installed properly, execute the following commands in your terminal: python3 - m asyncio from sardine import * You should now see a big bright SARDINE written on your screen. Congratulations! This is the indication that Sardine was able to start!","title":"I - Library"},{"location":"technical/installation/#ii-audio-engine","text":"","title":"II - Audio engine"},{"location":"technical/installation/#installation_1","text":"Installing SuperCollider and SuperDirt Refer to the SuperDirt installation guide for your platform. It will guide you through the installation of SuperCollider and SuperDirt . It is usually a three step process: install SuperCollider . run Quarks.install(\"SuperDirt\") in the SCIDE window. run SuperDirt.start to start the engine. SC3-plugins You might want to check out SC3-plugins . These plugins will dramatically increase the possibilities if you have planned to use sampling or the internal synthesis engine quite a lot! SuperDirt is the optional but very much recommended synthesis engine for Sardine . As a matter of fact, Sardine was initially built as an alternative client for SuperDirt . It is a well-known freen and open source piece of software used by live coders. SuperDirt is mostly developed by Julian Rohrhuber, and intended to be used initially for TidalCycles , a truly great live coding library. It is meant to be used via a simple message-based syntax converted into SuperDirt instructions that can trigger samples, synthesizers and do many other things, taking care of the finicky details. Note that it also means that your Sardine configuration will be valid and portable to TidalCycles alternatively.","title":"Installation"},{"location":"technical/installation/#iii-configuration","text":"Sardine is perfectly capable of booting both SuperCollider and SuperDirt by itself. However, this mechanism is disabled by default because I can't assume that you will have it installed and configured properly! You can turn on the SuperDirt autoboot feature by tweaking the configuration. Open up the configuration tool by typing: sardine-config Follow the menus to configure Sardine to your liking but remember to turn on the autoboot feature if you need it. Explore the menus a bit to understand all the things you can configure, we will come back to it later on. Sardine is very modular, you can enable or disable features very easily. If the sardine-config utility tool is missing, try reinstalling Sardine in admnistrator mode ( sudo on Unix systems). If Python returns a message such as: \"WARNING: The scripts sardine-config, sardine-config-python and sardine-config-superdirt are installed in '/opt/local/Library/Frameworks/Python.framework/Versions/3.10/bin' which is not on PATH.\" Please add the given location on your PATH .","title":"III - Configuration"},{"location":"technical/installation/#words-of-caution","text":"About the autoboot feature Sardine will assume that SuperCollider (and more specifically sclang ) is accessible on your $PATH . Everything should run just fine if you install it in the default folder for your platform. On some specific systems, you might need to locate the sclang executable and to add it to $PATH . The autoboot feature can cause trouble among newcomers and unexperienced live-coders. There is a bazillion ways SuperCollider and SuperDirt can refuse to boot, crash or cease to function all of the sudden. Consult the troubleshot page for more information about frequent issues. I recommend to boot SuperCollider and Sardine separately for new users so that they can keep an eye on both sides. To do so, turn off the autoboot feature and start Sardine and SuperCollider separately, each in their own window. Type SuperDirt.start to start the latter manually from the SuperCollider side. To start anew if any error arise, type Server.killAll to restart SuperCollider to a blank slate.","title":"Words of caution"},{"location":"technical/installation/#iv-code-editor","text":"Pick the editor you prefer from the following list. All of them have been tested with Sardine! It's only a matter of preference. List of Sardine compatible text editors VSCode : great for everyone, from newcomers to exprienced users. Vim : fast, powerful, ubiquitous. Modal editor that requires some learning. Neovim : the modernized version of Vim, configurable using Lua. Emacs : Emacs is everything and can do anything. Jupyter Notebook : A data-science oriented tool that can support Sardine . Working and making music with Sardine is usually done following the same method for all editors: 1) Opening a new blank .py file (no need to save). 2) Launching a terminal in the same coding environment 3) Sending lines of code from the code buffer to the terminal buffer. If you already know how to do that for you, great! If you don't, please head to the configuration section where additional help concerning your editor of choice will be written.","title":"IV - Code Editor"},{"location":"technical/installation/#conclusion","text":"You should now have Sardine (and possibly SuperDirt ) installed. You can fine-tune your Sardine installation by running the configuration client: sardine-config This is the main configuration tool for Sardine . We will come back to it later. If the command is not found or if nothing happens, Sardine might not be installed correctly. Please, worry and review the preceding steps! You might get a message saying that you have no configuration file. Take for a guarantee that Sardine is installed! This is perfectly normal. By default, there is no configuration file until it is created the first time you start Sardine . Open a new interactive Sardine session by running python3 -m fishery . If everything is alright, some popup messages will be printed and you will be left on a prompt ( >>> ) waiting for your input: If you have opted to use the SuperDirt audio backend, you can start checking if everything is fine by playing a clap or a kickdrum : S ( 'cp' ) . out () If you want to play a note on your MIDI Synth, use this command instead: M () . out () If you hear the clap or the note you were expecting, you are good to go! Have fun!","title":"Conclusion"},{"location":"technical/installation/#trivia","text":"","title":"Trivia"},{"location":"technical/installation/#alternative-boot-methods","text":"So far, we've used the fast boot method for Sardine : python3 - m fishery Note that you can boot Sardine manually in a two-step process: 1) python3 -m asyncio : start the asyncio REPL 2) from sardine import ** : import Sardine library","title":"Alternative boot methods"},{"location":"technical/troubleshot/","text":"Troubleshot This page will guide you along if you need to debug Sardine . It can be anything ranging from problems while installing it to problems encountered during performance. If you encounter an issue that is currently not documented here, please forward it by using the issue tracker on GitHub or by directly sending a mail out to me :) Broken Sardines Some bugs and issues are related to Sardine itself. I try to document the errors encountered by users as much as I can but I still lack feedback on the installation process for different systems, etc.. You might also have different use cases that I might not have anticipated. python3 -m fishery : no module named ... [ALL] : This is likely the sign of an incomplete Sardine installation. Please make sure that you have MSVC (Windows), gcc (Linux) or clang (MacOS) installed and that you have also installed CMake . The installation failed because some libraries couldn't compile. By failing more or less silently, some other dependencies have not been installed. This is the mythical broken sardine . python-rtmidi fails on install [LINUX/MACOS] : Installation fails on python-rtmidi build . Its probably because you missed libjack development files ( libjack-dev or libjack-jack2-dev ). You can install it with sudo apt-get install libjack-dev on Debian based systems, with brew for MacOS, and with pacman for any other Arch-based system. jack.h missing on install [MACOS] : Install fails on python-rtmidi build . You might have JackOSX installed. Remove it entirely from your system and rely on CoreAudio . Nothing personal against Jack , it just confuses the compilation process of python-rtmidi ! uvloop warning or errors [WINDOWS ONLY] : uvloop does not work on Windows. Fortunately, you can still run Sardine but you might have some issues targetting blindly a specific tempo. You will sometimes (?) have to drastically slow down the clock for it to work (~20bpm is a safe value)! This might be linked to a different implementation of asyncio on Windows. This issue is currently being investigated and is not fairly common. SuperDirt related I don't hear any sound at all! Check that --boot_superdirt is True in your sardine-config : sardine-config --boot_superdirt True Check that your audio output and microphone are running at the sample rate: 44100 or 48000hz on both sides (audio output / input). You can check this using your operating system usual configuration tools. Note that pluging in and out a microphone can change the sampling rate automatically. I still can't hear anything! Sometimes, when you play around with booting and quiting Sardine repeatedly, your computer might start to get confused about who is using some of the network connections or not. You now have zombie connexions blocking the I/O process from happening ( Sardine can't match with SuperCollider , etc...). This can also happen simply by opening multiple instances of Sardine . If that is to happen, please make sure to: kill every instance of Sardine and SuperCollider and the code editors that hosted them. run Server.killAll in a brand-new SuperCollider window. You can now start again.","title":"Troubleshooting"},{"location":"technical/troubleshot/#troubleshot","text":"This page will guide you along if you need to debug Sardine . It can be anything ranging from problems while installing it to problems encountered during performance. If you encounter an issue that is currently not documented here, please forward it by using the issue tracker on GitHub or by directly sending a mail out to me :)","title":"Troubleshot"},{"location":"technical/troubleshot/#broken-sardines","text":"Some bugs and issues are related to Sardine itself. I try to document the errors encountered by users as much as I can but I still lack feedback on the installation process for different systems, etc.. You might also have different use cases that I might not have anticipated. python3 -m fishery : no module named ... [ALL] : This is likely the sign of an incomplete Sardine installation. Please make sure that you have MSVC (Windows), gcc (Linux) or clang (MacOS) installed and that you have also installed CMake . The installation failed because some libraries couldn't compile. By failing more or less silently, some other dependencies have not been installed. This is the mythical broken sardine . python-rtmidi fails on install [LINUX/MACOS] : Installation fails on python-rtmidi build . Its probably because you missed libjack development files ( libjack-dev or libjack-jack2-dev ). You can install it with sudo apt-get install libjack-dev on Debian based systems, with brew for MacOS, and with pacman for any other Arch-based system. jack.h missing on install [MACOS] : Install fails on python-rtmidi build . You might have JackOSX installed. Remove it entirely from your system and rely on CoreAudio . Nothing personal against Jack , it just confuses the compilation process of python-rtmidi ! uvloop warning or errors [WINDOWS ONLY] : uvloop does not work on Windows. Fortunately, you can still run Sardine but you might have some issues targetting blindly a specific tempo. You will sometimes (?) have to drastically slow down the clock for it to work (~20bpm is a safe value)! This might be linked to a different implementation of asyncio on Windows. This issue is currently being investigated and is not fairly common.","title":"Broken Sardines"},{"location":"technical/troubleshot/#superdirt-related","text":"I don't hear any sound at all! Check that --boot_superdirt is True in your sardine-config : sardine-config --boot_superdirt True Check that your audio output and microphone are running at the sample rate: 44100 or 48000hz on both sides (audio output / input). You can check this using your operating system usual configuration tools. Note that pluging in and out a microphone can change the sampling rate automatically. I still can't hear anything! Sometimes, when you play around with booting and quiting Sardine repeatedly, your computer might start to get confused about who is using some of the network connections or not. You now have zombie connexions blocking the I/O process from happening ( Sardine can't match with SuperCollider , etc...). This can also happen simply by opening multiple instances of Sardine . If that is to happen, please make sure to: kill every instance of Sardine and SuperCollider and the code editors that hosted them. run Server.killAll in a brand-new SuperCollider window. You can now start again.","title":"SuperDirt related"}]}